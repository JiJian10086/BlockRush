<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Rush - Blockchain Tower Defense</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0a0a1a 100%);
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(0, 100, 200, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 200, 255, 0.08) 0%, transparent 50%),
                linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0a0a1a 100%);
            overflow: hidden;
            user-select: none;
        }
        
        #gameCanvas {
            display: block;
        }
        
        .neon-text {
            text-shadow: 0 0 3px rgba(0, 255, 255, 0.5), 0 0 6px rgba(0, 255, 255, 0.3);
        }
        
        .neon-border {
            box-shadow: 0 0 10px #00ffff, inset 0 0 10px rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
        }
        
        .tower-btn {
            transition: all 0.3s;
            cursor: grab;
            position: relative;
        }
        
        .tower-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px currentColor;
        }
        
        .tower-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(100%);
            background: rgba(20, 20, 20, 0.9) !important;
        }
        
        .tower-btn.locked:hover {
            transform: none;
            box-shadow: none;
        }
        
        .tower-btn.locked::after {
            content: '🔒';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            opacity: 0.8;
            pointer-events: none;
        }
        
        .tower-btn.affordable {
            animation: affordablePulse 2s ease-in-out infinite;
            box-shadow: 0 0 15px currentColor;
        }
        
        .tower-btn.not-affordable {
            opacity: 0.5;
            filter: brightness(0.6);
        }
        
        @keyframes affordablePulse {
            0%, 100% {
                box-shadow: 0 0 10px currentColor;
            }
            50% {
                box-shadow: 0 0 20px currentColor, 0 0 30px currentColor;
            }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100vh); }
        }
        
        /* Language Selector Styles */
        .language-dropdown {
            position: relative;
        }
        
        .language-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #00ffff;
            border-radius: 6px;
            color: #00ffff;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .language-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 10px #00ffff;
        }
        
        .dropdown-arrow {
            font-size: 10px;
            transition: transform 0.3s;
        }
        
        .language-btn.active .dropdown-arrow {
            transform: rotate(180deg);
        }
        
        .language-dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: rgba(0, 20, 40, 0.95);
            border: 1px solid #00ffff;
            border-radius: 6px;
            overflow: hidden;
            backdrop-filter: blur(10px);
            min-width: 120px;
        }
        
        .language-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
        }
        
        .language-option:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        .language-flag {
            font-size: 16px;
        }
        
        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            opacity: 0.3;
            animation: scanline 3s linear infinite;
            pointer-events: none;
        }
        
        #tooltip {
            position: fixed;
            background: rgba(0, 20, 40, 0.95);
            border: 1px solid #00ffff;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        #tooltip::-webkit-scrollbar {
            width: 4px;
        }
        
        #tooltip::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 2px;
        }
        
        #tooltip::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.5);
            border-radius: 2px;
        }
        
        #tooltip::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 255, 0.8);
        }
        
        .wave-announce {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff0040;
            text-shadow: 0 0 20px #ff0040, 0 0 40px #ff0040;
            animation: waveAnnounce 2s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }
        
        @keyframes waveAnnounce {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }
        
        .enemy-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 10, 20, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }
        
        .enemy-modal {
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.98), rgba(0, 20, 40, 0.98));
            border: 3px solid #ff0044;
            border-radius: 15px;
            padding: 30px 40px;
            max-width: 450px;
            text-align: center;
            animation: modalAppear 0.3s ease-out;
        }
        
        @keyframes modalAppear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .enemy-modal-icon {
            font-size: 64px;
            margin-bottom: 15px;
        }
        
        .enemy-modal-title {
            font-size: 28px;
            color: #fff;
            margin-bottom: 10px;
        }
        
        .enemy-modal-desc {
            color: #aaa;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .enemy-modal-tip {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 13px;
        }
        
        .enemy-modal-btn {
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 12px 40px;
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 5px;
        }
        
        .enemy-modal-btn:hover {
            background: #00ffff;
            color: #0a0a1a;
            box-shadow: 0 0 20px #00ffff;
        }
        
        .knowledge-modal {
            border-color: #00ffff !important;
            border-width: 4px !important;
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.90), rgba(0, 20, 40, 0.90)) !important;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5) !important;
        }
        
        .knowledge-modal .enemy-modal-icon {
            display: none !important;
        }
        
        .knowledge-modal .enemy-modal-title {
            font-size: 32px !important;
            margin-top: 0 !important;
        }
        
        .knowledge-modal .enemy-modal-desc {
            text-align: center !important;
            line-height: 2 !important;
            font-size: 16px !important;
            color: #ddd !important;
        }
        
        #startScreen {
            position: fixed;
            inset: 0;
            background: 
                linear-gradient(rgba(0, 10, 20, 0.7), rgba(0, 10, 20, 0.7)),
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 800"><defs><pattern id="hexagons" x="0" y="0" width="60" height="52" patternUnits="userSpaceOnUse"><path d="M30,0 L45,13 L45,39 L30,52 L15,39 L15,13 Z" fill="none" stroke="rgba(0,200,255,0.15)" stroke-width="0.5"/></pattern><linearGradient id="grad1" x1="0%25" y1="0%25" x2="100%25" y2="100%25"><stop offset="0%25" style="stop-color:rgba(0,100,200,0.2)"/><stop offset="100%25" style="stop-color:rgba(0,200,255,0.1)"/></linearGradient></defs><rect width="1200" height="800" fill="url(%23grad1)"/><rect width="1200" height="800" fill="url(%23hexagons)"/><line x1="100" y1="100" x2="300" y2="200" stroke="rgba(0,200,255,0.3)" stroke-width="1"/><line x1="300" y1="200" x2="500" y2="150" stroke="rgba(0,200,255,0.3)" stroke-width="1"/><line x1="900" y1="600" x2="1100" y2="700" stroke="rgba(0,200,255,0.3)" stroke-width="1"/><circle cx="100" cy="100" r="3" fill="rgba(0,255,255,0.6)"/><circle cx="300" cy="200" r="3" fill="rgba(0,255,255,0.6)"/><circle cx="500" cy="150" r="3" fill="rgba(0,255,255,0.6)"/><circle cx="900" cy="600" r="3" fill="rgba(0,255,255,0.6)"/><circle cx="1100" cy="700" r="3" fill="rgba(0,255,255,0.6)"/><text x="50" y="120" fill="rgba(0,200,255,0.4)" font-family="monospace" font-size="10">01101010</text><text x="850" y="620" fill="rgba(255,0,200,0.4)" font-family="monospace" font-size="10">11010110</text></svg>');
            background-size: cover;
            background-position: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        #gameOverScreen, #victoryScreen, #pauseScreen {
            position: fixed;
            inset: 0;
            background: rgba(0, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
        }
        
        #victoryScreen.slide-up {
            animation: slideUpFromBottom 1.5s ease-out forwards;
        }
        
        @keyframes slideUpFromBottom {
            0% {
                transform: translateY(100%);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        #spacePauseOverlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 20, 40, 0.3);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 180;
            pointer-events: none;
        }
        
        #spacePauseOverlay .pause-indicator {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px 40px;
            text-align: center;
        }
        
        .game-btn {
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 40px;
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px;
        }
        
        .game-btn:hover {
            background: #00ffff;
            color: #0a0a1a;
            box-shadow: 0 0 30px #00ffff;
        }
        
        #sellPanel {
            position: fixed;
            display: none;
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #ff6600;
            border-radius: 10px;
            padding: 15px;
            z-index: 160;
            min-width: 180px;
        }
        
        .sell-btn {
            background: rgba(255, 0, 68, 0.2);
            border: 1px solid #ff0044;
            color: #ff0044;
            padding: 8px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            width: 100%;
            transition: all 0.2s;
        }
        
        .sell-btn:hover {
            background: #ff0044;
            color: white;
        }
        
        #cannonTargetOverlay {
            position: fixed;
            inset: 0;
            display: none;
            z-index: 170;
            cursor: crosshair;
        }
        
        .cannon-hint {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 100, 0, 0.9);
            border: 2px solid #ff6600;
            padding: 15px 30px;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            text-align: center;
        }
        
        #helpPanel {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: rgba(5, 15, 30, 0.95);
            border-left: 2px solid #00ffff;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 150;
            overflow-y: auto;
            box-shadow: -5px 0 30px rgba(0, 255, 255, 0.2);
        }
        
        #helpPanel.open {
            transform: translateX(0);
        }
        
        #helpToggle {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ffff;
            border-right: none;
            color: #00ffff;
            padding: 15px 10px;
            cursor: pointer;
            z-index: 151;
            border-radius: 10px 0 0 10px;
            transition: all 0.3s;
            font-family: 'Orbitron', monospace;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }
        
        #helpToggle:hover {
            background: #00ffff;
            color: #0a0a1a;
        }
        
        #helpToggle.panel-open {
            right: 320px;
        }
        
        .help-section {
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding: 15px;
        }
        
        .help-title {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .help-content {
            color: #a0a0a0;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .help-item {
            background: rgba(0, 255, 255, 0.05);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .help-item-title {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .help-item-desc {
            color: #888;
            font-size: 11px;
            line-height: 1.5;
        }
        
        /* Keyboard Key Style */
        .key {
            display: inline-block;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 4px 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 13px;
            color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            min-width: 32px;
            text-align: center;
        }
        
        /* Tab Styles */
        .knowledge-tab {
            padding: 8px 24px;
            background: transparent;
            border: 2px solid #666;
            border-radius: 5px;
            color: #888;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .knowledge-tab.active {
            background: rgba(0, 255, 255, 0.2) !important;
            border-color: #00ffff !important;
            color: #00ffff !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .knowledge-tab:not(.active):hover {
            border-color: #00ffff;
            color: #00ffff;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Hotkey Grid */
        .hotkey-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .knowledge-box {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 100, 150, 0.1));
            border: 1px dashed #00ffff;
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 10px;
            color: #00ffff;
        }
        
        #helpPanel::-webkit-scrollbar {
            width: 6px;
        }
        
        #helpPanel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        
        #helpPanel::-webkit-scrollbar-thumb {
            background: #00ffff;
            border-radius: 3px;
        }
        
        .tower-menu-scroll {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 10px;
            max-width: 90vw;
        }
        
        .tower-menu-scroll::-webkit-scrollbar {
            height: 6px;
        }
        
        .tower-menu-scroll::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        
        .tower-menu-scroll::-webkit-scrollbar-thumb {
            background: #00ffff;
            border-radius: 3px;
        }
        
        #levelSelectScreen, #knowledgeLibraryScreen {
            position: fixed;
            inset: 0;
            background: rgba(0, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .knowledge-item {
            background: linear-gradient(135deg, rgba(0, 40, 60, 0.7), rgba(0, 20, 40, 0.7));
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .knowledge-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border-color: #00ffff;
        }
        
        .knowledge-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: #666;
        }
        
        .knowledge-item.locked:hover {
            transform: none;
            box-shadow: none;
        }
        
        .knowledge-item-icon {
            font-size: 32px;
            flex-shrink: 0;
        }
        
        .knowledge-item-content {
            flex: 1;
            text-align: left;
        }
        
        .knowledge-item-title {
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 4px;
        }
        
        .knowledge-item-desc {
            font-size: 12px;
            color: #888;
        }
        
        .level-card {
            --level-color: #00ffff;
            background: linear-gradient(135deg, rgba(0, 40, 60, 0.9), rgba(0, 20, 40, 0.9));
            border: 2px solid var(--level-color);
            border-radius: 10px;
            padding: 10px 8px;
            width: 140px;
            height: 190px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .level-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }
        
        .level-card:hover::before {
            opacity: 1;
            animation: shine 1s ease-in-out;
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }
        
        .level-card.unlocked {
            border-color: var(--level-color);
            opacity: 1;
        }
        
        .level-card.unlocked:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.15);
            border-color: var(--level-color);
        }
        
        .level-card.locked {
            border-color: #444;
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .level-card.locked:hover {
            transform: none;
            box-shadow: none;
        }
        
        .level-card.completed {
            border-color: #00ff88;
            background: linear-gradient(135deg, rgba(0, 60, 40, 0.9), rgba(0, 40, 30, 0.9));
        }
        
        .level-card.selected {
            border-color: #ffff00 !important;
            box-shadow: 0 0 30px rgba(255, 255, 0, 0.5), inset 0 0 20px rgba(255, 255, 0, 0.1) !important;
            transform: translateY(-5px) scale(1.05);
        }
        
        .level-number {
            font-size: 36px;
            font-weight: 900;
            color: var(--level-color);
            text-shadow: 0 0 8px var(--level-color);
            line-height: 1;
            margin-bottom: 6px;
        }
        
        .level-card.locked .level-number {
            color: #666;
            text-shadow: none;
        }
        
        .level-card.completed .level-number {
            color: #00ff88;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
        }
        
        .level-name {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
            line-height: 1.1;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .level-desc {
            font-size: 9px;
            color: #aaa;
            margin-bottom: 4px;
            line-height: 1.2;
            height: 22px;
            overflow: hidden;
        }
        
        .level-unlock {
            font-size: 9px;
            color: #ffcc00;
            margin-bottom: 4px;
            padding: 3px 2px;
            background: rgba(255, 204, 0, 0.1);
            border-radius: 3px;
            line-height: 1.1;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .level-card.locked .level-unlock {
            color: #666;
            background: rgba(100, 100, 100, 0.1);
        }
        
        .level-status {
            font-size: 10px;
            color: #00ffff;
            font-weight: bold;
            padding: 5px 3px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: auto;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .level-card.locked .level-status {
            color: #666;
            font-size: 9px;
            background: rgba(100, 100, 100, 0.1);
        }
        
        .level-status.primary-action {
            background: linear-gradient(135deg, #00ffff, #00ccff) !important;
            color: #000 !important;
            font-weight: bold !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .level-status.primary-action:hover {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            transform: scale(1.05);
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        #levelCompleteScreen {
            position: fixed;
            inset: 0;
            background: rgba(0, 10, 20, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .complete-stats {
            background: rgba(0, 40, 60, 0.5);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 20px 40px;
            margin: 20px 0;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 40px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .stat-label {
            color: #888;
        }
        
        .stat-value {
            color: #00ffff;
            font-weight: bold;
        }
        
        /* 对话系统样式 */
        .dialogue-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 10, 20, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 500;
            animation: fadeIn 0.3s ease-out;
        }
        
        .dialogue-box {
            background: linear-gradient(135deg, rgba(0, 40, 80, 0.95), rgba(0, 20, 60, 0.95));
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            text-align: center;
            animation: slideUp 0.4s ease-out;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        
        .dialogue-character {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .character-icon {
            font-size: 48px;
            margin-right: 15px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .character-name {
            font-size: 24px;
            color: #00ffff;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .dialogue-text {
            font-size: 18px;
            color: #ffffff;
            line-height: 1.6;
            margin-bottom: 25px;
            text-align: left;
        }
        
        .dialogue-continue {
            color: #ffff00;
            font-size: 14px;
            animation: blink 1.5s ease-in-out infinite;
            cursor: pointer;
            padding: 10px 20px;
            border: 1px solid #ffff00;
            border-radius: 5px;
            background: rgba(255, 255, 0, 0.1);
            transition: all 0.3s;
        }
        
        .dialogue-continue:hover {
            background: rgba(255, 255, 0, 0.2);
            box-shadow: 0 0 10px #ffff00;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }
        
        @keyframes scrollText {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Custom Scrollbar Styles for Knowledge Library */
        #knowledgeLibraryScreen ::-webkit-scrollbar {
            width: 6px;
        }
        
        #knowledgeLibraryScreen ::-webkit-scrollbar-track {
            background: rgba(0, 20, 40, 0.3);
            border-radius: 3px;
        }
        
        #knowledgeLibraryScreen ::-webkit-scrollbar-thumb {
            background: rgba(0, 200, 255, 0.2);
            border-radius: 3px;
            transition: background 0.3s;
        }
        
        #knowledgeLibraryScreen ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 200, 255, 0.4);
        }
        
        /* Firefox scrollbar */
        #knowledgeLibraryScreen * {
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 200, 255, 0.2) rgba(0, 20, 40, 0.3);
        }
        
        /* Help Icon Button */
        .help-icon-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.5);
            color: #00ffff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 1000;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .help-icon-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        /* Enhanced Start Button */
        .start-btn-enhanced {
            font-size: 28px !important;
            padding: 20px 60px !important;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.15), rgba(0, 200, 255, 0.25)) !important;
            border: 3px solid #00ffff !important;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), inset 0 0 20px rgba(0, 255, 255, 0.1) !important;
            transition: all 0.3s !important;
            position: relative !important;
            overflow: hidden !important;
        }
        
        .start-btn-enhanced::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.3), transparent);
            animation: buttonScan 3s ease-in-out infinite;
        }
        
        @keyframes buttonScan {
            0% { left: -100%; }
            50%, 100% { left: 100%; }
        }
        
        .start-btn-enhanced:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.25), rgba(0, 200, 255, 0.35)) !important;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8), inset 0 0 30px rgba(0, 255, 255, 0.2) !important;
            transform: scale(1.05) !important;
        }
        
        /* Subtitle Enhancement */
        .subtitle-enhanced {
            letter-spacing: 0.3em !important;
            font-size: 0.9rem !important;
        }
        
        /* Globe Language Selector */
        .globe-language-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .globe-language-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transform: scale(1.1);
        }
        
        /* Decorative Tower - Bottom Left - Holographic Blueprint */
        .deco-tower {
            position: fixed;
            bottom: -50px;
            left: -30px;
            width: 280px;
            height: 350px;
            opacity: 0.85;
            z-index: 1;
            pointer-events: none;
            filter: drop-shadow(0 0 50px rgba(0, 255, 255, 1)) 
                    drop-shadow(0 0 80px rgba(0, 220, 255, 1))
                    drop-shadow(0 0 120px rgba(0, 180, 255, 0.9))
                    drop-shadow(0 0 160px rgba(0, 150, 255, 0.7));
            animation: towerGlow 3s ease-in-out infinite;
        }
        
        .deco-tower::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 255, 0.1) 2px,
                rgba(0, 255, 255, 0.1) 4px
            );
            animation: scanlines 8s linear infinite;
            pointer-events: none;
        }
        
        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(20px); }
        }
        
        @keyframes towerGlow {
            0%, 100% { 
                opacity: 0.7;
                filter: drop-shadow(0 0 50px rgba(0, 255, 255, 1)) 
                        drop-shadow(0 0 80px rgba(0, 220, 255, 1))
                        drop-shadow(0 0 120px rgba(0, 180, 255, 0.9))
                        drop-shadow(0 0 160px rgba(0, 150, 255, 0.7));
            }
            50% { 
                opacity: 0.95;
                filter: drop-shadow(0 0 70px rgba(0, 255, 255, 1)) 
                        drop-shadow(0 0 110px rgba(0, 220, 255, 1))
                        drop-shadow(0 0 150px rgba(0, 180, 255, 1))
                        drop-shadow(0 0 200px rgba(0, 150, 255, 0.9));
            }
        }
        
        /* Decorative Tower - Bottom Right */
        .deco-tower-right {
            position: fixed;
            bottom: -50px;
            right: -30px;
            width: 280px;
            height: 350px;
            opacity: 0.85;
            z-index: 1;
            pointer-events: none;
            filter: drop-shadow(0 0 50px rgba(255, 150, 0, 1)) 
                    drop-shadow(0 0 80px rgba(255, 120, 0, 1))
                    drop-shadow(0 0 120px rgba(255, 100, 0, 0.9))
                    drop-shadow(0 0 160px rgba(255, 80, 0, 0.7));
            animation: towerGlowOrange 3s ease-in-out infinite;
        }
        
        @keyframes towerGlowOrange {
            0%, 100% { 
                opacity: 0.7;
                filter: drop-shadow(0 0 50px rgba(255, 150, 0, 1)) 
                        drop-shadow(0 0 80px rgba(255, 120, 0, 1))
                        drop-shadow(0 0 120px rgba(255, 100, 0, 0.9))
                        drop-shadow(0 0 160px rgba(255, 80, 0, 0.7));
            }
            50% { 
                opacity: 0.95;
                filter: drop-shadow(0 0 70px rgba(255, 150, 0, 1)) 
                        drop-shadow(0 0 110px rgba(255, 120, 0, 1))
                        drop-shadow(0 0 150px rgba(255, 100, 0, 1))
                        drop-shadow(0 0 200px rgba(255, 80, 0, 0.9));
            }
        }
        
        /* Decorative Virus - Bottom Right - Holographic Glitch */
        .deco-virus {
            position: fixed;
            bottom: -30px;
            right: -20px;
            width: 250px;
            height: 280px;
            opacity: 0.75;
            z-index: 1;
            pointer-events: none;
            filter: drop-shadow(0 0 55px rgba(255, 0, 100, 1)) 
                    drop-shadow(0 0 85px rgba(255, 0, 80, 1))
                    drop-shadow(0 0 120px rgba(255, 0, 60, 0.9))
                    drop-shadow(0 0 160px rgba(200, 0, 50, 0.8));
            animation: virusGlitch 4s ease-in-out infinite;
        }
        
        .deco-virus::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 3px,
                rgba(255, 0, 100, 0.15) 3px,
                rgba(255, 0, 100, 0.15) 6px
            );
            animation: glitchScanlines 6s linear infinite;
            pointer-events: none;
        }
        
        @keyframes glitchScanlines {
            0% { transform: translateY(0); opacity: 0.8; }
            50% { transform: translateY(15px); opacity: 0.4; }
            100% { transform: translateY(0); opacity: 0.8; }
        }
        
        @keyframes virusGlitch {
            0%, 100% { 
                opacity: 0.65;
                transform: translateY(0) rotate(0deg);
                filter: drop-shadow(0 0 55px rgba(255, 0, 100, 1)) 
                        drop-shadow(0 0 85px rgba(255, 0, 80, 1))
                        drop-shadow(0 0 120px rgba(255, 0, 60, 0.9))
                        drop-shadow(0 0 160px rgba(200, 0, 50, 0.8));
            }
            25% { 
                opacity: 0.9;
                transform: translateY(-10px) rotate(2deg) translateX(3px);
                filter: drop-shadow(0 0 70px rgba(255, 0, 100, 1)) 
                        drop-shadow(0 0 110px rgba(255, 0, 80, 1))
                        drop-shadow(0 0 150px rgba(255, 0, 60, 1))
                        drop-shadow(0 0 190px rgba(200, 0, 50, 0.9));
            }
            50% { 
                opacity: 0.75;
                transform: translateY(-15px) rotate(5deg) translateX(-2px);
                filter: drop-shadow(0 0 60px rgba(255, 0, 100, 1)) 
                        drop-shadow(0 0 95px rgba(255, 0, 80, 1))
                        drop-shadow(0 0 135px rgba(255, 0, 60, 0.95))
                        drop-shadow(0 0 175px rgba(200, 0, 50, 0.85));
            }
            75% { 
                opacity: 0.95;
                transform: translateY(-8px) rotate(-2deg) translateX(2px);
                filter: drop-shadow(0 0 75px rgba(255, 0, 100, 1)) 
                        drop-shadow(0 0 115px rgba(255, 0, 80, 1))
                        drop-shadow(0 0 155px rgba(255, 0, 60, 1))
                        drop-shadow(0 0 195px rgba(200, 0, 50, 0.9));
            }
        }
    </style>
</head>
<body class="bg-gray-900 min-h-screen">
    <div class="scanline"></div>
    
    <!-- Start Screen -->
    <div id="startScreen">
        <!-- Decorative Tower - Bottom Left - Holographic Blueprint -->
        <svg class="deco-tower" viewBox="0 0 280 350" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <style>
                    .blueprint-line { stroke-dasharray: 5,3; animation: dashBreath 2s ease-in-out infinite; }
                    @keyframes dashBreath { 0%, 100% { stroke-dashoffset: 0; opacity: 0.7; } 50% { stroke-dashoffset: 8; opacity: 1; } }
                </style>
            </defs>
            <!-- Base Platform -->
            <polygon points="80,340 200,340 220,320 60,320" fill="rgba(20,40,60,0.6)" stroke="rgba(0,200,255,0.8)" stroke-width="2" class="blueprint-line"/>
            <!-- Main Body -->
            <rect x="100" y="200" width="80" height="120" fill="rgba(30,50,70,0.7)" stroke="rgba(0,200,255,0.9)" stroke-width="2" class="blueprint-line"/>
            <rect x="110" y="210" width="60" height="100" fill="rgba(20,40,60,0.5)"/>
            <!-- Core Glow -->
            <circle cx="140" cy="260" r="25" fill="rgba(0,200,255,0.4)"/>
            <circle cx="140" cy="260" r="18" fill="rgba(0,255,255,0.6)"/>
            <circle cx="140" cy="260" r="10" fill="rgba(100,255,255,1)">
                <animate attributeName="r" values="10;12;10" dur="2s" repeatCount="indefinite"/>
            </circle>
            <!-- Top Cannon -->
            <polygon points="120,200 160,200 170,150 110,150" fill="rgba(40,60,80,0.7)" stroke="rgba(0,200,255,1)" stroke-width="2" class="blueprint-line"/>
            <rect x="130" y="120" width="20" height="30" fill="rgba(50,70,90,0.7)" stroke="rgba(0,200,255,1)" stroke-width="2" class="blueprint-line"/>
            <!-- Barrel -->
            <rect x="135" y="80" width="10" height="40" fill="rgba(0,150,200,0.6)" stroke="rgba(0,255,255,1)" stroke-width="1.5" class="blueprint-line"/>
            <!-- Energy Lines -->
            <line x1="140" y1="260" x2="140" y2="200" stroke="rgba(0,255,255,0.8)" stroke-width="2" class="blueprint-line"/>
            <line x1="140" y1="200" x2="140" y2="150" stroke="rgba(0,255,255,0.7)" stroke-width="2" class="blueprint-line"/>
            <!-- Side Details -->
            <rect x="95" y="240" width="8" height="40" fill="rgba(0,150,200,0.5)" class="blueprint-line"/>
            <rect x="177" y="240" width="8" height="40" fill="rgba(0,150,200,0.5)" class="blueprint-line"/>
            <!-- Hexagon Details -->
            <polygon points="125,230 135,225 145,230 145,240 135,245 125,240" fill="none" stroke="rgba(0,255,255,0.9)" stroke-width="1.5" class="blueprint-line"/>
            <polygon points="135,280 145,275 155,280 155,290 145,295 135,290" fill="none" stroke="rgba(0,255,255,0.9)" stroke-width="1.5" class="blueprint-line"/>
        </svg>
        
        <!-- Decorative Virus - Bottom Right - Holographic Glitch -->
        <svg class="deco-virus" viewBox="0 0 250 280" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <style>
                    .glitch-line { stroke-dasharray: 4,4; animation: glitchDash 1.5s ease-in-out infinite; }
                    @keyframes glitchDash { 0%, 100% { stroke-dashoffset: 0; opacity: 0.6; } 50% { stroke-dashoffset: 8; opacity: 1; } }
                </style>
            </defs>
            <!-- Main Body - Glitch Blocks -->
            <rect x="80" y="120" width="90" height="90" fill="rgba(150,0,50,0.5)" stroke="rgba(255,0,100,1)" stroke-width="2" class="glitch-line"/>
            <rect x="85" y="125" width="35" height="35" fill="rgba(200,0,60,0.4)"/>
            <rect x="130" y="125" width="35" height="35" fill="rgba(180,0,55,0.4)"/>
            <rect x="85" y="170" width="35" height="35" fill="rgba(190,0,58,0.4)"/>
            <rect x="130" y="170" width="35" height="35" fill="rgba(170,0,52,0.4)"/>
            <!-- Glitch Effect -->
            <rect x="75" y="115" width="95" height="5" fill="rgba(255,0,100,0.5)">
                <animate attributeName="opacity" values="0.3;0.7;0.3" dur="0.8s" repeatCount="indefinite"/>
            </rect>
            <rect x="78" y="210" width="92" height="4" fill="rgba(255,0,100,0.5)">
                <animate attributeName="opacity" values="0.5;0.9;0.5" dur="1.2s" repeatCount="indefinite"/>
            </rect>
            <!-- Core Glow -->
            <circle cx="125" cy="165" r="30" fill="rgba(255,0,100,0.4)"/>
            <circle cx="125" cy="165" r="20" fill="rgba(255,50,120,0.6)"/>
            <circle cx="125" cy="165" r="12" fill="rgba(255,100,150,0.9)">
                <animate attributeName="r" values="12;14;12" dur="1.5s" repeatCount="indefinite"/>
            </circle>
            <!-- Spikes/Tentacles -->
            <polygon points="125,120 130,80 135,120" fill="rgba(200,0,60,0.5)" stroke="rgba(255,0,100,1)" stroke-width="2" class="glitch-line"/>
            <polygon points="170,140 210,130 175,150" fill="rgba(200,0,60,0.5)" stroke="rgba(255,0,100,1)" stroke-width="2" class="glitch-line"/>
            <polygon points="80,140 40,130 75,150" fill="rgba(200,0,60,0.5)" stroke="rgba(255,0,100,1)" stroke-width="2" class="glitch-line"/>
            <polygon points="125,210 120,250 130,250" fill="rgba(200,0,60,0.5)" stroke="rgba(255,0,100,1)" stroke-width="2" class="glitch-line"/>
            <!-- Code Fragments -->
            <text x="90" y="145" fill="rgba(255,0,100,0.9)" font-family="monospace" font-size="12" font-weight="bold">ERR</text>
            <text x="130" y="175" fill="rgba(255,0,100,0.9)" font-family="monospace" font-size="10">0x00</text>
            <text x="95" y="195" fill="rgba(255,0,100,0.9)" font-family="monospace" font-size="10">NULL</text>
            <!-- Glitch Lines -->
            <line x1="70" y1="150" x2="180" y2="150" stroke="rgba(255,0,100,0.7)" stroke-width="1" class="glitch-line"/>
            <line x1="70" y1="180" x2="180" y2="180" stroke="rgba(255,0,100,0.7)" stroke-width="1" class="glitch-line"/>
            <!-- Eyes -->
            <circle cx="105" cy="155" r="6" fill="rgba(255,0,0,1)">
                <animate attributeName="opacity" values="1;0.3;1" dur="2s" repeatCount="indefinite"/>
            </circle>
            <circle cx="145" cy="155" r="6" fill="rgba(255,0,0,1)">
                <animate attributeName="opacity" values="1;0.3;1" dur="2s" repeatCount="indefinite"/>
            </circle>
        </svg>
        
        <h1 class="text-5xl md:text-7xl font-bold text-cyan-400 neon-text mb-4" data-i18n="game_title">Block Rush</h1>
        <p class="text-cyan-300 mb-2 subtitle-enhanced" data-i18n="game_subtitle">BLOCKCHAIN TOWER DEFENSE</p>
        <p class="text-gray-400 mb-12 text-center px-4 max-w-lg" data-i18n="game_description">
            守护你的区块！阻止恶意交易污染区块链。<br>
            让合法交易通过,消灭黑客与各种攻击！
        </p>
        <button class="game-btn start-btn-enhanced" onclick="showOpeningStory()" data-i18n="btn_start">开始游戏 START</button>
        
        <!-- ========== 体验模式按钮 ========== -->
        <button class="game-btn" onclick="unlockAllForTesting()" style="margin-top: 20px; border-color: #00ccff; color: #00ccff; font-size: 14px;" data-i18n="btn_test_mode">
            🔗 连接钱包
        </button>
        <!-- ========== 体验模式按钮结束 ========== -->
        
        <!-- Help Icon Button (replaces bottom tips) -->
        <button class="help-icon-btn" onclick="openKnowledgeLibraryFromStart()" title="知识库 / Knowledge Library / 知識ライブラリ">
            ❓
        </button>
    </div>
    
    <!-- Level Select Screen -->
    <div id="levelSelectScreen" style="display: none; padding: 80px 0 80px 0; overflow-y: auto; max-height: 100vh;">
        <!-- Language Selector for Level Select Screen -->
        <div style="position: fixed; top: 20px; right: 20px; z-index: 300;">
            <div class="language-dropdown">
                <button id="levelSelectLanguageBtn" class="globe-language-btn" onclick="toggleLanguageDropdown()" title="Language / 语言 / 言語">
                    🌐
                </button>
                <div id="levelSelectLanguageDropdown" class="language-dropdown-menu" style="display: none;">
                    <div class="language-option" onclick="changeLanguage('zh-CN')">
                        <span class="language-flag">🇨🇳</span>
                        <span class="language-name">中文</span>
                    </div>
                    <div class="language-option" onclick="changeLanguage('en-US')">
                        <span class="language-flag">🇺🇸</span>
                        <span class="language-name">English</span>
                    </div>
                    <div class="language-option" onclick="changeLanguage('ja-JP')">
                        <span class="language-flag">🇯🇵</span>
                        <span class="language-name">日本語</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Decorative Tower - Bottom Left -->
        <svg class="deco-tower" viewBox="0 0 280 350" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <style>
                    .blueprint-line { stroke-dasharray: 5,3; animation: dashBreath 2s ease-in-out infinite; }
                    @keyframes dashBreath { 0%, 100% { stroke-dashoffset: 0; opacity: 0.7; } 50% { stroke-dashoffset: 8; opacity: 1; } }
                </style>
            </defs>
            <polygon points="80,340 200,340 220,320 60,320" fill="rgba(20,40,60,0.6)" stroke="rgba(0,200,255,0.8)" stroke-width="2" class="blueprint-line"/>
            <rect x="100" y="200" width="80" height="120" fill="rgba(30,50,70,0.7)" stroke="rgba(0,200,255,0.9)" stroke-width="2" class="blueprint-line"/>
            <rect x="110" y="210" width="60" height="100" fill="rgba(20,40,60,0.5)"/>
            <circle cx="140" cy="260" r="25" fill="rgba(0,200,255,0.4)"/>
            <circle cx="140" cy="260" r="18" fill="rgba(0,255,255,0.6)"/>
            <circle cx="140" cy="260" r="10" fill="rgba(100,255,255,1)">
                <animate attributeName="r" values="10;12;10" dur="1.5s" repeatCount="indefinite"/>
            </circle>
            <rect x="115" y="180" width="50" height="20" fill="rgba(30,50,70,0.7)" stroke="rgba(0,200,255,0.9)" stroke-width="2" class="blueprint-line"/>
            <polygon points="115,180 140,150 165,180" fill="rgba(40,60,80,0.7)" stroke="rgba(0,200,255,0.9)" stroke-width="2" class="blueprint-line"/>
            <circle cx="140" cy="165" r="8" fill="rgba(0,255,255,0.8)">
                <animate attributeName="opacity" values="0.8;1;0.8" dur="1s" repeatCount="indefinite"/>
            </circle>
        </svg>
        
        <!-- Decorative Tower - Bottom Right -->
        <svg class="deco-tower-right" viewBox="0 0 280 350" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <style>
                    .orange-line { stroke-dasharray: 5,3; animation: dashBreathOrange 2s ease-in-out infinite; }
                    @keyframes dashBreathOrange { 0%, 100% { stroke-dashoffset: 0; opacity: 0.7; } 50% { stroke-dashoffset: 8; opacity: 1; } }
                </style>
            </defs>
            <polygon points="80,340 200,340 220,320 60,320" fill="rgba(60,40,20,0.6)" stroke="rgba(255,150,0,0.8)" stroke-width="2" class="orange-line"/>
            <rect x="100" y="220" width="80" height="100" fill="rgba(70,50,30,0.7)" stroke="rgba(255,150,0,0.9)" stroke-width="2" class="orange-line"/>
            <rect x="110" y="230" width="60" height="80" fill="rgba(60,40,20,0.5)"/>
            <circle cx="140" cy="270" r="20" fill="rgba(255,100,0,0.4)"/>
            <circle cx="140" cy="270" r="15" fill="rgba(255,150,0,0.6)"/>
            <circle cx="140" cy="270" r="8" fill="rgba(255,200,0,1)">
                <animate attributeName="r" values="8;10;8" dur="1.2s" repeatCount="indefinite"/>
            </circle>
            <rect x="120" y="200" width="40" height="20" fill="rgba(70,50,30,0.7)" stroke="rgba(255,150,0,0.9)" stroke-width="2" class="orange-line"/>
            <polygon points="120,200 140,175 160,200" fill="rgba(80,60,40,0.7)" stroke="rgba(255,150,0,0.9)" stroke-width="2" class="orange-line"/>
        </svg>
        
        <h1 class="text-2xl font-bold text-cyan-400 neon-text mb-1 mt-4" data-i18n="level_select_title">选择关卡</h1>
        <p class="text-cyan-300 mb-3 text-xs" data-i18n="level_select_subtitle">SELECT LEVEL</p>
        
        <div class="flex flex-wrap justify-center gap-2 px-4 mb-4" style="margin: 0 auto; max-width: 1100px;">
            <div class="level-card unlocked" data-level="1" data-color="#00ffff" onclick="selectLevel(1)" style="flex: 0 0 auto; width: 160px; --level-color: #00ffff;">
                <div class="level-number">1</div>
                <div class="level-name" data-i18n="level_1_name">交易验证</div>
                <div class="level-desc" data-i18n="level_1_desc">直线地图 | 基础敌人</div>
                <div class="level-unlock" data-i18n="level_1_unlock">🔐 公钥验证哨</div>
                <div class="level-status" data-i18n="level_status_start">▶ 开始</div>
            </div>
            
            <div class="level-card locked" data-level="2" data-color="#00ffff" onclick="selectLevel(2)" style="flex: 0 0 auto; width: 160px; --level-color: #00ffff;">
                <div class="level-number">2</div>
                <div class="level-name" data-i18n="level_2_name">网络扩容</div>
                <div class="level-desc" data-i18n="level_2_desc">U型弯 | 分裂怪</div>
                <div class="level-unlock" data-i18n="level_2_unlock">💥 分片加农炮</div>
                <div class="level-status" data-i18n="level_unlock_status_2">🔒 通关第1关解锁</div>
            </div>
            
            <div class="level-card locked" data-level="3" data-color="#00ffff" onclick="selectLevel(3)" style="flex: 0 0 auto; width: 160px; --level-color: #00ffff;">
                <div class="level-number">3</div>
                <div class="level-name" data-i18n="level_3_name">隐私与证明</div>
                <div class="level-desc" data-i18n="level_3_desc">S型弯 | 减伤怪</div>
                <div class="level-unlock" data-i18n="level_3_unlock">🎯 ZK狙击塔</div>
                <div class="level-status" data-i18n="level_unlock_status_3">🔒 通关第2关解锁</div>
            </div>
            
            <div class="level-card locked" data-level="4" data-color="#00ffff" onclick="selectLevel(4)" style="flex: 0 0 auto; width: 160px; --level-color: #00ffff;">
                <div class="level-number">4</div>
                <div class="level-name" data-i18n="level_4_name">闪电网络</div>
                <div class="level-desc" data-i18n="level_4_desc">长直线 | 回血怪</div>
                <div class="level-unlock" data-i18n="level_4_unlock">⚡ L2通道</div>
                <div class="level-status" data-i18n="level_unlock_status_4">🔒 通关第3关解锁</div>
            </div>
            
            <div class="level-card locked" data-level="5" data-color="#00ffff" onclick="selectLevel(5)" style="flex: 0 0 auto; width: 160px; --level-color: #00ffff;">
                <div class="level-number">5</div>
                <div class="level-name" data-i18n="level_5_name">51%攻击</div>
                <div class="level-desc" data-i18n="level_5_desc">双入口 | BOSS战</div>
                <div class="level-unlock" data-i18n="level_5_unlock">☄️ 主网大炮</div>
                <div class="level-status" data-i18n="level_unlock_status_5">🔒 通关第4关解锁</div>
            </div>
            
            <div class="level-card locked" data-level="endless" data-color="#ff00ff" onclick="selectLevel('endless')" style="flex: 0 0 auto; width: 160px; --level-color: #ff00ff;">
                <div class="level-number">∞</div>
                <div class="level-name" data-i18n="endless_mode_name">无尽模式</div>
                <div class="level-desc" data-i18n="endless_desc">随机地图 | 无限挑战</div>
                <div class="level-unlock" data-i18n="endless_challenge">🌟 终极考验</div>
                <div class="level-status" data-i18n="level_unlock_status_endless">🔒 通关第5关解锁</div>
            </div>
        </div>
        
        <!-- 难度选择 -->
        <div class="mt-3 text-center px-4">
            <div class="text-cyan-400 text-xs font-bold mb-2" data-i18n="difficulty_title">选择难度 DIFFICULTY</div>
            <div class="flex gap-2 justify-center mx-auto" style="flex-wrap: nowrap;">
                <button id="difficultyEasy" class="game-btn text-xs py-1.5 px-3" onclick="setDifficulty('easy')" style="border-color: #00ff88; color: #00ff88; min-width: 130px; flex-shrink: 0; transition: all 0.3s;">
                    <span data-i18n="difficulty_easy">🛡 简单 (HP 70%)</span>
                </button>
                <button id="difficultyNormal" class="game-btn text-xs py-1.5 px-3" onclick="setDifficulty('normal')" style="border-color: #00ffff; color: #00ffff; box-shadow: 0 0 30px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.2); background: rgba(0, 255, 255, 0.1); transform: scale(1.05); min-width: 130px; flex-shrink: 0; transition: all 0.3s;">
                    <span data-i18n="difficulty_normal">⭐ 标准 (HP 100%)</span>
                </button>
                <button id="difficultyHard" class="game-btn text-xs py-1.5 px-3" onclick="setDifficulty('hard')" style="border-color: #ff0044; color: #ff0044; min-width: 130px; flex-shrink: 0; transition: all 0.3s;">
                    <span data-i18n="difficulty_hard">💀 困难 (HP 200%)</span>
                </button>
            </div>
        </div>
        
        <!-- 核心玩法图示 - 科技感左右分开 -->
        <div class="text-center mt-6 mb-3" style="display: flex; justify-content: center; align-items: center; gap: 50px; flex-wrap: wrap;">
            <!-- 左侧：合法数据 -->
            <div style="display: flex; align-items: center; gap: 10px; padding: 12px 20px; background: rgba(0, 255, 136, 0.05); border: 2px solid rgba(0, 255, 136, 0.3); border-radius: 10px; box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);">
                <div style="width: 35px; height: 35px; background: linear-gradient(135deg, #00ff88, #00cc66); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);">🟢</div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                    <div id="mechanicsLegitimateData" style="color: #00ff88; font-size: 12px; font-weight: bold; letter-spacing: 1px; opacity: 0.8;" data-i18n="mechanics_legitimate_data">合法数据</div>
                    <div id="mechanicsPass" style="color: #00ff88; font-size: 16px; font-weight: bold; letter-spacing: 2px; text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);" data-i18n="mechanics_pass">>> PASS</div>
                </div>
            </div>
            
            <!-- 右侧：恶意攻击 -->
            <div style="display: flex; align-items: center; gap: 10px; padding: 12px 20px; background: rgba(255, 0, 68, 0.05); border: 2px solid rgba(255, 0, 68, 0.3); border-radius: 10px; box-shadow: 0 0 15px rgba(255, 0, 68, 0.2);">
                <div style="width: 35px; height: 35px; background: linear-gradient(135deg, #ff0044, #cc0033); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 0 10px rgba(255, 0, 68, 0.5);">🔴</div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                    <div id="mechanicsMaliciousAttack" style="color: #ff0044; font-size: 12px; font-weight: bold; letter-spacing: 1px; opacity: 0.8;" data-i18n="mechanics_malicious_attack">恶意攻击</div>
                    <div id="mechanicsKill" style="color: #ff0044; font-size: 16px; font-weight: bold; letter-spacing: 2px; text-shadow: 0 0 10px rgba(255, 0, 68, 0.5);" data-i18n="mechanics_kill">>> KILL</div>
                </div>
            </div>
        </div>
        
        <!-- 开始部署大按钮 - 实心强化版 -->
        <div class="text-center mt-4 mb-4">
            <button id="startDeployBtn" onclick="startSelectedLevel()" style="display: none; background: linear-gradient(135deg, #ff8800, #ffaa00); border: 3px solid #ffcc00; color: #000; font-size: 24px; padding: 18px 50px; box-shadow: 0 0 40px rgba(255, 170, 0, 0.8), 0 5px 15px rgba(0,0,0,0.3); font-weight: bold; border-radius: 12px; cursor: pointer; transition: all 0.3s; text-transform: uppercase; letter-spacing: 2px;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0 50px rgba(255, 170, 0, 1), 0 8px 20px rgba(0,0,0,0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0 40px rgba(255, 170, 0, 0.8), 0 5px 15px rgba(0,0,0,0.3)';" data-i18n="btn_start_deploy">
                🚀 开始部署
            </button>
        </div>
        
        <div class="text-center flex flex-wrap gap-2 justify-center mt-3 mb-4 px-4 max-w-xl mx-auto">
            <button class="game-btn text-xs py-1.5 px-3" onclick="openKnowledgeLibrary()" style="border-color: #00ffff; color: #00ffff; min-width: 130px;" data-i18n="btn_knowledge">
                📚 知识库 LIBRARY
            </button>
            <div style="display: flex; gap: 15px; align-items: stretch;">
                <button class="game-btn text-xs py-1.5 px-3" onclick="backToStart()" style="border-color: #888; color: #888; min-width: 130px;" data-i18n="btn_back_main">
                    ← 返回主菜单
                </button>
                <button class="game-btn text-xs py-1.5" onclick="openCredits()" style="border-color: #ff6b9d; color: #ff6b9d; width: 38px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 16px;" data-i18n-title="btn_credits" title="关于我们">
                    ❤
                </button>
            </div>
        </div>
    </div>
    
    <!-- Knowledge Library Screen -->
    <div id="knowledgeLibraryScreen" style="display: none; position: relative; height: 100vh; overflow: hidden;">
        <!-- Fixed Header -->
        <div style="position: fixed; top: 0; left: 0; right: 0; z-index: 100; background: rgba(0, 15, 30, 1); padding: 60px 0 20px 0; text-align: center;">
            <h1 class="text-4xl font-bold text-cyan-400 neon-text mb-2" data-i18n="help_screen_title">区块知识库</h1>
            <p class="text-cyan-300 mb-3 text-sm" data-i18n="help_screen_subtitle">BLOCKCHAIN KNOWLEDGE</p>
            
            <!-- Tab Navigation -->
            <div style="display: flex; justify-content: center; gap: 10px; margin-top: 15px;">
                <button id="tabGuide" class="knowledge-tab active" onclick="switchKnowledgeTab('guide')">
                    <span data-i18n="tab_guide">📖 操作指南</span>
                </button>
                <button id="tabEncyclopedia" class="knowledge-tab" onclick="switchKnowledgeTab('encyclopedia')">
                    <span data-i18n="tab_encyclopedia">📚 区块链百科</span>
                </button>
            </div>
        </div>
        
        <!-- Scrollable Content -->
        <div style="max-width: 1000px; margin: 0 auto; padding: 240px 20px 120px 20px; height: 100%; overflow-y: auto;">
            
            <!-- Tab Content: Guide -->
            <div id="tabContentGuide" class="tab-content active">
            <!-- 游戏目标 -->
            <div class="help-section" style="background: linear-gradient(135deg, rgba(0,100,150,0.3), rgba(0,50,80,0.3)); margin-bottom: 20px;">
                <div class="help-title">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: inline-block; vertical-align: middle; margin-right: 8px;">
                        <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
                        <line x1="12" y1="18" x2="12" y2="18"></line>
                    </svg>
                    <span data-i18n="help_title_goal">游戏目标</span>
                </div>
                <div class="help-content">
                    <div data-i18n="help_goal_content_1">守护你的<span style="color:#00ffff">区块（Block）</span>！</div>
                    <br>
                    <div style="display: flex; justify-content: center; gap: 40px; margin: 20px 0;">
                        <div style="text-align: center;">
                            <svg width="60" height="60" viewBox="0 0 60 60">
                                <rect x="10" y="10" width="40" height="40" fill="#00ff88" rx="5"></rect>
                                <rect x="15" y="15" width="30" height="30" fill="rgba(0,255,136,0.5)" rx="3"></rect>
                            </svg>
                            <div style="margin-top: 8px; color: #00ff88; font-weight: bold;" data-i18n="help_goal_content_2">合法交易 → 放行</div>
                        </div>
                        <div style="text-align: center;">
                            <svg width="60" height="60" viewBox="0 0 60 60">
                                <circle cx="30" cy="30" r="20" fill="#ff0044"></circle>
                                <circle cx="22" cy="22" r="3" fill="#fff"></circle>
                                <circle cx="38" cy="22" r="3" fill="#fff"></circle>
                                <path d="M 20 38 Q 30 32 40 38" stroke="#fff" stroke-width="3" fill="none"></path>
                            </svg>
                            <div style="margin-top: 8px; color: #ff0044; font-weight: bold;" data-i18n="help_goal_content_3">恶意数据 → 消灭</div>
                        </div>
                    </div>
                    <div data-i18n="help_goal_content_4">• 点击路径入口的<span style="color:#ff0044">红色图标</span>开始波次</div>
                </div>
            </div>
            
            <!-- 快捷键 -->
            <div class="help-section" style="margin-bottom: 20px;">
                <div class="help-title">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: inline-block; vertical-align: middle; margin-right: 8px;">
                        <rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect>
                        <line x1="6" y1="8" x2="6" y2="8"></line>
                        <line x1="10" y1="8" x2="10" y2="8"></line>
                        <line x1="14" y1="8" x2="14" y2="8"></line>
                        <line x1="18" y1="8" x2="18" y2="8"></line>
                        <line x1="6" y1="12" x2="6" y2="12"></line>
                        <line x1="10" y1="12" x2="10" y2="12"></line>
                        <line x1="14" y1="12" x2="14" y2="12"></line>
                        <line x1="18" y1="12" x2="18" y2="12"></line>
                        <line x1="8" y1="16" x2="16" y2="16"></line>
                    </svg>
                    <span data-i18n="help_title_hotkeys">快捷键</span>
                </div>
                <div class="help-content">
                    <div class="hotkey-grid">
                        <div class="help-item">
                            <div class="help-item-title"><span class="key">X</span> <span data-i18n="help_hotkey_x_title">二倍速</span></div>
                            <div class="help-item-desc" data-i18n="help_hotkey_x_desc">切换游戏速度（1倍 ↔ 2倍）</div>
                        </div>
                        <div class="help-item">
                            <div class="help-item-title"><span class="key">N</span> <span data-i18n="help_hotkey_n_title">下一波</span></div>
                            <div class="help-item-desc" data-i18n="help_hotkey_n_desc">跳过准备时间，立即开始下一波</div>
                        </div>
                        <div class="help-item">
                            <div class="help-item-title"><span class="key">ESC</span> / <span class="key">P</span> <span data-i18n="help_hotkey_esc_title">暂停</span></div>
                            <div class="help-item-desc" data-i18n="help_hotkey_esc_desc">打开暂停菜单</div>
                        </div>
                        <div class="help-item">
                            <div class="help-item-title"><span class="key">SPACE</span> <span data-i18n="help_hotkey_space_title">快速暂停</span></div>
                            <div class="help-item-desc" data-i18n="help_hotkey_space_desc">长按暂停，松开继续</div>
                        </div>
                        <div class="help-item">
                            <div class="help-item-title"><span class="key">W</span> <span data-i18n="help_hotkey_w_title">快捷升级</span></div>
                            <div class="help-item-desc" data-i18n="help_hotkey_w_desc">升级当前选中的防御塔</div>
                        </div>
                        <div class="help-item">
                            <div class="help-item-title"><span class="key">Q</span> <span data-i18n="help_hotkey_q_title">快捷出售</span></div>
                            <div class="help-item-desc" data-i18n="help_hotkey_q_desc">出售当前选中的防御塔</div>
                        </div>
                        <div class="help-item">
                            <div class="help-item-title"><span class="key">R</span> <span data-i18n="help_hotkey_r_title">主网轰炸</span></div>
                            <div class="help-item-desc" data-i18n="help_hotkey_r_desc">激活主网大炮瞄准模式（需要建造主网大炮）</div>
                        </div>
                        <div class="help-item">
                            <div class="help-item-title"><span class="key">1-8</span> <span data-i18n="help_hotkey_1to8_title">选择防御塔</span></div>
                            <div class="help-item-desc" data-i18n="help_hotkey_1to8_desc">快速选择对应编号的防御塔进行建造</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 操作说明 -->
            <div class="help-section" style="margin-bottom: 20px;">
                <div class="help-title">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: inline-block; vertical-align: middle; margin-right: 8px;">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="3"></circle>
                        <line x1="12" y1="2" x2="12" y2="9"></line>
                        <line x1="12" y1="15" x2="12" y2="22"></line>
                        <line x1="2" y1="12" x2="9" y2="12"></line>
                        <line x1="15" y1="12" x2="22" y2="12"></line>
                    </svg>
                    <span data-i18n="help_title_controls">操作说明</span>
                </div>
                <div class="help-content">
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_control_place_title">放置防御塔</div>
                        <div class="help-item-desc" data-i18n="help_control_place_desc">点击底部塔图标 → 点击地图空地放置</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_control_upgrade_title">升级防御塔</div>
                        <div class="help-item-desc" data-i18n="help_control_upgrade_desc">点击已放置的塔 → 点击升级按钮（最高Lv10）</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_control_sell_title">出售防御塔</div>
                        <div class="help-item-desc" data-i18n="help_control_sell_desc">点击已放置的塔 → 点击出售按钮（返还70%）</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_control_enemy_title">查看敌人信息</div>
                        <div class="help-item-desc" data-i18n="help_control_enemy_desc">点击敌人查看详细属性和特性</div>
                    </div>
                </div>
            </div>
            
            <!-- 游戏技巧 -->
            <div class="help-section" style="margin-bottom: 20px;">
                <div class="help-title" data-i18n="help_title_tips">💡 游戏技巧</div>
                <div class="help-content">
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_economy_title">经济优先</div>
                        <div class="help-item-desc" data-i18n="help_tip_economy_desc">前期多建矿机，保证经济发展</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_upgrade_title">升级优于新建</div>
                        <div class="help-item-desc" data-i18n="help_tip_upgrade_desc">升级塔性价比约2倍，优先升级核心塔至Lv10</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_priority_title">索敌优先级</div>
                        <div class="help-item-desc" data-i18n="help_tip_priority_desc">点击塔可设置：第一/最后/特攻/最强/最弱/最近</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_combo_title">合理搭配</div>
                        <div class="help-item-desc" data-i18n="help_tip_combo_desc">Gas站+合约门+主力塔 = 完美组合</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_counter_title">针对性防御</div>
                        <div class="help-item-desc" data-i18n="help_tip_counter_desc">垃圾交易→验证哨 | 装甲怪→ZK狙击 | 分裂怪→分片炮 | 回血怪→L2通道</div>
                    </div>
                </div>
            </div>
            
            <!-- 学习模式 -->
            <div class="help-section" style="margin-bottom: 20px;">
                <div class="help-title" data-i18n="help_title_learning">📚 学习模式</div>
                <div class="help-content">
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_learn_card_title">知识卡片</div>
                        <div class="help-item-desc" data-i18n="help_learn_card_desc">每个塔解锁时会显示区块链知识介绍</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_learn_story_title">剧情模式</div>
                        <div class="help-item-desc" data-i18n="help_learn_story_desc">每关都有开场和通关剧情，了解区块链故事</div>
                    </div>
                </div>
            </div>
            </div>
            <!-- End of Tab Content: Guide -->
            
            <!-- Tab Content: Encyclopedia -->
            <div id="tabContentEncyclopedia" class="tab-content">
            
            <!-- 防御塔一览 -->
            <div class="help-section" style="margin-bottom: 20px;">
                <div class="help-title" data-i18n="help_title_towers">🗼 防御塔一览</div>
                <div class="help-content">
                    <div class="help-item">
                        <div class="help-item-title">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #4a9eff; border-radius: 4px; text-align: center; line-height: 24px; margin-right: 8px; vertical-align: middle;">🔐</span>
                            <span data-i18n="help_tower_validator_title">验证哨 - 非对称加密</span>
                        </div>
                        <div class="help-item-desc" data-i18n="help_tower_validator_desc">单体高伤，前期主力。可升级至Lv10</div>
                        <div class="knowledge-box">
                            <span style="color: #ffd700;">成本25</span> | 
                            <span style="color: #00ffff;">射程110</span> | 
                            <span style="color: #ff6b6b;">伤害12</span> | 
                            <span style="color: #a0a0a0;">攻速1.0s</span>
                        </div>
                        <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_validator_special">⚡ 特攻垃圾交易 (1.2x-2.5x)</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #8b7355; border-radius: 4px; text-align: center; line-height: 24px; margin-right: 8px; vertical-align: middle;">⛏️</span>
                            <span data-i18n="help_tower_miner_title">矿机 - 工作量证明</span>
                        </div>
                        <div class="help-item-desc" data-i18n="help_tower_miner_desc">被动收入建筑，可升级至Lv10</div>
                        <div class="knowledge-box">
                            <span style="color: #ffd700;">成本50</span> | 
                            <span style="color: #00ff88;">收入2 GAS/3s</span> | 
                            <span style="color: #a0a0a0;">出售回收90%</span>
                        </div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #ff9500; border-radius: 4px; text-align: center; line-height: 24px; margin-right: 8px; vertical-align: middle;">⛽</span>
                            <span data-i18n="help_tower_gas_title">Gas站 - Gas费机制</span>
                        </div>
                        <div class="help-item-desc" data-i18n="help_tower_gas_desc">范围加速友军，可升级至Lv10</div>
                        <div class="knowledge-box">
                            <span style="color: #ffd700;">成本45</span> | 
                            <span style="color: #00ffff;">范围100</span> | 
                            <span style="color: #00ff88;">加速25%-70%</span>
                        </div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #9b59b6; border-radius: 4px; text-align: center; line-height: 24px; margin-right: 8px; vertical-align: middle;">📜</span>
                            <span data-i18n="help_tower_contract_title">合约门 - 智能合约</span>
                        </div>
                        <div class="help-item-desc" data-i18n="help_tower_contract_desc">范围减速+真视，可升级至Lv10</div>
                        <div class="knowledge-box">
                            <span style="color: #ffd700;">成本65</span> | 
                            <span style="color: #00ffff;">范围140</span> | 
                            <span style="color: #ff6b6b;">减速35%-80%</span>
                        </div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #e74c3c; border-radius: 4px; text-align: center; line-height: 24px; margin-right: 8px; vertical-align: middle;">💥</span>
                            <span data-i18n="help_tower_sharding_title">分片炮 - 分片技术 [Lv2解锁]</span>
                        </div>
                        <div class="help-item-desc" data-i18n="help_tower_sharding_desc">AOE范围伤害，可升级至Lv10</div>
                        <div class="knowledge-box">
                            <span style="color: #ffd700;">成本75</span> | 
                            <span style="color: #00ffff;">射程150</span> | 
                            <span style="color: #ff6b6b;">AOE伤害30</span>
                        </div>
                        <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_sharding_special">💎 特攻分裂怪 (1.2x-2.5x)</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #2ecc71; border-radius: 4px; text-align: center; line-height: 24px; margin-right: 8px; vertical-align: middle;">🎯</span>
                            <span data-i18n="help_tower_zk_title">ZK狙击 - 零知识证明 [Lv3解锁]</span>
                        </div>
                        <div class="help-item-desc" data-i18n="help_tower_zk_desc">超远射程，可升级至Lv10</div>
                        <div class="knowledge-box">
                            <span style="color: #ffd700;">成本90</span> | 
                            <span style="color: #00ffff;">射程260</span> | 
                            <span style="color: #ff6b6b;">伤害50</span>
                        </div>
                        <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_zk_special">💥 特攻装甲怪/BOSS (1.5x-2.8x / 1.1x-2.0x)</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #3498db; border-radius: 4px; text-align: center; line-height: 24px; margin-right: 8px; vertical-align: middle;">⚡</span>
                            <span data-i18n="help_tower_l2_title">L2通道 - Layer2扩容 [Lv4解锁]</span>
                        </div>
                        <div class="help-item-desc" data-i18n="help_tower_l2_desc">持续激光，可升级至Lv10</div>
                        <div class="knowledge-box">
                            <span style="color: #ffd700;">成本100</span> | 
                            <span style="color: #00ffff;">射程180</span> | 
                            <span style="color: #ff6b6b;">伤害20/s</span>
                        </div>
                        <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_l2_special">⚡ 特攻回血怪 (1.2x-2.5x + 压制40%-85%)</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #f39c12; border-radius: 4px; text-align: center; line-height: 24px; margin-right: 8px; vertical-align: middle;">☄️</span>
                            <span data-i18n="help_tower_cannon_title">主网大炮 - 硬分叉 [Lv5解锁]</span>
                        </div>
                        <div class="help-item-desc" data-i18n="help_tower_cannon_desc">手动轰炸，对BOSS特效</div>
                        <div class="knowledge-box">
                            <span style="color: #ffd700;">成本80</span> | 
                            <span style="color: #ffd700;">使用150 GAS</span> | 
                            <span style="color: #ff6b6b;">AOE伤害200</span>
                        </div>
                        <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_cannon_special">💥 对BOSS造成30%当前HP伤害！</div>
                    </div>
                </div>
            </div>
            
            <!-- 敌人类型 -->
            <div class="help-section" style="margin-bottom: 20px;">
                <div class="help-title" data-i18n="help_title_enemies">👾 敌人类型</div>
                <div class="help-content">
                    <div class="help-item">
                        <div class="help-item-title" style="color:#00ff88" data-i18n="help_enemy_valid_title">■ 合法交易</div>
                        <div class="help-item-desc" data-i18n="help_enemy_valid_desc">让它进入区块！验证后奖励+5 GAS</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" style="color:#ff0044" data-i18n="help_enemy_spam_title">🦠 垃圾交易</div>
                        <div class="help-item-desc" data-i18n="help_enemy_spam_desc">快速但脆弱，奖励3 GAS</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" style="color:#ff00ff" data-i18n="help_enemy_double_title">👻 双花攻击 [隐身]</div>
                        <div class="help-item-desc" data-i18n="help_enemy_double_desc">隐身单位，需要真视才能攻击</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" style="color:#00aaff" data-i18n="help_enemy_splitter_title">💎 粉尘攻击 [分裂]</div>
                        <div class="help-item-desc" data-i18n="help_enemy_splitter_desc">死后分裂成3个小怪</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" style="color:#888888" data-i18n="help_enemy_shielded_title">🛡️ 混币器 [减伤]</div>
                        <div class="help-item-desc" data-i18n="help_enemy_shielded_desc">200 HP + 50%减伤护盾</div>
                        <div class="text-pink-400 text-xs mt-1" data-i18n="help_enemy_shielded_counter">克星：ZK狙击塔</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" style="color:#00ff00" data-i18n="help_enemy_healer_title">💚 高频交易 [回血]</div>
                        <div class="help-item-desc" data-i18n="help_enemy_healer_desc">150 HP + 每秒恢复8 HP</div>
                        <div class="text-yellow-400 text-xs mt-1" data-i18n="help_enemy_healer_counter">克星：Layer 2通道</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" style="color:#ff0000" data-i18n="help_enemy_boss_title">☠️ 51%攻击 [BOSS]</div>
                        <div class="help-item-desc" data-i18n="help_enemy_boss_desc">10000 HP + 55%减伤 + 回血3/s</div>
                        <div class="text-red-400 text-xs mt-1" data-i18n="help_enemy_boss_counter">克星：主网大炮 + ZK狙击塔</div>
                    </div>
                </div>
            </div>
            
            <!-- 游戏技巧 -->
            <div class="help-section" style="margin-bottom: 20px;">
                <div class="help-title" data-i18n="help_title_tips">💡 游戏技巧</div>
                <div class="help-content">
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_economy_title">经济优先</div>
                        <div class="help-item-desc" data-i18n="help_tip_economy_desc">前期多建矿机，保证经济发展</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_upgrade_title">升级优于新建</div>
                        <div class="help-item-desc" data-i18n="help_tip_upgrade_desc">升级塔性价比约2倍，优先升级核心塔至Lv10</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_priority_title">索敌优先级</div>
                        <div class="help-item-desc" data-i18n="help_tip_priority_desc">点击塔可设置：第一/最后/特攻/最强/最弱/最近</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_combo_title">合理搭配</div>
                        <div class="help-item-desc" data-i18n="help_tip_combo_desc">Gas站+合约门+主力塔 = 完美组合</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title" data-i18n="help_tip_counter_title">针对性防御</div>
                        <div class="help-item-desc" data-i18n="help_tip_counter_desc">垃圾交易→验证哨 | 装甲怪→ZK狙击 | 分裂怪→分片炮 | 回血怪→L2通道</div>
                    </div>
                </div>
            </div>
            
            </div>
            <!-- End of Tab Content: Encyclopedia -->
            
        </div>
        
        <!-- Fixed Back Buttons at Bottom Right -->
        <div style="position: fixed; bottom: 40px; right: 40px; z-index: 100; display: flex; gap: 10px;">
            <button class="game-btn" onclick="backToLevelSelect()" style="border-color: #00ffff; color: #00ffff; padding: 8px 16px; font-size: 14px;" data-i18n="btn_back_level_select">
                ← 选关
            </button>
            <button class="game-btn" onclick="backToMainMenu()" style="border-color: #888; color: #888; padding: 8px 16px; font-size: 14px;" data-i18n="btn_back_main">
                ← 主菜单
            </button>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen" style="display: none;">
        <h1 class="text-5xl font-bold text-red-500 mb-4" style="text-shadow: 0 0 20px #ff0040;" data-i18n="defeat_title">区块被污染！</h1>
        <p class="text-xl text-red-300 mb-2">CONSENSUS FAILED</p>
        <p class="text-gray-400 mb-8" data-i18n="defeat_description">恶意交易入侵了区块，共识失败...</p>
        <div class="flex gap-4">
            <button class="game-btn" onclick="restartCurrentLevel()" data-i18n="btn_restart">🔁 重试本关 RETRY</button>
            <button class="game-btn" onclick="returnToLevelSelect()" style="border-color: #00aaff; color: #00aaff;" data-i18n="btn_levels">🎮 选择关卡 LEVELS</button>
            <button class="game-btn" onclick="location.reload()" style="border-color: #666; color: #888;" data-i18n="btn_reset">🔄 重置游戏 RESET</button>
        </div>
    </div>
    
    <!-- Pause Screen -->
    <div id="pauseScreen" style="display: none;">
        <div class="text-center">
            <h1 class="text-5xl font-bold text-cyan-400 mb-4 neon-text" data-i18n="pause_title">游戏暂停</h1>
            <p class="text-xl text-cyan-300 mb-2" data-i18n="pause_subtitle">PAUSED</p>
            <p class="text-gray-400 mb-8" data-i18n="pause_description">按 ESC 或点击按钮继续游戏</p>
            <div class="flex flex-col gap-4 items-center">
                <button class="game-btn" onclick="togglePause()" data-i18n="btn_resume" style="min-width: 280px;">▶ 继续游戏 RESUME</button>
                <button class="game-btn" onclick="restartCurrentLevel()" style="border-color: #ffaa00; color: #ffaa00; min-width: 280px;" data-i18n="btn_restart">🔁 重新游玩本关 REPLAY</button>
                <button class="game-btn" onclick="returnToLevelSelect()" style="border-color: #00aaff; color: #00aaff; min-width: 280px;" data-i18n="btn_levels">🎮 切换关卡 LEVELS</button>
                <button class="game-btn" onclick="location.reload()" style="border-color: #ff6600; color: #ff6600; min-width: 280px;" data-i18n="btn_reset">🔄 重置游戏 RESET</button>
            </div>
            <div class="mt-8 text-gray-500 text-sm">
                <p><span data-i18n="pause_current_level">当前关卡</span>: <span id="pauseLevel" class="text-cyan-400">1</span>/5</p>
                <p><span data-i18n="pause_balance">余额</span>: <span id="pauseBalance" class="text-yellow-400">100</span> GAS</p>
            </div>
        </div>
    </div>
    
    <!-- Space Pause Overlay -->
    <div id="spacePauseOverlay">
        <div class="pause-indicator">
            <div class="text-3xl text-cyan-400 neon-text mb-2" data-i18n="space_pause_title">⏸ 暂停中</div>
            <div class="text-gray-400 text-sm" data-i18n="space_pause_hint">按空格键或点击暂停按钮继续</div>
        </div>
    </div>
    
    <!-- Victory Screen -->
    <div id="victoryScreen" style="display: none; padding: 40px 20px; overflow-y: auto; max-height: 100vh;">
        <div style="max-width: 580px; text-align: center; padding: 20px; margin: 0 auto;">
            <div style="font-size: 70px; margin-bottom: 10px; animation: bounce 2s infinite;">🏆</div>
            <h1 class="text-3xl font-bold text-green-400 mb-2" style="text-shadow: 0 0 20px #00ff00;" data-i18n="victory_title">使命完成！</h1>
            <p class="text-base text-green-300 mb-3" data-i18n="victory_subtitle">MISSION ACCOMPLISHED</p>
            
            <div style="background: linear-gradient(135deg, rgba(0,100,50,0.3), rgba(0,50,30,0.3)); border: 2px solid #00ff88; border-radius: 10px; padding: 15px; margin: 15px 0; text-align: left;">
                <p style="color: #00ffff; font-size: 15px; font-weight: bold; margin-bottom: 10px;" data-i18n="victory_ending_title">📜 结局：区块链守护者</p>
                <p style="color: #cccccc; line-height: 1.5; margin-bottom: 10px; font-size: 13px;" data-i18n="victory_story_1">
                    2045年，在你的守护下，区块链网络经受住了最严峻的考验。
                    从简单的交易验证，到抵御51%攻击，你掌握了所有的防御技术。
                </p>
                <p style="color: #cccccc; line-height: 1.5; margin-bottom: 10px; font-size: 12px;">
                    <span style="color: #00ff88;">✓</span> <span data-i18n="victory_tech_1">非对称加密保护了用户的身份</span><br>
                    <span style="color: #00ff88;">✓</span> <span data-i18n="victory_tech_2">分片技术实现了网络扩容</span><br>
                    <span style="color: #00ff88;">✓</span> <span data-i18n="victory_tech_3">零知识证明保障了隐私</span><br>
                    <span style="color: #00ff88;">✓</span> <span data-i18n="victory_tech_4">Layer 2 提升了交易速度</span><br>
                    <span style="color: #00ff88;">✓</span> <span data-i18n="victory_tech_5">去中心化共识抵御了攻击</span>
                </p>
                <p style="color: #ffcc00; line-height: 1.5; font-style: italic; font-size: 12px;" data-i18n="victory_quote">
                    "但这不是结束...只要区块链存在，威胁就永远存在。<br>
                    而你，将继续守护这个去中心化的世界。"
                </p>
            </div>
            
            <div style="background: rgba(255,100,255,0.1); border: 2px solid #ff00ff; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <p style="color: #ff00ff; font-size: 14px; font-weight: bold; margin-bottom: 6px;" data-i18n="endless_unlock_title">🌟 无尽模式已解锁！</p>
                <p style="color: #cccccc; font-size: 12px;" data-i18n="endless_unlock_desc">挑战你的极限，看看你能守护多少波攻击！</p>
            </div>
            
            <div class="flex gap-2 justify-center" style="flex-wrap: nowrap; margin-bottom: 15px;">
                <button class="game-btn" onclick="startEndlessMode()" style="border-color: #ff00ff; color: #ff00ff; font-size: 13px; padding: 8px 16px; white-space: nowrap;" data-i18n="btn_endless">∞ 无尽模式</button>
                <button class="game-btn" onclick="returnToLevelSelect()" style="font-size: 13px; padding: 8px 16px; white-space: nowrap;" data-i18n="btn_levels">🎮 返回选关</button>
                <button class="game-btn" onclick="location.reload()" style="border-color: #888; color: #888; font-size: 13px; padding: 8px 16px; white-space: nowrap;" data-i18n="btn_reset">🔄 重新开始</button>
            </div>
            
            <div style="padding-top: 12px; border-top: 1px solid rgba(0,255,255,0.2);">
                <p style="color: #00ffff; font-size: 12px; margin-bottom: 6px;" data-i18n="victory_thanks">感谢游玩 BlockRush！</p>
                <p style="color: #888; font-size: 10px;" data-i18n="victory_tagline">在游戏中学习区块链技术 🚀</p>
            </div>
        </div>
    </div>
    
    <!-- Story Modal -->
    <div id="storyModal" class="enemy-modal-overlay" style="display: none; backdrop-filter: blur(10px) !important; -webkit-backdrop-filter: blur(10px) !important; background: rgba(0, 0, 0, 0.85) !important;">
        <div class="enemy-modal knowledge-modal" style="max-width: 650px; background: rgba(0, 15, 30, 0.95) !important; border: 4px solid rgba(0, 255, 255, 0.7) !important; box-shadow: 0 0 50px rgba(0, 255, 255, 0.5) !important; position: relative; overflow: hidden;">
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 255, 0.03) 2px, rgba(0, 255, 255, 0.03) 4px); pointer-events: none; z-index: 0;"></div>
            <div style="position: relative; z-index: 1;">
                <div class="enemy-modal-icon" id="storyIcon" style="display: none !important;">📖</div>
                <div class="text-sm mb-2" style="color: #00ffff !important; font-weight: bold !important; letter-spacing: 2px !important; font-size: 22px !important; text-transform: uppercase !important; margin-bottom: 25px !important; text-shadow: 0 0 20px rgba(0, 255, 255, 0.9) !important;" id="storySubtitle">任务简报 / MISSION BRIEFING</div>
                <div class="enemy-modal-title" id="storyTitle" style="display: none;">开场剧情</div>
                <div class="enemy-modal-desc" id="storyContent" style="white-space: normal !important; max-height: 320px; overflow-y: auto; margin-bottom: 30px !important; line-height: 1.8 !important; font-size: 15px !important; padding: 0 20px;">
                    剧情内容...
                </div>
                <div style="text-align: center; margin: 25px 0 15px 0;">
                    <div id="mechanicsTitle" style="display: inline-block; color: rgba(0, 255, 255, 0.6); font-size: 12px; letter-spacing: 1.5px; margin-bottom: 15px; text-transform: uppercase; font-weight: 600;">▼ 核心机制 / CORE MECHANICS ▼</div>
                </div>
                <div style="display: flex; justify-content: center; align-items: center; gap: 100px; margin: 20px 0 30px 0;">
                    <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
                        <svg width="60" height="60" viewBox="0 0 60 60" style="filter: drop-shadow(0 0 30px rgba(0, 255, 136, 1)) drop-shadow(0 0 50px rgba(0, 255, 136, 0.8)) !important; display: block;">
                            <circle cx="30" cy="30" r="26" fill="rgba(0,255,136,0.2)" stroke="#00ff88" stroke-width="2"></circle>
                            <circle cx="30" cy="30" r="18" fill="rgba(0,255,136,0.35)"></circle>
                            <circle cx="30" cy="30" r="11" fill="#00ff88"><animate attributeName="r" values="11;13;11" dur="2s" repeatCount="indefinite"></animate></circle>
                        </svg>
                        <div id="mechanicsAllow" style="margin-top: 12px; font-size: 15px; font-weight: 600; color: #00ff88; text-shadow: 0 0 15px rgba(0, 255, 136, 1); text-align: center; white-space: nowrap;">合法交易 → 放行</div>
                    </div>
                    <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
                        <svg width="60" height="60" viewBox="0 0 60 60" style="filter: drop-shadow(0 0 30px rgba(255, 0, 68, 1)) drop-shadow(0 0 50px rgba(255, 0, 68, 0.8)) !important; display: block;">
                            <circle cx="30" cy="30" r="26" fill="rgba(255,0,68,0.2)" stroke="#ff0044" stroke-width="2"></circle>
                            <circle cx="30" cy="30" r="18" fill="rgba(255,0,68,0.35)"></circle>
                            <circle cx="30" cy="30" r="11" fill="#ff0044"><animate attributeName="r" values="11;13;11" dur="1.5s" repeatCount="indefinite"></animate></circle>
                            <line x1="22" y1="22" x2="38" y2="38" stroke="#fff" stroke-width="3.5"></line>
                            <line x1="38" y1="22" x2="22" y2="38" stroke="#fff" stroke-width="3.5"></line>
                        </svg>
                        <div id="mechanicsDestroy" style="margin-top: 12px; font-size: 15px; font-weight: 600; color: #ff0044; text-shadow: 0 0 15px rgba(255, 0, 68, 1); text-align: center; white-space: nowrap;">恶意攻击 → 消灭</div>
                    </div>
                </div>
                <button class="enemy-modal-btn" onclick="closeStoryModal()" id="storyButton" style="font-size: 19px !important; padding: 16px 70px !important; background: linear-gradient(135deg, #00ffff, #00ccff) !important; color: #000 !important; font-weight: bold !important; border: none !important; box-shadow: 0 0 40px rgba(0, 255, 255, 0.7), 0 5px 20px rgba(0, 0, 0, 0.4) !important; text-shadow: none !important; transition: all 0.3s ease !important; text-transform: uppercase !important; letter-spacing: 1px !important;">开始守护</button>
            </div>
        </div>
    </div>
    
    <!-- Enemy Info Modal -->
    <div id="enemyModalOverlay" class="enemy-modal-overlay" style="display: none;">
        <div class="enemy-modal" id="enemyModal">
            <div class="enemy-modal-icon" id="enemyModalIcon">👾</div>
            <div class="text-sm mb-2" style="color: #ff6666;" id="enemyModalLabel" data-i18n="enemy_new_appear">⚠ 新敌人出现！</div>
            <div class="enemy-modal-title" id="enemyModalTitle">敌人名称</div>
            <div class="enemy-modal-desc" id="enemyModalDesc">敌人描述</div>
            <div class="enemy-modal-tip" id="enemyModalTip">
                <span style="color: #ffcc00;" id="enemyModalTipLabel" data-i18n="enemy_tip_label">💡 攻略提示：</span>
                <span id="enemyModalTipText">提示内容</span>
            </div>
            <button class="enemy-modal-btn" onclick="closeEnemyModal()" data-i18n="enemy_modal_btn">我知道了 继续游戏</button>
        </div>
    </div>
    
    <!-- Credits Modal -->
    <div id="creditsModal" class="enemy-modal-overlay" style="display: none; backdrop-filter: blur(10px) !important; -webkit-backdrop-filter: blur(10px) !important; background: rgba(0, 0, 0, 0.85) !important;">
        <div class="enemy-modal knowledge-modal" style="max-width: 480px; background: rgba(0, 15, 30, 0.95) !important; border: 4px solid rgba(0, 255, 255, 0.7) !important; box-shadow: 0 0 50px rgba(0, 255, 255, 0.5) !important; position: relative; overflow: hidden; padding: 30px 25px;">
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 255, 0.03) 2px, rgba(0, 255, 255, 0.03) 4px); pointer-events: none; z-index: 0;"></div>
            <div style="position: relative; z-index: 1;">
                <div class="enemy-modal-icon" style="font-size: 40px; margin-bottom: 15px;">❤️</div>
                <div class="text-sm mb-2" style="color: #00ffff !important; font-weight: bold !important; letter-spacing: 2px !important; font-size: 20px !important; text-transform: uppercase !important; margin-bottom: 20px !important; text-shadow: 0 0 20px rgba(0, 255, 255, 0.9) !important;" data-i18n="credits_title">关于我们</div>
                <div class="enemy-modal-desc" style="white-space: normal !important; overflow: visible !important; margin-bottom: 25px !important; line-height: 1.6 !important; font-size: 14px !important; padding: 0 15px; text-align: left;">
                    <div style="margin-bottom: 20px;">
                        <div style="color: #00ffff; font-weight: bold; margin-bottom: 12px; font-size: 15px; font-family: 'Microsoft YaHei', 'SimHei', 'Heiti SC', sans-serif;" data-i18n="credits_developers">开发团队：</div>
                        <div style="color: #fff; margin-bottom: 12px;">
                            <span style="color: #ffcc00; font-weight: bold; font-size: 16px; font-family: 'Microsoft YaHei', 'SimHei', 'Heiti SC', sans-serif; display: block; margin-bottom: 5px;">方文浩</span>
                            <span style="color: #888; font-size: 12px;">3898181031@qq.com</span>
                        </div>
                        <div style="color: #fff; margin-bottom: 8px;">
                            <span style="color: #ffcc00; font-weight: bold; font-size: 16px; font-family: 'Microsoft YaHei', 'SimHei', 'Heiti SC', sans-serif; display: block; margin-bottom: 5px;">彭士雄</span>
                            <span style="color: #888; font-size: 12px;">jilan_26@qq.com</span>
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <div style="color: #00ffff; font-weight: bold; margin-bottom: 12px; font-size: 15px; font-family: 'Microsoft YaHei', 'SimHei', 'Heiti SC', sans-serif;" data-i18n="credits_thanks">特别鸣谢：</div>
                        <div style="color: #ff6b6b; font-weight: bold; font-size: 17px; margin-bottom: 5px;">Kiro</div>
                        <div style="color: #888; font-size: 12px;" data-i18n="credits_kiro_desc">AI 开发助手</div>
                    </div>
                </div>
                <button class="enemy-modal-btn" onclick="closeCredits()" style="font-size: 15px !important; padding: 10px 35px !important; background: linear-gradient(135deg, #00ffff, #00ccff) !important; color: #000 !important; font-weight: bold !important; border: none !important; box-shadow: 0 0 40px rgba(0, 255, 255, 0.7), 0 5px 20px rgba(0, 0, 0, 0.4) !important; text-shadow: none !important; transition: all 0.3s ease !important;" data-i18n="credits_close">关闭</button>
            </div>
        </div>
    </div>
    
    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" style="display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.85); z-index: 9999; pointer-events: none;">
        <!-- Tutorial Highlight -->
        <div id="tutorialHighlight" style="position: absolute; border: 3px solid #00ffff; box-shadow: 0 0 30px rgba(0, 255, 255, 0.8); border-radius: 8px; pointer-events: auto;"></div>
        
        <!-- Tutorial Message Box -->
        <div id="tutorialMessage" style="position: absolute; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #00ffff; border-radius: 15px; padding: 20px; max-width: 400px; box-shadow: 0 0 30px rgba(0, 255, 255, 0.5); pointer-events: auto;">
            <div style="font-size: 24px; margin-bottom: 8px;" id="tutorialIcon">👋</div>
            <div style="font-size: 18px; font-weight: bold; color: #00ffff; margin-bottom: 12px;" id="tutorialTitle">欢迎！</div>
            <div style="font-size: 14px; color: #cccccc; line-height: 1.6; margin-bottom: 16px;" id="tutorialText">教程文本</div>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="game-btn" onclick="skipTutorial()" style="border-color: #888; color: #888; font-size: 12px; padding: 8px 16px;">跳过教程</button>
                <button class="game-btn" onclick="nextTutorialStep()" id="tutorialNextBtn" style="font-size: 12px; padding: 8px 16px;">下一步</button>
            </div>
        </div>
        
        <!-- Arrow Indicator -->
        <div id="tutorialArrow" style="position: absolute; font-size: 48px; animation: bounce 1s infinite; pointer-events: none;">👇</div>
    </div>
    
    <!-- Knowledge Modal for new levels -->
    <div id="knowledgeModalOverlay" class="enemy-modal-overlay" style="display: none;">
        <div class="enemy-modal knowledge-modal" id="knowledgeModal" style="max-width: 650px; padding: 25px;">
            <!-- Left-Right Layout -->
            <div style="display: flex; gap: 25px; align-items: center;">
                <!-- Left: Tower Image/Icon (merged with box) -->
                <div style="flex-shrink: 0; width: 180px; display: flex; flex-direction: column; align-items: center; gap: 10px;">
                    <!-- Tower Visual with Icon in Center -->
                    <div id="knowledgeModalIcon" style="width: 180px; height: 180px; border-radius: 15px; background: rgba(0, 255, 255, 0.1); border: 3px solid rgba(0, 255, 255, 0.4); display: flex; align-items: center; justify-content: center; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); position: relative; overflow: visible;">
                        📚
                    </div>
                    <div style="text-align: center; color: #00ffff; font-size: 11px; opacity: 0.7;" data-i18n="knowledge_ai_label">链灵 AI</div>
                </div>
                
                <!-- Right: Content -->
                <div style="flex: 1; min-width: 0;">
                    <div class="text-sm mb-2" style="color: #00ffff; font-weight: bold; font-size: 13px;" data-i18n="knowledge_unlocked">🔓 新科技解锁！</div>
                    <div class="enemy-modal-title" id="knowledgeModalTitle" style="margin-bottom: 15px; font-size: 24px;">科技名称</div>
                    <div class="enemy-modal-desc" id="knowledgeModalDesc" style="margin-bottom: 20px; font-size: 14px; line-height: 1.7; color: #e0e0e0;">科技描述</div>
                    
                    <button class="enemy-modal-btn" onclick="closeKnowledgeModal()" data-i18n="btn_start_challenge" style="width: 100%; padding: 12px; font-size: 16px;">开始挑战！</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Tower Management Panel (Upgrade + Sell) -->
    <div id="sellPanel">
        <div class="text-cyan-400 text-sm mb-2 font-bold" id="sellTowerName">验证节点</div>
        <div class="text-white text-xs mb-2" id="towerLevel"><span data-i18n="panel_level">等级</span>: Lv1</div>
        
        <!-- 当前属性 -->
        <div class="text-gray-400 text-xs mb-2" style="border-top: 1px solid rgba(0,255,255,0.2); padding-top: 8px;">
            <div id="towerStats">
                <div><span data-i18n="panel_stat_damage">伤害</span>: <span class="text-cyan-400" id="statDamage">20</span></div>
                <div><span data-i18n="panel_stat_range">射程</span>: <span class="text-cyan-400" id="statRange">120</span></div>
                <div><span data-i18n="panel_stat_speed">攻速</span>: <span class="text-cyan-400" id="statSpeed">1.0s</span></div>
            </div>
        </div>
        
        <!-- 索敌优先级选择 -->
        <div id="targetPrioritySection" style="border-top: 1px solid rgba(0,255,255,0.2); padding-top: 8px; margin-bottom: 8px;">
            <div class="text-gray-400 text-xs mb-2" data-i18n="panel_target_priority">🎯 索敌优先级</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="sell-btn" style="padding: 4px 8px; font-size: 10px;" onclick="setTargetPriority('first')">
                    <span id="priority-first">⭕</span> <span data-i18n="panel_priority_first">第一</span>
                </button>
                <button class="sell-btn" style="padding: 4px 8px; font-size: 10px;" onclick="setTargetPriority('last')">
                    <span id="priority-last">⭕</span> <span data-i18n="panel_priority_last">最后</span>
                </button>
                <button class="sell-btn" style="padding: 4px 8px; font-size: 10px;" onclick="setTargetPriority('counter')">
                    <span id="priority-counter">⭕</span> <span data-i18n="panel_priority_counter">特攻</span>
                </button>
                <button class="sell-btn" style="padding: 4px 8px; font-size: 10px;" onclick="setTargetPriority('strongest')">
                    <span id="priority-strongest">⭕</span> <span data-i18n="panel_priority_strongest">最强</span>
                </button>
                <button class="sell-btn" style="padding: 4px 8px; font-size: 10px;" onclick="setTargetPriority('weakest')">
                    <span id="priority-weakest">⭕</span> <span data-i18n="panel_priority_weakest">最弱</span>
                </button>
                <button class="sell-btn" style="padding: 4px 8px; font-size: 10px;" onclick="setTargetPriority('nearest')">
                    <span id="priority-nearest">⭕</span> <span data-i18n="panel_priority_nearest">最近</span>
                </button>
            </div>
        </div>
        
        <!-- 升级按钮 -->
        <div id="upgradeSection" style="margin-bottom: 8px;">
            <div class="text-gray-400 text-xs mb-1"><span data-i18n="panel_upgrade_to">升级到</span> Lv<span id="nextLevel">2</span></div>
            <button class="sell-btn" style="border-color: #00ff00; color: #00ff00;" onclick="upgradeSelectedTower()">
                <span data-i18n="panel_upgrade">⬆ 升级 (W)</span> (<span id="upgradeCost">30</span> GAS)
            </button>
        </div>
        
        <!-- 满级提示 -->
        <div id="maxLevelSection" style="display: none; margin-bottom: 8px;">
            <div class="text-gray-400 text-xs mb-1"><span data-i18n="panel_current_level">当前等级</span> Lv<span id="currentMaxLevel">10</span></div>
            <button class="sell-btn" style="border-color: #ffaa00; color: #ffaa00; opacity: 0.6; cursor: not-allowed;" disabled>
                <span data-i18n="panel_max_level_btn">⭐ 已满级</span>
            </button>
        </div>
        
        <!-- 出售按钮 -->
        <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
            <div class="text-gray-400 text-xs mb-1" id="sellRatioText">出售返还 70%</div>
            <button class="sell-btn" onclick="sellSelectedTower()"><span data-i18n="panel_sell">💰 出售 (Q)</span> (+<span id="sellPrice">14</span> GAS)</button>
        </div>
        
        <button class="sell-btn" style="margin-top: 8px; border-color: #666; color: #888;" onclick="closeSellPanel()" data-i18n="panel_cancel">取消</button>
    </div>
    
    <!-- Cannon Target Overlay -->
    <div id="cannonTargetOverlay" onclick="fireMainnetCannon(event)" onmousemove="updateCannonPreview(event)">
        <canvas id="cannonPreviewCanvas" style="position: fixed; inset: 0; pointer-events: none;"></canvas>
        <div class="cannon-hint">
            <div>🎯 点击选择轰炸区域</div>
            <div class="text-sm mt-2">消耗 150 GAS | 右键取消</div>
        </div>
    </div>
    
    <!-- Main Game UI -->
    <div id="gameUI" class="fixed inset-0 pointer-events-none" style="display: none;">
        <!-- Top Left - Block Info -->
        <div class="absolute top-4 left-4 pointer-events-auto">
            <div class="neon-border rounded-lg bg-gray-900/80" style="width: 200px; min-width: 200px; padding: 16px;">
                <div class="text-cyan-400 text-xs mb-1"><span data-i18n="ui_level">LEVEL</span> <span id="levelNum">1</span>/5</div>
                <div style="height: 28px; overflow: hidden; position: relative;">
                    <div class="text-lg font-bold text-white" id="levelName" data-i18n="level_1_name" 
                         style="white-space: nowrap; display: inline-block;">
                        交易验证
                    </div>
                </div>
                <div class="text-xs text-gray-400 mt-2" data-i18n="ui_block_height">BLOCK HEIGHT</div>
                <div class="text-xl font-bold text-cyan-400" style="text-shadow: 0 0 2px rgba(0, 255, 255, 0.3);">#<span id="blockHeight">1024</span></div>
                <div class="text-xs text-gray-400 mt-2" data-i18n="ui_transactions">TRANSACTIONS</div>
                <div class="w-full h-2 bg-gray-800 rounded-full mt-1 overflow-hidden">
                    <div id="txProgress" class="h-full bg-gradient-to-r from-cyan-500 to-green-400 transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="text-xs text-gray-500 mt-1"><span id="txCount">0</span>/<span id="txRequired">10</span> TXs</div>
            </div>
        </div>
        
        <!-- Enemy Info Panel (Right Side) -->
        <div class="absolute top-4 left-64 pointer-events-auto">
            <div id="enemyInfoPanel" class="neon-border rounded-lg p-3 bg-gray-900/80" style="display: none; min-width: 200px;">
                <div class="text-red-400 text-xs mb-2" data-i18n="enemy_info_title">⚠ ENEMY INFO</div>
                <div class="flex items-center gap-2 mb-2">
                    <div class="text-3xl" id="enemyInfoIcon">🦠</div>
                    <div class="flex-1">
                        <div class="text-white font-bold text-sm" id="enemyInfoName">垃圾交易</div>
                        <div class="text-gray-400 text-xs" id="enemyInfoType">spam</div>
                    </div>
                </div>
                
                <!-- HP Bar -->
                <div class="mb-2">
                    <div class="flex justify-between text-xs mb-1">
                        <span class="text-gray-400" data-i18n="enemy_info_hp">HP</span>
                        <span class="text-white"><span id="enemyInfoHp">30</span>/<span id="enemyInfoMaxHp">30</span></span>
                    </div>
                    <div class="w-full h-2 bg-gray-800 rounded-full overflow-hidden">
                        <div id="enemyInfoHpBar" class="h-full bg-gradient-to-r from-red-500 to-orange-400 transition-all duration-200" style="width: 100%"></div>
                    </div>
                </div>
                
                <!-- Stats -->
                <div class="text-xs space-y-1">
                    <div class="flex justify-between">
                        <span class="text-gray-400"><span data-i18n="enemy_info_speed">速度</span>:</span>
                        <span class="text-cyan-400" id="enemyInfoSpeed">1.5</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400"><span data-i18n="enemy_info_reward">奖励</span>:</span>
                        <span class="text-yellow-400" id="enemyInfoReward">3 GAS</span>
                    </div>
                    <div id="enemyInfoSpecial" class="text-purple-400 mt-2" style="display: none;">
                        <span class="text-gray-400">特性:</span> <span id="enemyInfoSpecialText">无</span>
                    </div>
                </div>
                
                <button onclick="closeEnemyInfo()" class="mt-2 w-full text-xs text-gray-400 hover:text-white transition-colors" data-i18n="btn_close"></button>
                    ✕ 关闭
                </button>
            </div>
        </div>
        
        <!-- Top Right - Wallet -->
        <div class="absolute top-4 right-4 pointer-events-auto" style="width: 180px;">
            <div class="neon-border rounded-lg bg-gray-900/80" style="padding: 16px;">
                <div class="text-cyan-400 text-xs mb-1" data-i18n="ui_wallet_balance" style="height: 14px; overflow: hidden; text-align: right;">WALLET BALANCE</div>
                <div class="text-2xl font-bold text-yellow-400" style="height: 32px; overflow: hidden; text-align: right; text-shadow: 0 0 2px rgba(255, 215, 0, 0.3);">
                    <span id="balance" style="display: inline-block; max-width: 120px; overflow: hidden; text-overflow: ellipsis;">100</span> <span class="text-sm">GAS</span>
                </div>
                <div class="text-xs text-gray-400 mt-2" data-i18n="ui_lives" style="height: 14px; overflow: hidden; text-align: right;">网络完整性</div>
                <div class="text-lg font-bold" style="color: #00ff88; height: 24px; overflow: hidden; text-align: right; text-shadow: 0 0 2px rgba(0, 255, 136, 0.3);">
                    🛡️ <span id="lives">1</span>/<span id="maxLives">1</span>
                </div>
                <div class="text-xs text-gray-400 mt-2" data-i18n="ui_wave" style="height: 14px; overflow: hidden; text-align: right;">WAVE</div>
                <div class="text-lg text-white" style="height: 24px; overflow: hidden; text-align: right; text-shadow: 0 0 2px rgba(255, 255, 255, 0.2);"><span id="currentWaveNum">1</span>/<span id="totalWavesNum">3</span></div>
                <div class="text-xs text-gray-400 mt-1" data-i18n="ui_enemies" style="height: 14px; overflow: hidden; text-align: right;">ENEMIES</div>
                <div class="text-lg text-white" style="height: 24px; overflow: hidden; text-align: right; text-shadow: 0 0 2px rgba(255, 255, 255, 0.2);">💀 <span id="enemiesLeft">0</span> <span data-i18n="ui_remaining">remaining</span></div>
            </div>
            <button onclick="togglePause()" 
                    class="mt-2 w-full neon-border rounded-lg p-2 bg-gray-900/80 text-cyan-400 hover:bg-cyan-900/50 transition-all flex items-center justify-center gap-2">
                <span id="pauseIcon">☰</span>
                <span id="pauseText" class="text-xs" data-i18n="ui_menu_esc">菜单 ESC</span>
            </button>
            <button id="soundBtn" onclick="toggleVolumePanel()" 
                    class="mt-2 w-full neon-border rounded-lg p-2 bg-gray-900/80 text-green-400 hover:bg-green-900/50 transition-all flex items-center justify-center gap-2">
                <span>🔊</span>
                <span class="text-xs" data-i18n="ui_volume">音量</span>
            </button>
            
            <!-- Volume Control Panel -->
            <div id="volumePanel" style="display: none;" 
                 class="mt-2 w-full neon-border rounded-lg p-3 bg-gray-900/95 text-white">
                <div class="text-xs font-bold text-cyan-400 mb-2" data-i18n="ui_volume_control">音量控制</div>
                
                <!-- BGM Volume -->
                <div class="mb-3">
                    <div class="flex justify-between text-xs mb-1">
                        <span class="text-gray-400" data-i18n="ui_bgm">🎵 背景音乐</span>
                        <span id="bgmVolumeText" class="text-cyan-400">15%</span>
                    </div>
                    <input type="range" id="bgmVolumeSlider" min="0" max="100" value="15" 
                           oninput="updateBGMVolume(this.value)"
                           class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                           style="accent-color: #00ffff;">
                </div>
                
                <!-- SFX Volume -->
                <div>
                    <div class="flex justify-between text-xs mb-1">
                        <span class="text-gray-400" data-i18n="ui_sfx">🔊 音效</span>
                        <span id="sfxVolumeText" class="text-cyan-400">30%</span>
                    </div>
                    <input type="range" id="sfxVolumeSlider" min="0" max="100" value="30" 
                           oninput="updateSFXVolume(this.value)"
                           class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                           style="accent-color: #00ffff;">
                </div>
            </div>
        </div>
        
        <!-- Bottom Center - Tower Menu with Controls -->
        <div id="towerMenuContainer" class="absolute bottom-4 left-1/2 -translate-x-1/2 pointer-events-auto transition-all duration-300" style="max-width: 95vw;">
            <!-- Toggle Button -->
            <button id="towerMenuToggle" onclick="toggleTowerMenu()" 
                    class="absolute -top-6 left-1/2 -translate-x-1/2 rounded-t-md px-4 py-1 bg-gray-900/95 text-cyan-400 hover:bg-cyan-900/50 transition-all text-xs"
                    style="border: 2px solid rgba(0, 255, 255, 0.5); border-bottom: none; height: 24px;">
                <span id="towerMenuToggleIcon">▼</span> <span data-i18n="ui_tower_menu">收起</span>
            </button>
            
            <div id="towerMenuContent" class="neon-border rounded-lg p-2 bg-gray-900/90 flex items-center gap-2">
                <div class="tower-menu-scroll">
                    <div class="tower-btn flex flex-col items-center p-2 rounded-lg bg-gray-800 text-cyan-400 border border-cyan-400/30 min-w-[70px] relative"
                         data-tower="validator"
                         onmouseenter="showTooltip(event, 'validator')" onmouseleave="hideTooltip()">
                        <div class="absolute top-1 left-1 text-xs bg-black/70 rounded px-1">1</div>
                        <div class="w-10 h-10 rounded-full bg-cyan-900 flex items-center justify-center border-2 border-cyan-400">
                            <span class="text-lg">🔐</span>
                        </div>
                        <div class="text-xs mt-1" data-i18n="ui_tower_validator">验证哨</div>
                        <div class="text-yellow-400 text-lg font-bold">25</div>
                    </div>
                    
                    <div class="tower-btn flex flex-col items-center p-2 rounded-lg bg-gray-800 text-orange-400 border border-orange-400/30 min-w-[70px] relative"
                         data-tower="miner"
                         onmouseenter="showTooltip(event, 'miner')" onmouseleave="hideTooltip()">
                        <div class="absolute top-1 left-1 text-xs bg-black/70 rounded px-1">2</div>
                        <div class="w-10 h-10 rounded-full bg-orange-900 flex items-center justify-center border-2 border-orange-400">
                            <span class="text-lg">⚡</span>
                        </div>
                        <div class="text-xs mt-1" data-i18n="ui_tower_miner">矿机炮</div>
                        <div class="text-yellow-400 text-lg font-bold">50</div>
                    </div>
                    
                    <div class="tower-btn flex flex-col items-center p-2 rounded-lg bg-gray-800 text-green-400 border border-green-400/30 min-w-[70px] relative"
                         data-tower="gasStation"
                         onmouseenter="showTooltip(event, 'gasStation')" onmouseleave="hideTooltip()">
                        <div class="absolute top-1 left-1 text-xs bg-black/70 rounded px-1">3</div>
                        <div class="w-10 h-10 rounded-full bg-green-900 flex items-center justify-center border-2 border-green-400">
                            <span class="text-lg">⛽</span>
                        </div>
                        <div class="text-xs mt-1" data-i18n="ui_tower_gas">加油站</div>
                        <div class="text-yellow-400 text-lg font-bold">45</div>
                    </div>
                    
                    <div class="tower-btn flex flex-col items-center p-2 rounded-lg bg-gray-800 text-purple-400 border border-purple-400/30 min-w-[70px] relative"
                         data-tower="contract"
                         onmouseenter="showTooltip(event, 'contract')" onmouseleave="hideTooltip()">
                        <div class="absolute top-1 left-1 text-xs bg-black/70 rounded px-1">4</div>
                        <div class="w-10 h-10 rounded-full bg-purple-900 flex items-center justify-center border-2 border-purple-400">
                            <span class="text-lg">📜</span>
                        </div>
                        <div class="text-xs mt-1" data-i18n="ui_tower_contract">合约门</div>
                        <div class="text-yellow-400 text-lg font-bold">65</div>
                    </div>
                    
                    <div class="tower-btn locked flex flex-col items-center p-2 rounded-lg bg-gray-800 text-blue-400 border border-blue-400/30 min-w-[70px] relative"
                         data-tower="sharding"
                         onmouseenter="showTooltip(event, 'sharding')" onmouseleave="hideTooltip()">
                        <div class="absolute top-1 left-1 text-xs bg-black/70 rounded px-1">5</div>
                        <div class="w-10 h-10 rounded-full bg-blue-900 flex items-center justify-center border-2 border-blue-400">
                            <span class="text-lg">💥</span>
                        </div>
                        <div class="text-xs mt-1" data-i18n="ui_tower_sharding">分片炮</div>
                        <div class="text-yellow-400 text-lg font-bold">75</div>
                        <div class="text-xs text-gray-500">Lv2</div>
                    </div>
                    
                    <div class="tower-btn locked flex flex-col items-center p-2 rounded-lg bg-gray-800 text-pink-400 border border-pink-400/30 min-w-[70px] relative"
                         data-tower="zkSniper"
                         onmouseenter="showTooltip(event, 'zkSniper')" onmouseleave="hideTooltip()">
                        <div class="absolute top-1 left-1 text-xs bg-black/70 rounded px-1">6</div>
                        <div class="w-10 h-10 rounded-full bg-pink-900 flex items-center justify-center border-2 border-pink-400">
                            <span class="text-lg">🎯</span>
                        </div>
                        <div class="text-xs mt-1" data-i18n="ui_tower_zk">ZK狙击</div>
                        <div class="text-yellow-400 text-lg font-bold">90</div>
                        <div class="text-xs text-gray-500">Lv3</div>
                    </div>
                    
                    <div class="tower-btn locked flex flex-col items-center p-2 rounded-lg bg-gray-800 text-yellow-400 border border-yellow-400/30 min-w-[70px] relative"
                         data-tower="l2Channel"
                         onmouseenter="showTooltip(event, 'l2Channel')" onmouseleave="hideTooltip()">
                        <div class="absolute top-1 left-1 text-xs bg-black/70 rounded px-1">7</div>
                        <div class="w-10 h-10 rounded-full bg-yellow-900 flex items-center justify-center border-2 border-yellow-400">
                            <span class="text-lg">🌐</span>
                        </div>
                        <div class="text-xs mt-1" data-i18n="ui_tower_l2">L2通道</div>
                        <div class="text-yellow-400 text-lg font-bold">100</div>
                        <div class="text-xs text-gray-500">Lv4</div>
                    </div>
                    
                    <div class="tower-btn locked flex flex-col items-center p-2 rounded-lg bg-gray-800 text-red-400 border border-red-400/30 min-w-[70px] relative"
                         data-tower="mainnetCannon"
                         onmouseenter="showTooltip(event, 'mainnetCannon')" onmouseleave="hideTooltip()">
                        <div class="absolute top-1 left-1 text-xs bg-black/70 rounded px-1">8</div>
                        <div class="w-10 h-10 rounded-full bg-red-900 flex items-center justify-center border-2 border-red-400">
                            <span class="text-lg">☄️</span>
                        </div>
                        <div class="text-xs mt-1" data-i18n="ui_tower_cannon">主网炮</div>
                        <div class="text-yellow-400 text-lg font-bold">80</div>
                        <div class="text-xs text-gray-500">Lv5</div>
                    </div>
                </div>
                
                <!-- Control Buttons in Same Row -->
                <div class="flex flex-col gap-2 ml-2">
                    <button id="pauseBtn" onclick="toggleGamePause()" 
                            class="rounded-lg bg-gray-900/90 text-cyan-400 hover:bg-cyan-900/50 transition-all flex items-center gap-2 font-bold"
                            style="width: 110px; min-width: 110px; padding: 8px 10px; border: 2px solid rgba(255, 255, 255, 0.6);">
                        <span id="pauseBtnIcon" class="text-lg">⏸</span>
                        <div class="text-left" style="flex: 1; overflow: hidden;">
                            <div id="pauseBtnText" class="text-xs font-bold" data-i18n="btn_pause" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">暂停</div>
                            <div class="text-xs opacity-70" data-i18n="hotkey_space" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 9px;">空格键</div>
                        </div>
                    </button>
                    <button id="speedBtn" onclick="toggleSpeed()" 
                            class="rounded-lg bg-gray-900/90 text-yellow-400 hover:bg-yellow-900/50 transition-all flex items-center gap-2 font-bold"
                            style="width: 110px; min-width: 110px; padding: 8px 10px; border: 2px solid rgba(255, 215, 0, 0.6);">
                        <span id="speedIcon" class="text-lg">▶</span>
                        <div class="text-left" style="flex: 1; overflow: hidden;">
                            <div id="speedText" class="text-xs font-bold" data-i18n="ui_speed_2x" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">二倍速</div>
                            <div class="text-xs opacity-70" data-i18n="ui_hotkey_x" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 9px;">快捷键: X</div>
                        </div>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Tooltip -->
    <div id="tooltip" class="text-cyan-300"></div>
    
    <!-- Next Wave Button (Bottom Left) -->
    <div style="position: fixed; bottom: 20px; left: 20px; z-index: 100;">
        <button id="nextWaveBtn" onclick="skipToNextWave()" 
                style="display: none; padding: 12px 16px; border: 2px solid rgba(0, 255, 136, 0.8); box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);"
                class="rounded-lg bg-gray-900/95 text-green-400 hover:bg-green-900/70 transition-all flex items-center gap-3 font-bold">
            <span class="text-2xl">⏭</span>
            <div class="text-left">
                <div id="nextWaveBtnText" class="text-sm font-bold" data-i18n="btn_next_wave">下一波</div>
                <div class="text-xs opacity-70" data-i18n="hotkey_n">快捷键: N</div>
            </div>
        </button>
    </div>
    
    <!-- Help Panel -->
    <div id="helpPanel">
        <div class="help-section" style="background: linear-gradient(135deg, rgba(0,100,150,0.3), rgba(0,50,80,0.3));">
            <div class="help-title" data-i18n="help_title_goal">🎮 游戏目标</div>
            <div class="help-content">
                <div data-i18n="help_goal_content_1">守护你的<span style="color:#00ffff">区块（Block）</span>！</div>
                <br><br>
                <div data-i18n="help_goal_content_2">• <span style="color:#00ff88">绿色方块</span> = 合法交易 → <b>放行</b></div>
                <div data-i18n="help_goal_content_3">• <span style="color:#ff0044">红色敌人</span> = 恶意数据 → <b>消灭</b></div>
                <div data-i18n="help_goal_content_4">• 点击路径入口的<span style="color:#ff0044">红色图标</span>开始波次</div>
            </div>
        </div>
        
        <div class="help-section">
            <div class="help-title" data-i18n="help_title_hotkeys">⌨️ 快捷键</div>
            <div class="help-content">
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_hotkey_x_title">X - 二倍速</div>
                    <div class="help-item-desc" data-i18n="help_hotkey_x_desc">切换游戏速度（1倍 ↔ 2倍）</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_hotkey_n_title">N - 下一波</div>
                    <div class="help-item-desc" data-i18n="help_hotkey_n_desc">跳过准备时间，立即开始下一波</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_hotkey_esc_title">ESC / P - 暂停</div>
                    <div class="help-item-desc" data-i18n="help_hotkey_esc_desc">打开暂停菜单</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_hotkey_space_title">空格 - 快速暂停</div>
                    <div class="help-item-desc" data-i18n="help_hotkey_space_desc">长按暂停，松开继续</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_hotkey_w_title">W - 快捷升级</div>
                    <div class="help-item-desc" data-i18n="help_hotkey_w_desc">升级当前选中的防御塔</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_hotkey_q_title">Q - 快捷出售</div>
                    <div class="help-item-desc" data-i18n="help_hotkey_q_desc">出售当前选中的防御塔</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_hotkey_r_title">R - 主网轰炸</div>
                    <div class="help-item-desc" data-i18n="help_hotkey_r_desc">激活主网大炮瞄准模式（需要建造主网大炮）</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_hotkey_1to8_title">1-8 - 选择防御塔</div>
                    <div class="help-item-desc" data-i18n="help_hotkey_1to8_desc">快速选择对应编号的防御塔进行建造</div>
                </div>
            </div>
        </div>
        
        <div class="help-section">
            <div class="help-title" data-i18n="help_title_controls">🕹️ 操作说明</div>
            <div class="help-content">
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_control_place_title">放置防御塔</div>
                    <div class="help-item-desc" data-i18n="help_control_place_desc">点击底部塔图标 → 点击地图空地放置</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_control_upgrade_title">升级防御塔</div>
                    <div class="help-item-desc" data-i18n="help_control_upgrade_desc">点击已放置的塔 → 点击升级按钮（最高Lv4）</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_control_sell_title">出售防御塔</div>
                    <div class="help-item-desc" data-i18n="help_control_sell_desc">点击已放置的塔 → 点击出售按钮（返还70%）</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_control_enemy_title">查看敌人信息</div>
                    <div class="help-item-desc" data-i18n="help_control_enemy_desc">点击敌人查看详细属性和特性</div>
                </div>
            </div>
        </div>
        
        <div class="help-section">
            <div class="help-title" data-i18n="help_title_towers">🗼 防御塔一览</div>
            <div class="help-content">
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tower_validator_title">🔐 验证哨 - 非对称加密</div>
                    <div class="help-item-desc" data-i18n="help_tower_validator_desc">单体高伤，前期主力。可升级至Lv10</div>
                    <div class="knowledge-box" data-i18n="help_tower_validator_stats">成本25 | 射程110 | 伤害12 | 攻速1.0s</div>
                    <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_validator_special">⚡ 特攻垃圾交易 (1.2x-2.5x)</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tower_miner_title">⛏️ 矿机 - 工作量证明</div>
                    <div class="help-item-desc" data-i18n="help_tower_miner_desc">被动收入建筑，可升级至Lv10</div>
                    <div class="knowledge-box" data-i18n="help_tower_miner_stats">成本50 | 收入2 GAS/3s | 出售回收90%</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tower_gas_title">⛽ Gas站 - Gas费机制</div>
                    <div class="help-item-desc" data-i18n="help_tower_gas_desc">范围加速友军，可升级至Lv10</div>
                    <div class="knowledge-box" data-i18n="help_tower_gas_stats">成本45 | 范围100 | 加速25%-70%</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tower_contract_title">📜 合约门 - 智能合约</div>
                    <div class="help-item-desc" data-i18n="help_tower_contract_desc">范围减速+真视，可升级至Lv10</div>
                    <div class="knowledge-box" data-i18n="help_tower_contract_stats">成本65 | 范围140 | 减速35%-80%</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tower_sharding_title">💥 分片炮 - 分片技术 [Lv2解锁]</div>
                    <div class="help-item-desc" data-i18n="help_tower_sharding_desc">AOE范围伤害，可升级至Lv10</div>
                    <div class="knowledge-box" data-i18n="help_tower_sharding_stats">成本75 | 射程150 | AOE伤害30</div>
                    <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_sharding_special">💎 特攻分裂怪 (1.2x-2.5x)</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tower_zk_title">🎯 ZK狙击 - 零知识证明 [Lv3解锁]</div>
                    <div class="help-item-desc" data-i18n="help_tower_zk_desc">超远射程，可升级至Lv10</div>
                    <div class="knowledge-box" data-i18n="help_tower_zk_stats">成本90 | 射程260 | 伤害50</div>
                    <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_zk_special">💥 特攻装甲怪/BOSS (1.5x-2.8x / 1.1x-2.0x)</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tower_l2_title">⚡ L2通道 - Layer2扩容 [Lv4解锁]</div>
                    <div class="help-item-desc" data-i18n="help_tower_l2_desc">持续激光，可升级至Lv10</div>
                    <div class="knowledge-box" data-i18n="help_tower_l2_stats">成本100 | 射程180 | 伤害20/s</div>
                    <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_l2_special">⚡ 特攻回血怪 (1.2x-2.5x + 压制40%-85%)</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tower_cannon_title">☄️ 主网大炮 - 硬分叉 [Lv5解锁]</div>
                    <div class="help-item-desc" data-i18n="help_tower_cannon_desc">手动轰炸，对BOSS特效</div>
                    <div class="knowledge-box" data-i18n="help_tower_cannon_stats">成本80 | 使用150 GAS | AOE伤害200</div>
                    <div class="text-green-400 text-xs mt-1" data-i18n="help_tower_cannon_special">💥 对BOSS造成30%当前HP伤害！</div>
                </div>
            </div>
        </div>
        
        <div class="help-section">
            <div class="help-title" data-i18n="help_title_enemies">👾 敌人类型</div>
            <div class="help-content">
                <div class="help-item">
                    <div class="help-item-title" style="color:#00ff88" data-i18n="help_enemy_valid_title">■ 合法交易</div>
                    <div class="help-item-desc" data-i18n="help_enemy_valid_desc">让它进入区块！验证后奖励+5 GAS</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" style="color:#ff0044" data-i18n="help_enemy_spam_title">🦠 垃圾交易</div>
                    <div class="help-item-desc" data-i18n="help_enemy_spam_desc">快速但脆弱，奖励3 GAS</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" style="color:#ff00ff" data-i18n="help_enemy_double_title">👻 双花攻击 [隐身]</div>
                    <div class="help-item-desc" data-i18n="help_enemy_double_desc">隐身单位，需要真视才能攻击</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" style="color:#00aaff" data-i18n="help_enemy_splitter_title">💎 粉尘攻击 [分裂]</div>
                    <div class="help-item-desc" data-i18n="help_enemy_splitter_desc">死后分裂成3个小怪</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" style="color:#888888" data-i18n="help_enemy_shielded_title">🛡️ 混币器 [减伤]</div>
                    <div class="help-item-desc" data-i18n="help_enemy_shielded_desc">200 HP + 50%减伤护盾</div>
                    <div class="text-pink-400 text-xs mt-1" data-i18n="help_enemy_shielded_counter">克星：ZK狙击塔</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" style="color:#00ff00" data-i18n="help_enemy_healer_title">💚 高频交易 [回血]</div>
                    <div class="help-item-desc" data-i18n="help_enemy_healer_desc">150 HP + 每秒恢复8 HP</div>
                    <div class="text-yellow-400 text-xs mt-1" data-i18n="help_enemy_healer_counter">克星：Layer 2通道</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" style="color:#ff0000" data-i18n="help_enemy_boss_title">☠️ 51%攻击 [BOSS]</div>
                    <div class="help-item-desc" data-i18n="help_enemy_boss_desc">10000 HP + 55%减伤 + 回血3/s</div>
                    <div class="text-red-400 text-xs mt-1" data-i18n="help_enemy_boss_counter">克星：主网大炮 + ZK狙击塔</div>
                </div>
            </div>
        </div>
        
        <div class="help-section">
            <div class="help-title" data-i18n="help_title_tips">💡 游戏技巧</div>
            <div class="help-content">
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tip_economy_title">经济优先</div>
                    <div class="help-item-desc" data-i18n="help_tip_economy_desc">前期多建矿机，保证经济发展</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tip_upgrade_title">升级优于新建</div>
                    <div class="help-item-desc" data-i18n="help_tip_upgrade_desc">升级塔性价比约2倍，优先升级核心塔至Lv10</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tip_priority_title">索敌优先级</div>
                    <div class="help-item-desc" data-i18n="help_tip_priority_desc">点击塔可设置：第一/最后/特攻/最强/最弱/最近</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tip_combo_title">合理搭配</div>
                    <div class="help-item-desc" data-i18n="help_tip_combo_desc">Gas站+合约门+主力塔 = 完美组合</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_tip_counter_title">针对性防御</div>
                    <div class="help-item-desc" data-i18n="help_tip_counter_desc">垃圾交易→验证哨 | 装甲怪→ZK狙击 | 分裂怪→分片炮 | 回血怪→L2通道</div>
                </div>
            </div>
        </div>
        
        <div class="help-section">
            <div class="help-title" data-i18n="help_title_learning">📚 学习模式</div>
            <div class="help-content">
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_learn_card_title">知识卡片</div>
                    <div class="help-item-desc" data-i18n="help_learn_card_desc">每个塔解锁时会显示区块链知识介绍</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_learn_library_title">知识库</div>
                    <div class="help-item-desc" data-i18n="help_learn_library_desc">在关卡选择界面点击"知识库"复习</div>
                </div>
                <div class="help-item">
                    <div class="help-item-title" data-i18n="help_learn_story_title">剧情模式</div>
                    <div class="help-item-desc" data-i18n="help_learn_story_desc">每关都有开场和通关剧情，了解区块链故事</div>
                </div>
            </div>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <!-- Language Selector (placed here to ensure it's on top of all screens) -->
    <div id="languageSelector" style="position: fixed; top: 20px; right: 20px; z-index: 10000; display: block;">
        <div class="language-dropdown">
            <button id="currentLanguageBtn" class="globe-language-btn" onclick="toggleLanguageDropdown()" title="Language / 语言 / 言語">
                🌐
            </button>
            <div id="languageDropdown" class="language-dropdown-menu" style="display: none;">
                <div class="language-option" onclick="changeLanguage('zh-CN')">
                    <span class="language-flag">🇨🇳</span>
                    <span class="language-name">中文</span>
                </div>
                <div class="language-option" onclick="changeLanguage('en-US')">
                    <span class="language-flag">🇺🇸</span>
                    <span class="language-name">English</span>
                </div>
                <div class="language-option" onclick="changeLanguage('ja-JP')">
                    <span class="language-flag">🇯🇵</span>
                    <span class="language-name">日本語</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ==================== I18N SYSTEM ====================
        
        // 多语言文本数据库
        const i18nData = {
            'zh-CN': {
                // 游戏标题
                'game_title': '区块保卫战',
                'game_subtitle': 'Block Rush',
                'game_description': '守护你的区块！阻止恶意交易污染区块链。<br>让合法交易通过,消灭黑客与各种攻击！',
                
                // 按钮文本
                'btn_story': '📖 观看剧情 STORY',
                'btn_start': '开始游戏 START',
                'btn_pause': '⏸ 暂停 PAUSE',
                'btn_resume': '▶ 继续游戏 RESUME',
                'btn_restart': '🔁 重试本关 RETRY',
                'btn_levels': '🎮 选择关卡 LEVELS',
                'btn_back_level_select': '← 选关',
                'btn_back_main': '← 主菜单',
                'btn_reset': '🔄 重置游戏 RESET',
                'btn_endless': '∞ 无尽模式 ENDLESS',
                
                // 关卡选择
                'level_select_title': '选择关卡',
                'level_select_subtitle': 'SELECT LEVEL',
                'level_select_victory_tip': '💡 通关条件：让足够的<span style="color:#00ff88">合法交易</span>(绿)进入区块 + 消灭所有<span style="color:#ff0044">恶意数据</span>(红)',
                'btn_back': '← 返回',
                'btn_back_main': '← 返回主菜单',
                'btn_start_deploy': '🚀 开始部署',
                'btn_knowledge': '📚 游戏帮助 HELP',
                'btn_credits': '关于我们',
                'credits_title': '关于我们',
                'credits_developers': '开发团队：',
                'credits_thanks': '特别鸣谢：',
                'credits_kiro_desc': 'AI 开发助手',
                'credits_close': '关闭',
                'knowledge_title': '游戏帮助',
                'knowledge_subtitle': 'GAME GUIDE',
                
                // 游戏状态
                'status_victory': '胜利！',
                'status_defeat': '失败...',
                'status_wave_complete': '波次完成',
                'status_level_complete': '关卡完成',
                
                // 资源
                'resource_gas': 'GAS',
                'resource_hp': '生命',
                'resource_wave': '波次',
                'resource_level': '等级',
                
                // 提示
                'tip_not_enough_gas': 'GAS不足',
                'tip_max_level': '已达最高等级',
                'tip_cannot_build': '无法在此建造',
                
                // 快捷键提示
                'hotkeys_tip': '快捷键: 空格=暂停 | X=二倍速 | N=下一波 | M=音量 | ESC=菜单',
                'traffic_tip_green': '🟢 绿色 = 合法交易（放行）',
                'traffic_tip_red': '🔴 红色 = 恶意数据（消灭）',
                'help_title_quick': '快速指南',
                
                // 游戏UI
                'ui_level': '关卡',
                'ui_block_height': '区块高度',
                'ui_transactions': '交易数',
                'ui_wallet_balance': '钱包余额',
                'ui_lives': '网络完整性',
                'ui_wave': '波次',
                'ui_wave_announce': '第 {0} 波 / {1}',
                'ui_enemies': '敌人',
                'ui_remaining': '剩余',
                'ui_menu_esc': '菜单 ESC',
                'ui_volume': '音量',
                'ui_volume_control': '音量控制',
                'ui_bgm': '🎵 背景音乐',
                'ui_sfx': '🔊 音效',
                
                // 测试按钮
                'btn_test_mode': '🔗 连接钱包',
                
                // 游戏界面
                'pause_title': '游戏暂停',
                'pause_subtitle': 'PAUSED',
                'pause_description': '按 ESC 或点击按钮继续游戏',
                'space_pause_title': '⏸ 暂停中',
                'space_pause_hint': '按空格键或点击暂停按钮继续',
                'pause_current_level': '当前关卡',
                'pause_balance': '余额',
                'defeat_title': '区块被污染！',
                'defeat_description': '恶意交易入侵了区块，共识失败...',
                'endless_mode_name': '无尽模式',
                'endless_unlock_title': '🌟 无尽模式已解锁！',
                'endless_unlock_desc': '挑战你的极限，看看你能守护多少波攻击！',
                'enemy_modal_btn': '我知道了 继续游戏',
                'enemy_new_appear': '⚠ 新敌人出现！',
                'enemy_tip_label': '💡 攻略提示：',
                'endless_desc': '随机地图 | 无限挑战',
                'endless_challenge': '🌟 终极考验',
                'unlock_status_template': '🔒 通关第{0}关解锁',
                'knowledge_locked': '🔒 未解锁',
                'knowledge_available': '点击查看详情',
                
                // 关卡名称
                'level_1_name': '交易验证',
                'level_2_name': '网络扩容',
                'level_3_name': '隐私与证明',
                'level_4_name': '闪电网络',
                'level_5_name': '51%攻击',
                
                // 关卡描述
                'level_1_desc': '直线地图 | 基础敌人',
                'level_2_desc': 'U型弯 | 分裂怪',
                'level_3_desc': 'S型弯 | 减伤怪',
                'level_4_desc': '长直线 | 回血怪',
                'level_5_desc': '双入口 | BOSS战',
                
                // 关卡解锁塔
                'level_1_unlock': '🔐 公钥验证哨',
                'level_2_unlock': '💥 分片加农炮',
                'level_3_unlock': '🎯 ZK狙击塔',
                'level_4_unlock': '⚡ L2通道',
                'level_5_unlock': '☄️ 主网大炮',
                'level_unlock_status_2': '🔒 通关第1关解锁',
                'level_unlock_status_3': '🔒 通关第2关解锁',
                'level_unlock_status_4': '🔒 通关第3关解锁',
                'level_unlock_status_5': '🔒 通关第4关解锁',
                'level_unlock_status_endless': '🔒 通关第5关解锁',
                
                // 难度
                'difficulty_title': '选择难度 DIFFICULTY',
                'difficulty_easy': '🛡 简单 (HP 70%)',
                'difficulty_normal': '⭐ 标准 (HP 100%)',
                'difficulty_hard': '💀 困难 (HP 140%)',
                'difficulty_easy_short': '简单',
                'difficulty_normal_short': '标准',
                'difficulty_hard_short': '困难',
                
                // 关卡状态
                'level_status_start': '▶ 开始',
                'level_status_replay': '🔁 重新游玩',
                'level_status_challenge': '♾️ 挑战',
                
                // 科技解锁按钮
                'btn_start_challenge': '开始挑战！',
                'btn_next_tower': '下一个',
                
                // 游戏内提示
                'click_to_start': '点击开始',
                'click_spawn_icon': '点击路径入口的红色图标开始波次',
                
                // 关卡内按钮
                'btn_pause': '暂停',
                'btn_continue': '继续',
                'btn_next_wave': '下一波',
                'btn_help': '📖 帮助',
                'btn_close': '✕ 关闭',
                'enemy_modal_btn': '我知道了 继续游戏',
                'enemy_info_title': '⚠ 敌人信息',
                'enemy_info_hp': 'HP',
                'enemy_info_speed': '速度',
                'enemy_info_reward': '奖励',
                'hotkey_space': '空格键',
                'hotkey_n': '快捷键: N',
                
                // Tooltip文本
                'tooltip_locked': '关卡 {0} 解锁',
                'tooltip_build': '建造',
                'tooltip_sell': '出售',
                'tooltip_income': '收入',
                'tooltip_range': '范围',
                'tooltip_damage': '伤害',
                'tooltip_attack_speed': '攻速',
                'tooltip_slow': '减速',
                'tooltip_slow_range': '减速范围',
                'tooltip_slow_effect': '减速效果',
                'tooltip_truesight_range': '真视范围',
                'tooltip_full_map': '全图',
                'tooltip_none': '无',
                'tooltip_cannot_upgrade': '无法升级',
                'tooltip_can_upgrade': '可升级至Lv10',
                'tooltip_recycle': '回收',
                'tooltip_counter_spam': '⚡ 特攻：垃圾交易 (1.2x-2.5x，随等级提升)',
                'tooltip_counter_armored': '💥 特攻：装甲怪 (1.5x-2.8x) | BOSS (1.1x-2.0x)',
                'tooltip_counter_splitter': '💎 特攻：分裂怪 (1.2x-2.5x，随等级提升)',
                'tooltip_counter_healer': '⚡ 特攻：回血怪 (1.2x-2.5x + 压制40%-85%)',
                'tooltip_counter_boss': '💥 对BOSS：造成30%当前HP伤害！',
                'tooltip_aura_gas': '⚡ 光环：范围内友军攻速+15%-50%',
                'tooltip_truesight': '👁️ 真视：显形隐身敌人 + 减速35%-50%',
                
                // 塔管理面板
                'panel_level': '等级',
                'panel_upgrade_to': '升级到',
                'panel_upgrade': '⬆ 升级',
                'panel_sell': '💰 出售',
                'panel_cancel': '取消',
                'panel_sell_ratio': '出售返还 {0}%',
                'panel_miner_privilege': '(矿机特权)',
                'panel_before_wave1': '(第一波前)',
                'panel_target_priority': '索敌优先级',
                'panel_priority_first': '第一',
                'panel_priority_last': '最后',
                'panel_priority_counter': '特攻',
                'panel_priority_strongest': '最强',
                'panel_priority_weakest': '最弱',
                'panel_priority_nearest': '最近',
                
                // 敌人信息面板
                'enemy_info_title': '⚠ ENEMY INFO',
                'enemy_info_hp': '生命值',
                'enemy_info_speed': '速度',
                'enemy_info_reward': '奖励',
                
                // 浮动文字
                'float_life': '生命',
                'float_verified': '✓ VERIFIED',
                'float_unverified': '未验证!',
                'float_detected': '⚠ DETECTED!',
                'float_suppress': '⚡ SUPPRESS!',
                'float_miss': 'MISS',
                'float_purge': '⚡ PURGE!',
                'float_pierce': '💥 PIERCE!',
                'float_critical': '🎯 CRITICAL!',
                'float_shatter': '💎 SHATTER!',
                'float_blocked': '🛡️ BLOCKED',
                'float_mainnet_strike': '💥 MAINNET STRIKE!',
                'float_not_enough_gas': 'NOT ENOUGH GAS!',
                'float_cannon_limit': '主网大炮限制：1个/关卡',
                'float_miner_limit': '矿机限制：最多5个',
                'float_cannot_sell_cannon': '主网大炮无法出售！',
                'float_max_level': '已满级！',
                'float_max_lives_up': '生命值上限提升！',
                
                // 速度按钮
                'speed_normal': '正常速度',
                'speed_double': '二倍速',
                'float_not_enough_gas_upgrade': 'GAS不足！',
                'float_target_priority': '索敌: {0}',
                
                // 防御塔名称
                'tower_validator_lv1': '验证节点',
                'tower_validator_lv2': '共识节点',
                'tower_validator_lv3': '主验证者',
                'tower_miner_lv1': '矿机',
                'tower_miner_lv2': '矿池',
                'tower_miner_lv3': '超级矿场',
                'tower_gasStation_lv1': 'Gas优化器',
                'tower_gasStation_lv2': 'Gas加速站',
                'tower_gasStation_lv3': 'Gas超频器',
                'tower_contract_lv1': '智能合约门',
                'tower_contract_lv2': '合约防火墙',
                'tower_contract_lv3': '合约堡垒',
                'tower_sharding_lv1': '分片处理器',
                'tower_sharding_lv2': '分片加农炮',
                'tower_sharding_lv3': '分片歼灭者',
                'tower_zkSniper_lv1': 'ZK狙击塔',
                'tower_zkSniper_lv2': 'ZK穿透炮',
                'tower_zkSniper_lv3': 'ZK歼灭者',
                'tower_l2Channel_lv1': 'L2通道',
                'tower_l2Channel_lv2': 'L2激光炮',
                'tower_l2Channel_lv3': 'L2歼灭光束',
                'tower_mainnetCannon': '主网大炮',
                
                // 防御塔描述
                'tower_desc_validator': '单体高伤，前期主力。可升级4次',
                'tower_knowledge_validator': '非对称加密、签名验证',
                'tower_desc_miner': '被动收入建筑。升级提升收益',
                'tower_knowledge_miner': 'PoW工作量证明 - 挖矿产生收益',
                'tower_desc_gasStation': '群体减速控制。升级提升减速效果',
                'tower_knowledge_gasStation': 'Gas Fee激励机制',
                'tower_desc_contract': '范围减速+真视。升级扩大范围',
                'tower_knowledge_contract': '代码逻辑判断 (If-Else)',
                'tower_desc_sharding': '范围AOE伤害。对分裂怪有特效',
                'tower_knowledge_sharding': '分片技术 (Sharding) - 并行处理',
                'tower_desc_zkSniper': '超远狙击，无视护盾。对装甲怪和BOSS有特效',
                'tower_knowledge_zkSniper': '零知识证明 (ZKP) - 精准验证',
                'tower_desc_l2Channel': '持续激光输出。对回血怪有特效',
                'tower_knowledge_l2Channel': 'Layer 2 状态通道 - 高速处理',
                'tower_desc_mainnetCannon': '终极武器，全图AOE。每关限1个',
                'tower_knowledge_mainnetCannon': '主网最终确认 - 不可逆转',
                
                // 知识卡片 - 通用
                'knowledge_unlocked': '🔓 新科技解锁！',
                'btn_start_challenge': '开始挑战！',
                
                // 知识卡片 - 防御塔
                'knowledge_validator_title': '非对称加密',
                'knowledge_validator_principle': '每个账户有两把钥匙：私钥（只有你知道，用来签名）和公钥（公开的，用来验证签名）。',
                'knowledge_validator_analogy': '就像你的签名：只有你能签，但所有人都能验证是不是你签的。',
                'knowledge_validator_application': '比特币地址、以太坊钱包、数字签名认证',
                'knowledge_validator_gameplay': '验证哨检查每笔交易的签名，确保交易真的来自账户主人。',
                
                'knowledge_miner_title': '工作量证明 (PoW)',
                'knowledge_miner_principle': '矿工通过大量计算来竞争记账权，谁先算出答案谁就能打包区块并获得奖励。',
                'knowledge_miner_analogy': '就像数学竞赛：谁先解出难题，谁就能获得奖金。',
                'knowledge_miner_application': '比特币挖矿、以太坊1.0（已转PoS）',
                'knowledge_miner_gameplay': '矿池每3秒产生GAS收入，是你的经济来源。',
                
                'knowledge_gasStation_title': 'Gas费机制',
                'knowledge_gasStation_principle': '用户支付Gas费来激励矿工优先处理自己的交易。Gas费越高，交易越快被打包。',
                'knowledge_gasStation_analogy': '就像快递加急费：付更多钱，你的包裹就能更快送达。',
                'knowledge_gasStation_application': '以太坊交易费、智能合约执行成本',
                'knowledge_gasStation_gameplay': 'Gas优化器提升周围防御塔的攻击速度，让它们更快处理交易。',
                
                'knowledge_contract_title': '智能合约',
                'knowledge_contract_principle': '自动执行的代码，部署在区块链上。满足条件就自动运行，不需要人工干预。',
                'knowledge_contract_analogy': '就像自动售货机：投币→选择→自动出货，全程无需人工。',
                'knowledge_contract_application': 'DeFi协议、NFT交易、DAO治理',
                'knowledge_contract_gameplay': '智能合约塔自动检测范围内的敌人并减速，还能揭露隐身单位。',
                
                'knowledge_sharding_title': '分片技术',
                'knowledge_sharding_principle': '将区块链网络分成多个分片，每个分片并行处理不同的交易，大幅提升吞吐量。',
                'knowledge_sharding_analogy': '就像超市开设多个收银台，而不是让所有人排一个队。',
                'knowledge_sharding_application': '以太坊2.0分片、Zilliqa、Near Protocol',
                'knowledge_sharding_gameplay': '分片炮发射范围攻击，一次处理多个目标，体现并行处理的威力。',
                
                'knowledge_zkSniper_title': '零知识证明 (ZKP)',
                'knowledge_zkSniper_principle': '证明某个陈述为真，而不需要透露任何额外信息。',
                'knowledge_zkSniper_analogy': '就像你能证明自己成年，而不需要告诉别人你的具体年龄。',
                'knowledge_zkSniper_application': 'zkSNARK、zkSTARK、隐私币Zcash',
                'knowledge_zkSniper_gameplay': 'ZK狙击塔能"看穿"隐身和混淆，对隐藏单位造成额外伤害。',
                
                'knowledge_l2Channel_title': 'Layer 2扩容',
                'knowledge_l2Channel_principle': '在主链之外处理大量交易，只把最终结果提交到主链，降低成本和延迟。',
                'knowledge_l2Channel_analogy': '就像你和朋友之间的借还钱，不需要每次都找银行记账，最后算总账就行。',
                'knowledge_l2Channel_application': 'Lightning Network、Polygon、Arbitrum、Optimism',
                'knowledge_l2Channel_gameplay': 'L2通道持续发射激光，高频低成本的持续伤害。',
                
                'knowledge_mainnetCannon_title': '硬分叉',
                'knowledge_mainnetCannon_principle': '区块链协议的重大更改，不兼容旧版本。相当于"重启"网络，是最后的手段。',
                'knowledge_mainnetCannon_analogy': '就像给操作系统做重大升级，旧版本的软件可能无法运行。',
                'knowledge_mainnetCannon_application': '比特币现金分叉、以太坊DAO事件后的分叉',
                'knowledge_mainnetCannon_gameplay': '主网大炮是终极武器，对BOSS造成当前生命值30%的巨额伤害，但需要手动点击发射。',
                
                // 知识卡片 - 敌人
                'knowledge_spam_title': '垃圾交易攻击',
                'knowledge_spam_principle': '攻击者发送大量无意义的交易，堵塞网络，让正常交易无法被处理。',
                'knowledge_spam_analogy': '就像有人不断拨打骚扰电话，占用客服热线，让真正需要帮助的人打不进来。',
                'knowledge_spam_application': '2017年以太坊CryptoKitties拥堵事件',
                'knowledge_spam_gameplay': '基础敌人，数量多但血量低，容易清理。',
                
                'knowledge_doublespend_title': '双花攻击',
                'knowledge_doublespend_principle': '攻击者试图将同一笔钱花两次，通过控制算力或利用网络延迟。',
                'knowledge_doublespend_analogy': '就像用同一张假钞在两家店同时买东西。',
                'knowledge_doublespend_application': '51%攻击、Race Attack、Finney Attack',
                'knowledge_doublespend_gameplay': '会隐身，需要智能合约的真视能力或ZK狙击塔来揭露。',
                
                'knowledge_splitter_title': '粉尘攻击',
                'knowledge_splitter_principle': '攻击者发送大量微小金额的交易，让受害者的钱包充满"粉尘"，难以管理且暴露隐私。',
                'knowledge_splitter_analogy': '就像有人往你家门口倒一堆垃圾，让你无法正常出入。',
                'knowledge_splitter_application': '比特币粉尘攻击、地址追踪',
                'knowledge_splitter_gameplay': '死后分裂成3个快速移动的小单位，需要范围攻击清理。',
                
                'knowledge_armored_title': '混币服务',
                'knowledge_armored_principle': '通过混淆交易来源和去向，让资金流向难以追踪。',
                'knowledge_armored_analogy': '就像把你的钱和很多人的钱混在一起洗牌，然后再发回来，别人就不知道哪笔是你的了。',
                'knowledge_armored_application': 'Tornado Cash、CoinJoin、混币器',
                'knowledge_armored_gameplay': '拥有50%伤害减免，需要高伤害或ZK狙击塔的穿透攻击。',
                
                'knowledge_vampire_title': '高频交易攻击',
                'knowledge_vampire_principle': '利用极快的交易速度抢先执行，从价格波动中获利（抢跑、夹击）。',
                'knowledge_vampire_analogy': '就像有人能提前0.1秒知道股票价格，总能抢在你前面买卖。',
                'knowledge_vampire_application': 'MEV（最大可提取价值）、三明治攻击',
                'knowledge_vampire_gameplay': '持续回血，需要L2通道的持续伤害来压制回血能力。',
                
                'knowledge_boss_title': '51%攻击',
                'knowledge_boss_principle': '攻击者控制超过50%的网络算力，可以篡改交易记录、进行双花攻击。',
                'knowledge_boss_analogy': '就像有人控制了超过半数的投票权，可以随意修改投票结果。',
                'knowledge_boss_application': '小型区块链的51%攻击案例（ETC、BTG等）',
                'knowledge_boss_gameplay': '终极BOSS，超高血量和减伤，需要所有高级塔配合，主网大炮是击杀关键。',
                
                // 知识卡片 - 标签
                'knowledge_label_principle': '原理',
                'knowledge_label_analogy': '类比',
                'knowledge_label_application': '应用',
                'knowledge_label_gameplay': '游戏机制',
                'knowledge_label_principle_icon': '💡 核心：',
                'knowledge_label_gameplay_icon': '🎮 效果：',
                'knowledge_ai_label': '链灵 AI',
                
                // 帮助屏幕
                'help_screen_title': '区块知识库',
                'help_screen_subtitle': 'BLOCKCHAIN KNOWLEDGE',
                'tab_guide': '📖 操作指南',
                'tab_encyclopedia': '📚 区块链百科',
                
                // 帮助面板内容 - 游戏目标
                'help_goal_content_1': '守护你的<span style="color:#00ffff">区块（Block）</span>！',
                'help_goal_content_2': '• <span style="color:#00ff88">绿色方块</span> = 合法交易 → <b>放行</b>',
                'help_goal_content_3': '• <span style="color:#ff0044">红色敌人</span> = 恶意数据 → <b>消灭</b>',
                'help_goal_content_4': '• 点击路径入口的<span style="color:#ff0044">红色图标</span>开始波次',
                
                // 帮助面板 - 快捷键
                'help_hotkey_x_title': 'X - 二倍速',
                'help_hotkey_x_desc': '切换游戏速度（1倍 ↔ 2倍）',
                'help_hotkey_n_title': 'N - 下一波',
                'help_hotkey_n_desc': '跳过准备时间，立即开始下一波',
                'help_hotkey_esc_title': 'ESC / P - 暂停',
                'help_hotkey_esc_desc': '打开暂停菜单',
                'help_hotkey_space_title': '空格 - 快速暂停',
                'help_hotkey_space_desc': '长按暂停，松开继续',
                'help_hotkey_w_title': 'W - 快捷升级',
                'help_hotkey_w_desc': '升级当前选中的防御塔',
                'help_hotkey_q_title': 'Q - 快捷出售',
                'help_hotkey_q_desc': '出售当前选中的防御塔',
                'help_hotkey_r_title': 'R - 主网轰炸',
                'help_hotkey_r_desc': '激活主网大炮瞄准模式（需要建造主网大炮）',
                'help_hotkey_1to8_title': '1-8 - 选择防御塔',
                'help_hotkey_1to8_desc': '快速选择对应编号的防御塔进行建造',
                
                // 帮助面板 - 操作说明
                'help_control_place_title': '放置防御塔',
                'help_control_place_desc': '点击底部塔图标 → 点击地图空地放置',
                'help_control_upgrade_title': '升级防御塔',
                'help_control_upgrade_desc': '点击已放置的塔 → 点击升级按钮（最高Lv10）',
                'help_control_sell_title': '出售防御塔',
                'help_control_sell_desc': '点击已放置的塔 → 点击出售按钮（返还70%）',
                'help_control_enemy_title': '查看敌人信息',
                'help_control_enemy_desc': '点击敌人查看详细属性和特性',
                
                // 帮助面板 - 防御塔详情
                'help_tower_validator_title': '🔐 验证哨 - 非对称加密',
                'help_tower_validator_desc': '单体高伤，前期主力。可升级至Lv10',
                'help_tower_validator_stats': '成本25 | 射程110 | 伤害12 | 攻速1.0s',
                'help_tower_validator_special': '⚡ 特攻垃圾交易 (1.2x-2.5x)',
                'help_tower_miner_title': '⛏️ 矿机 - 工作量证明',
                'help_tower_miner_desc': '被动收入建筑，可升级至Lv10',
                'help_tower_miner_stats': '成本50 | 收入2 GAS/3s | 出售回收90%',
                'help_tower_gas_title': '⛽ Gas站 - Gas费机制',
                'help_tower_gas_desc': '范围加速友军，可升级至Lv10',
                'help_tower_gas_stats': '成本45 | 范围100 | 加速25%-70%',
                'help_tower_contract_title': '📜 合约门 - 智能合约',
                'help_tower_contract_desc': '范围减速+真视，可升级至Lv10',
                'help_tower_contract_stats': '成本65 | 范围140 | 减速35%-80%',
                'help_tower_sharding_title': '💥 分片炮 - 分片技术 [Lv2解锁]',
                'help_tower_sharding_desc': 'AOE范围伤害，可升级至Lv10',
                'help_tower_sharding_stats': '成本75 | 射程150 | AOE伤害30',
                'help_tower_sharding_special': '💎 特攻分裂怪 (1.2x-2.5x)',
                'help_tower_zk_title': '🎯 ZK狙击 - 零知识证明 [Lv3解锁]',
                'help_tower_zk_desc': '超远射程，可升级至Lv10',
                'help_tower_zk_stats': '成本90 | 射程260 | 伤害50',
                'help_tower_zk_special': '💥 特攻装甲怪/BOSS (1.5x-2.8x / 1.1x-2.0x)',
                'help_tower_l2_title': '⚡ L2通道 - Layer2扩容 [Lv4解锁]',
                'help_tower_l2_desc': '持续激光，可升级至Lv10',
                'help_tower_l2_stats': '成本100 | 射程180 | 伤害20/s',
                'help_tower_l2_special': '⚡ 特攻回血怪 (1.2x-2.5x + 压制40%-85%)',
                'help_tower_cannon_title': '☄️ 主网大炮 - 硬分叉 [Lv5解锁]',
                'help_tower_cannon_desc': '手动轰炸，对BOSS特效',
                'help_tower_cannon_stats': '成本80 | 使用150 GAS | AOE伤害200',
                'help_tower_cannon_special': '💥 对BOSS造成30%当前HP伤害！',
                
                // 帮助面板 - 敌人类型
                'help_enemy_valid_title': '■ 合法交易',
                'help_enemy_valid_desc': '让它进入区块！验证后奖励+5 GAS',
                
                // 怪物介绍卡片
                'enemy_normal_name': '合法交易',
                'enemy_spam_name': '垃圾交易虫',
                'enemy_doubleSpend_name': '双花幽灵',
                'enemy_splitter_name': '粉尘分裂体',
                'enemy_shielded_name': '混币装甲兽',
                'enemy_healer_name': '高频吸血蝠',
                'enemy_boss_name': '51%算力泰坦',
                'enemy_splitChild_name': '碎片',
                'enemy_normal_desc': '绿色数据包 - 这是正常的交易，需要被打包进区块！',
                'enemy_normal_tip': '不要攻击它们，让它们安全到达区块。',
                'enemy_spam_desc': '垃圾数据病毒 - 试图堵塞网络的无效交易！',
                'enemy_spam_tip': '用验证节点快速清理！',
                'enemy_doublespend_desc': '隐形的双花攻击 - 试图把同一笔钱花两次！',
                'enemy_doublespend_tip': '需要智能合约门来揭露它的真身！',
                'enemy_splitter_desc': '粉尘攻击载体 - 死后会分裂成3个快速移动的小碎片！',
                'enemy_splitter_tip': '分片加农炮对分裂怪造成额外伤害，AOE范围可以一次清理碎片！',
                'enemy_shielded_desc': '混币器护盾 - 拥有50%伤害减免！普通攻击只能造成一半伤害！',
                'enemy_shielded_tip': 'ZK狙击塔可以穿透护盾，造成额外伤害！',
                'enemy_healer_desc': '高频交易体 - 每秒恢复8点生命！必须快速击杀或压制回血！',
                'enemy_healer_tip': 'Layer 2通道的持续激光能压制它的回血，并造成额外伤害！',
                'enemy_boss_desc': '51%攻击巨兽 - 拥有超过半数的算力！10000点血量，55%减伤，每秒回血3点！',
                'enemy_boss_tip': '必须使用高级塔组合！ZK狙击塔对BOSS造成额外伤害！主网大炮对BOSS造成30%当前HP伤害，是击杀关键！',
                'enemy_doubleSpend_desc': '隐形的双花攻击 - 试图把同一笔钱花两次！',
                'enemy_doubleSpend_tip': '需要智能合约门来揭露它的真身！',
                'help_enemy_spam_title': '🦠 垃圾交易虫',
                'help_enemy_spam_desc': '快速但脆弱，奖励3 GAS',
                'help_enemy_double_title': '👻 双花幽灵 [隐身]',
                'help_enemy_double_desc': '隐身单位，需要真视才能攻击',
                'help_enemy_splitter_title': '💎 粉尘分裂体 [分裂]',
                'help_enemy_splitter_desc': '死后分裂成3个小怪',
                'help_enemy_shielded_title': '🛡️ 混币装甲兽 [减伤]',
                'help_enemy_shielded_desc': '200 HP + 50%减伤护盾',
                'help_enemy_shielded_counter': '克星：ZK狙击塔',
                'help_enemy_healer_title': '💚 高频吸血蝠 [回血]',
                'help_enemy_healer_desc': '150 HP + 每秒恢复8 HP',
                'help_enemy_healer_counter': '克星：Layer 2通道',
                'help_enemy_boss_title': '☠️ 51%算力泰坦 [BOSS]',
                'help_enemy_boss_desc': '10000 HP + 55%减伤 + 回血3/s',
                'help_enemy_boss_counter': '克星：主网大炮 + ZK狙击塔',
                
                // 帮助面板 - 游戏技巧
                'help_tip_economy_title': '经济优先',
                'help_tip_economy_desc': '前期多建矿机，保证经济发展',
                'help_tip_upgrade_title': '升级优于新建',
                'help_tip_upgrade_desc': '升级塔性价比约2倍，优先升级核心塔至Lv10',
                'help_tip_priority_title': '索敌优先级',
                'help_tip_priority_desc': '点击塔可设置：第一/最后/特攻/最强/最弱/最近',
                'help_tip_combo_title': '合理搭配',
                'help_tip_combo_desc': 'Gas站+合约门+主力塔 = 完美组合',
                'help_tip_counter_title': '针对性防御',
                'help_tip_counter_desc': '垃圾交易→验证哨 | 装甲怪→ZK狙击 | 分裂怪→分片炮 | 回血怪→L2通道',
                
                // 帮助面板 - 学习模式
                'help_learn_card_title': '知识卡片',
                'help_learn_card_desc': '每个塔解锁时会显示区块链知识介绍',
                'help_learn_story_title': '剧情模式',
                'help_learn_story_desc': '每关都有开场和通关剧情，了解区块链故事',
                
                // 剧情按钮
                'story_btn_start': '开始守护！',
                'story_btn_deploy': '开始部署',
                'story_btn_continue': '继续前进',
                'story_btn_final': '最终决战',
                'story_btn_complete': '完成使命',
                
                // 胜利界面
                'victory_title': '使命完成！',
                'victory_subtitle': 'MISSION ACCOMPLISHED',
                'victory_ending_title': '📜 结局：区块链守护者',
                'victory_story_1': '2045年，在你的守护下，区块链网络经受住了最严峻的考验。从简单的交易验证，到抵御51%攻击，你掌握了所有的防御技术。',
                'victory_tech_1': '非对称加密保护了用户的身份',
                'victory_tech_2': '分片技术实现了网络扩容',
                'victory_tech_3': '零知识证明保障了隐私',
                'victory_tech_4': 'Layer 2 提升了交易速度',
                'victory_tech_5': '去中心化共识抵御了攻击',
                'victory_quote': '"但这不是结束...只要区块链存在，威胁就永远存在。<br>而你，将继续守护这个去中心化的世界。"',
                'victory_thanks': '感谢游玩 BlockRush！',
                'victory_tagline': '在游戏中学习区块链技术 🚀',
                
                // 塔管理面板
                'panel_level': '等级',
                'panel_stat_cost': '成本',
                'panel_stat_damage': '伤害',
                'panel_stat_range': '射程',
                'panel_stat_speed': '攻速',
                'panel_stat_income': '收入',
                'panel_stat_boost': '加速',
                'panel_stat_slow_range': '减速范围',
                'panel_stat_slow_effect': '减速效果',
                'panel_stat_truesight': '真视范围',
                'panel_stat_sell_refund': '出售回收',
                'panel_stat_uses': '使用',
                'panel_stat_aoe_damage': 'AOE伤害',
                'panel_stat_slow': '减速',
                'panel_upgrade_preview': '升级后:',
                'panel_target_priority': '🎯 索敌优先级',
                'panel_priority_first': '第一',
                'panel_priority_last': '最后',
                'panel_priority_counter': '特攻',
                'panel_priority_strongest': '最强',
                'panel_priority_weakest': '最弱',
                'panel_priority_nearest': '最近',
                'panel_upgrade_to': '升级到',
                'panel_upgrade': '⬆ 升级 (W)',
                'panel_max_level': '⭐ 已满级！',
                'panel_current_level': '当前等级',
                'panel_max_level_btn': '⭐ 已满级',
                'panel_sell_ratio': '出售返还 {0}%',
                'panel_sell': '💰 出售 (Q)',
                'panel_cancel': '取消',
                
                // 游戏界面UI
                'ui_speed_2x': '二倍速',
                'ui_hotkey_x': '快捷键: X',
                'ui_tower_menu': '收起',
                'ui_tower_validator': '验证哨',
                'ui_tower_miner': '矿机炮',
                'ui_tower_gas': '加油站',
                'ui_tower_contract': '合约门',
                'ui_tower_sharding': '分片炮',
                'ui_tower_zk': 'ZK狙击',
                'ui_tower_l2': 'L2通道',
                'ui_tower_cannon': '主网炮',
                
                // 帮助面板标题
                'help_title_goal': '游戏目标',
                'help_title_hotkeys': '快捷键',
                'help_title_controls': '操作说明',
                'help_hotkey_x_title': '二倍速',
                'help_hotkey_n_title': '下一波',
                'help_hotkey_esc_title': '暂停',
                'help_hotkey_space_title': '快速暂停',
                'help_goal_content_2': '合法交易 → 放行',
                'help_goal_content_3': '恶意数据 → 消灭',
                'help_title_towers': '🗼 防御塔一览',
                'help_title_enemies': '👾 敌人类型',
                'help_title_tips': '💡 游戏技巧',
                'help_title_learning': '📚 学习模式',
                
                // 帮助面板 - 学习模式
                'help_learn_library_title': '知识库',
                'help_learn_library_desc': '在关卡选择界面点击"知识库"复习',
                
                // 开场故事
                'opening_title': '数字世界的守护者',
                'opening_subtitle': '任务简报 / MISSION BRIEFING',
                'opening_content': '<span style="color:#00ffff">2045年</span>，人类社会已完全数字化。<br>每一笔交易都需要通过<span style="color:#00ffff">区块链</span>这个<span style="color:#00ffff">去中心化</span>的账本来验证和记录。<br><br>但是，<span style="color:#ff0044">黑客、诈骗者、恶意程序</span>从未停止攻击...<br><br>你是一名<span style="color:#00ff88">区块链安全工程师</span>。<br>你的任务是：守护<span style="color:#00ffff">区块链</span>网络，确保每个区块都只包含合法、安全的交易。',
                'opening_mechanics_title': '▼ 核心机制 / CORE MECHANICS ▼',
                'opening_mechanics_allow': '合法交易 → 放行',
                'opening_mechanics_destroy': '恶意攻击 → 消灭',
                'mechanics_legitimate_data': '合法数据',
                'mechanics_malicious_attack': '恶意攻击',
                'mechanics_pass': '>> PASS',
                'mechanics_kill': '>> KILL',
                
                // 链灵对话 - 第1关
                'dialogue_level1_intro_1': '这是最基础的防御！垃圾交易虫正在攻击网络。',
                'dialogue_level1_intro_2': '建造验证节点来清理它们，但要放行绿色的合法交易！',
                'dialogue_level1_victory_1': '太棒了！你成功保护了第一批交易！',
                'dialogue_level1_victory_2': '但这只是开始...更强的敌人即将到来。',
                
                // 链灵对话 - 第2关
                'dialogue_level2_intro_1': '糟糕！粉尘分裂体出现了！',
                'dialogue_level2_intro_2': '它们死后会分裂成3个小怪...我们需要分片处理器！',
                'dialogue_level2_victory_1': '分片技术果然有效！你掌握得很快！',
                
                // 链灵对话 - 第3关
                'dialogue_level3_intro_1': '小心！双花幽灵会隐身！',
                'dialogue_level3_intro_2': '使用智能合约的真视功能，或者零知识证明器的穿透攻击！',
                'dialogue_level3_victory_1': '零知识证明的力量...即使看不见，也能验证真相！',
                
                // 链灵对话 - 第4关
                'dialogue_level4_intro_1': '吸血鬼机器人！它们会不断回血！',
                'dialogue_level4_intro_2': '用Layer 2通道的持续伤害压制它们的恢复能力！',
                'dialogue_level4_victory_1': 'Layer 2的速度...这就是未来！',
                
                // 链灵对话 - 第5关
                'dialogue_level5_intro_1': '警报！51%攻击BOSS来了！',
                'dialogue_level5_intro_2': '这是最终考验...使用所有防御技术，必要时启动主网大炮！',
                'dialogue_level5_victory_1': '你做到了！区块链安全了！',
                'dialogue_level5_victory_2': '你是真正的区块链守护者！',
                
                // 对话界面
                'character_chain_spirit': '链灵',
                'dialogue_continue': '点击继续 ▼',
                
                // 关卡介绍 - 第1关
                'level1_opening_title': '第一道防线',
                'level1_opening_subtitle': '关卡 1：交易验证',
                'level1_opening_content': '<div style="text-align: left;"><strong>【当前位置】</strong><br><span style="color: #00ffff;">交易池 (Mempool)</span><br><br><strong>【任务简报】</strong><br>所有交易上链前都在此排队。你是<span style="color: #00ffff;">第一道防线</span>，必须防止<span style="color: #ff6b6b;">垃圾交易</span>堵塞网络。<br><br><strong>【执行指令】</strong><br>部署设施：<span style="color: #00ffff;">公钥验证哨</span><br>核心机制：<span style="color: #ffd700;">检查数字签名</span>（如同核对银行身份证）<br><br><strong>【警惕目标】</strong><br><span style="color: #ff6b6b;">垃圾交易 / 恶意攻击</span></div>',
                'level1_victory_title': '第一关完成',
                'level1_victory_subtitle': '防线稳固',
                'level1_victory_content': '干得好！你成功验证了第一批交易。\n\n但这只是开始...\n随着区块链越来越受欢迎，交易量暴增，\n单纯的验证已经不够了。\n\n我们需要更强大的技术...',
                
                // 关卡介绍 - 第2关
                'level2_opening_title': '扩容危机',
                'level2_opening_subtitle': '关卡 2：网络扩容',
                'level2_opening_content': '<div style="text-align: left;"><strong>⚠️ 警报：网络极度拥堵！</strong><br><br>交易量激增 <span style="color:#ff0044">100 倍</span>，单链处理已崩溃。<br><br>必须激活 <span style="color:#00ffff">[分片技术 Sharding]</span> —— 将网络划分为多个平行区域，同时处理海量数据。<br><br><strong>当前威胁：粉尘攻击 (Dust Attack)</strong><br>敌人分裂成了无数微小单位，试图用"人海战术"瘫痪节点。<br><br><strong>战术指令：</strong><br>常规武器效率太低，请部署 <span style="color:#00ffff">[分片炮]</span>，利用 <span style="color:#ffd700">范围攻击 (AOE)</span> 批量清除它们！</div>',
                'level2_victory_title': '第二关完成',
                'level2_victory_subtitle': '网络畅通',
                'level2_victory_content': '网络恢复正常！交易速度提升了10倍！\n\n但新的威胁出现了...\n有人在使用"混币器"隐藏交易来源。\n\n我们需要更高级的技术来应对...',
                
                // 关卡介绍 - 第3关
                'level3_opening_title': '隐私之战',
                'level3_opening_subtitle': '关卡 3：隐私与证明',
                'level3_opening_content': '<div style="text-align: left;">⚠️ 警报：检测到"<span style="color: #ff6b6b;">双花攻击</span>" (Double-Spend)！<br><br>狡猾的敌人试图将同一笔钱使用两次，并利用加密迷雾处于 <span style="color: #ff6b6b;">[隐身状态]</span>，常规防御塔无法锁定目标。<br><br><span style="color: #00ffff;">技术解锁：零知识证明 (ZK-SNARKs)</span><br>"无需知晓具体内容，也能验证真相。"<br><br><span style="color: #ffd700;">战术指令：</span><br>立即部署 <span style="color: #00ffff;">[ZK狙击塔]</span>！它拥有 <span style="color: #ffd700;">真视 (True Sight)</span> 能力，能直接识破所有隐身单位的伪装，并造成 <span style="color: #ffd700;">致命暴击</span>！</div>',
                'level3_victory_title': '第三关完成',
                'level3_victory_subtitle': '真相大白',
                'level3_victory_content': '你找到了隐私和安全的平衡点！\n\n但区块链还有一个致命弱点：\n主链处理速度太慢，手续费太贵...\n\n是时候引入Layer 2了！',
                
                // 关卡介绍 - 第4关
                'level4_opening_title': '速度革命',
                'level4_opening_subtitle': '关卡 4：闪电网络',
                'level4_opening_content': '<div style="text-align: left;">⚠️ 主网拥堵警报：<span style="color: #ff6b6b;">Gas 费已突破天际！</span><br><br>链上确认太慢，单笔手续费高达几十美元，常规防线已瘫痪。<br><br><span style="color: #ff6b6b;">遭遇强敌：吸血鬼机器人 (Vampire Bot)</span><br>它们拥有 <span style="color: #ff6b6b;">[持续回血]</span> 机制，普通防御塔的伤害还没有它们回血快！<br><br><span style="color: #00ffff;">技术升级：闪电网络 (Lightning Network)</span><br>建立链下 Layer 2 通道，实现毫秒级交易！<br><br>请部署 <span style="color: #00ffff;">[L2 速射炮]</span>，利用其 <span style="color: #ffd700;">超高攻速</span> 形成的火力网，强行压制并瓦解敌人的修复装甲！</div>',
                'level4_victory_title': '第四关完成',
                'level4_victory_subtitle': '闪电速度',
                'level4_victory_content': '交易速度提升了1000倍！手续费降低了99%！\n\n但最大的威胁还在前方...\n有人正在集结算力，准备发动51%攻击！\n\n这将是区块链的终极考验！',
                
                // 关卡介绍 - 第5关
                'level5_opening_title': '终极威胁',
                'level5_opening_subtitle': '关卡 5：51%攻击',
                'level5_opening_content': '<div style="text-align: left;"><strong style="color: #ff0000;">🟥 红色最高警报：51% 算力攻击！</strong><br><br>攻击者已控制全网超过 <span style="color: #ff6b6b;">50% 的算力</span>，正在试图 <span style="color: #ff6b6b;">重写区块链历史</span>。一旦防线失守，所有交易记录将被篡改！<br><br><strong style="color: #ff6b6b;">⚠️ 战场突变：双通道入侵</strong><br>敌人将从 <span style="color: #ff6b6b;">两个入口</span> 同时发起猛攻，防守压力翻倍！<br><br><span style="color: #00ffff;">终极协议解锁：硬分叉 (Hard Fork)</span><br>常规手段已失效。必须启动 <span style="color: #00ffff;">[主网大炮]</span>，强制把恶意算力剥离！这是对付 BOSS 的唯一手段，能造成 <span style="color: #ffd700;">毁灭性打击</span>。<br><br><strong>这是最后一战，誓死守卫创世区块！</strong></div>',
                'level5_victory_title': '第五关完成',
                'level5_victory_subtitle': '共识守护',
                'level5_victory_content': '你击退了51%攻击！区块链安全了！\n\n从交易验证到抵御51%攻击，\n你掌握了所有的防御技术。\n\n非对称加密保护了用户的身份，\n工作量证明确保了网络的安全，\n分片技术提升了处理速度，\n零知识证明平衡了隐私和透明，\nLayer 2让区块链真正可用。\n\n你是真正的区块链守护者！'
            },
            
            'en-US': {
                // 游戏标题
                'game_title': 'Block Rush',
                'game_subtitle': '',
                'game_description': 'Protect your blockchain! Stop malicious transactions from corrupting the network.<br>Let legitimate transactions pass, eliminate hackers and attacks!',
                
                // 按钮文本
                'btn_story': '📖 Watch Story',
                'btn_start': 'Start Game',
                'btn_pause': '⏸ Pause',
                'btn_resume': '▶ Resume Game',
                'btn_restart': '🔁 Retry Level',
                'btn_levels': '🎮 Select Level',
                'btn_back_level_select': '← Levels',
                'btn_back_main': '← Main Menu',
                'btn_start_deploy': '🚀 Start Deploy',
                'btn_credits': 'About Us',
                'credits_title': 'About Us',
                'credits_developers': 'Development Team:',
                'credits_thanks': 'Special Thanks:',
                'credits_kiro_desc': 'AI Development Assistant',
                'credits_close': 'Close',
                'btn_reset': '🔄 Reset Game',
                'btn_endless': '∞ Endless Mode',
                
                // 关卡选择
                'level_select_title': 'Select Level',
                'level_select_subtitle': 'SELECT LEVEL',
                'level_select_victory_tip': '💡 Victory Condition: Let enough <span style="color:#00ff88">legitimate transactions</span> (green) enter blocks + Eliminate all <span style="color:#ff0044">malicious data</span> (red)',
                'btn_back': '← Back',
                'btn_back_main': '← Back to Main',
                'btn_knowledge': '📚 Game Guide',
                'knowledge_title': 'Game Guide',
                'knowledge_subtitle': 'GAME GUIDE',
                
                // 游戏状态
                'status_victory': 'Victory!',
                'status_defeat': 'Defeat...',
                'status_wave_complete': 'Wave Complete',
                'status_level_complete': 'Level Complete',
                
                // 资源
                'resource_gas': 'GAS',
                'resource_hp': 'HP',
                'resource_wave': 'Wave',
                'resource_level': 'Level',
                
                // 提示
                'tip_not_enough_gas': 'Not enough GAS',
                'tip_max_level': 'Max level reached',
                'tip_cannot_build': 'Cannot build here',
                
                // 快捷键提示
                'hotkeys_tip': 'Hotkeys: Space=Pause | X=2x Speed | N=Next Wave | M=Volume | ESC=Menu',
                'traffic_tip_green': '🟢 Green = Valid Transaction (Let Pass)',
                'traffic_tip_red': '🔴 Red = Malicious Data (Eliminate)',
                'help_title_quick': 'Quick Guide',
                
                // 游戏UI
                'ui_level': 'LEVEL',
                'ui_block_height': 'BLOCK HEIGHT',
                'ui_transactions': 'TRANSACTIONS',
                'ui_wallet_balance': 'WALLET BALANCE',
                'ui_lives': 'NETWORK INTEGRITY',
                'ui_wave': 'WAVE',
                'ui_wave_announce': 'WAVE {0} / {1}',
                'ui_enemies': 'ENEMIES',
                'ui_remaining': 'remaining',
                'ui_menu_esc': 'Menu ESC',
                'ui_volume': 'Volume',
                'ui_volume_control': 'Volume Control',
                'ui_bgm': '🎵 BGM',
                'ui_sfx': '🔊 SFX',
                
                // 测试按钮
                'btn_test_mode': '🎮 Experience All Content',
                
                // 游戏界面
                'pause_title': 'Game Paused',
                'pause_subtitle': 'PAUSED',
                'pause_description': 'Press ESC or click button to continue',
                'space_pause_title': '⏸ Paused',
                'space_pause_hint': 'Press Space or click pause button to continue',
                'pause_current_level': 'Current Level',
                'pause_balance': 'Balance',
                'defeat_title': 'Blockchain Corrupted!',
                'defeat_description': 'Malicious transactions invaded the blockchain, consensus failed...',
                'endless_mode_name': 'Endless Mode',
                'endless_unlock_title': '🌟 Endless Mode Unlocked!',
                'endless_unlock_desc': 'Challenge your limits, see how many waves you can defend!',
                'enemy_modal_btn': 'Got it, Continue Game',
                'enemy_new_appear': '⚠ New Enemy Appeared!',
                'enemy_tip_label': '💡 Strategy Tip:',
                'endless_desc': 'Random Map | Infinite Challenge',
                'endless_challenge': '🌟 Ultimate Test',
                'unlock_status_template': '🔒 Clear Level {0} to Unlock',
                'knowledge_locked': '🔒 Locked',
                'knowledge_available': 'Click to View Details',
                
                // Level names
                'level_1_name': 'Transaction Verification',
                'level_2_name': 'Network Scaling',
                'level_3_name': 'Privacy & Proof',
                'level_4_name': 'Lightning Network',
                'level_5_name': '51% Attack',
                
                // Level descriptions
                'level_1_desc': 'Straight Map | Basic Enemies',
                'level_2_desc': 'U-Turn | Splitters',
                'level_3_desc': 'S-Curve | Armored',
                'level_4_desc': 'Long Straight | Healers',
                'level_5_desc': 'Dual Entry | BOSS',
                
                // Level unlocks
                'level_1_unlock': '🔐 Validator Node',
                'level_2_unlock': '💥 Sharding Cannon',
                'level_3_unlock': '🎯 ZK Sniper',
                'level_4_unlock': '⚡ L2 Channel',
                'level_5_unlock': '☄️ Mainnet Cannon',
                'level_unlock_status_2': '🔒 Clear Level 1 to Unlock',
                'level_unlock_status_3': '🔒 Clear Level 2 to Unlock',
                'level_unlock_status_4': '🔒 Clear Level 3 to Unlock',
                'level_unlock_status_5': '🔒 Clear Level 4 to Unlock',
                'level_unlock_status_endless': '🔒 Clear Level 5 to Unlock',
                
                // Difficulty
                'difficulty_title': 'Select Difficulty',
                'difficulty_easy': '🛡 Easy (HP 70%)',
                'difficulty_normal': '⭐ Normal (HP 100%)',
                'difficulty_hard': '💀 Hard (HP 140%)',
                'difficulty_easy_short': 'Easy',
                'difficulty_normal_short': 'Normal',
                'difficulty_hard_short': 'Hard',
                
                // Level status
                'level_status_start': '▶ Start',
                'level_status_replay': '🔁 Replay',
                'level_status_challenge': '♾️ Challenge',
                
                // Tech unlock buttons
                'btn_start_challenge': 'Start Challenge!',
                'btn_next_tower': 'Next',
                
                // In-game tips
                'click_to_start': 'Click to Start',
                'click_spawn_icon': 'Click red icon at path entrance to start wave',
                
                // In-game buttons
                'btn_pause': 'Pause',
                'btn_continue': 'Continue',
                'btn_next_wave': 'Next Wave',
                'btn_help': '📖 Help',
                'btn_close': '✕ Close',
                'enemy_modal_btn': 'Got it, Continue Game',
                'enemy_info_title': '⚠ ENEMY INFO',
                'enemy_info_hp': 'HP',
                'enemy_info_speed': 'Speed',
                'enemy_info_reward': 'Reward',
                'hotkey_space': 'Space',
                'hotkey_n': 'Hotkey: N',
                
                // Tooltip text
                'tooltip_locked': 'Unlock at Level {0}',
                'tooltip_build': 'Build',
                'tooltip_sell': 'Sell',
                'tooltip_income': 'Income',
                'tooltip_range': 'Range',
                'tooltip_damage': 'Damage',
                'tooltip_attack_speed': 'Attack Speed',
                'tooltip_slow': 'Slow',
                'tooltip_slow_range': 'Slow Range',
                'tooltip_slow_effect': 'Slow Effect',
                'tooltip_truesight_range': 'Truesight Range',
                'tooltip_full_map': 'Full Map',
                'tooltip_none': 'None',
                'tooltip_cannot_upgrade': 'Cannot Upgrade',
                'tooltip_can_upgrade': 'Upgradeable to Lv10',
                'tooltip_recycle': 'Recycle',
                'tooltip_counter_spam': '⚡ Bonus vs Spam (1.2x-2.5x, scales with level)',
                'tooltip_counter_armored': '💥 Bonus vs Armored (1.5x-2.8x) | BOSS (1.1x-2.0x)',
                'tooltip_counter_splitter': '💎 Bonus vs Splitter (1.2x-2.5x, scales with level)',
                'tooltip_counter_healer': '⚡ Bonus vs Healer (1.2x-2.5x + Suppress 40%-85%)',
                'tooltip_counter_boss': '💥 vs BOSS: Deal 30% current HP damage!',
                'tooltip_aura_gas': '⚡ Aura: +15%-50% attack speed to nearby towers',
                'tooltip_truesight': '👁️ Truesight: Reveal invisible + Slow 35%-50%',
                
                // Tower management panel
                'panel_level': 'Level',
                'panel_stat_cost': 'Cost',
                'panel_stat_damage': 'Damage',
                'panel_stat_range': 'Range',
                'panel_stat_speed': 'Speed',
                'panel_stat_income': 'Income',
                'panel_stat_boost': 'Boost',
                'panel_stat_slow_range': 'Slow Range',
                'panel_stat_slow_effect': 'Slow Effect',
                'panel_stat_sell_refund': 'Refund on sell',
                'panel_stat_uses': 'Uses',
                'panel_stat_aoe_damage': 'AOE Damage',
                'panel_stat_slow': 'Slow',
                'panel_stat_truesight': 'Truesight Range',
                'panel_upgrade_preview': 'After Upgrade:',
                'panel_upgrade_to': 'Upgrade to',
                'panel_upgrade': '⬆ Upgrade (W)',
                'panel_max_level': '⭐ Max Level!',
                'panel_current_level': 'Current Level',
                'panel_max_level_btn': '⭐ Max Level',
                'panel_sell': '💰 Sell (Q)',
                'panel_cancel': 'Cancel',
                'panel_sell_ratio': 'Sell Return {0}%',
                'panel_miner_privilege': '(Miner Privilege)',
                'panel_before_wave1': '(Before Wave 1)',
                'panel_target_priority': 'Target Priority',
                'panel_priority_first': 'First',
                'panel_priority_last': 'Last',
                'panel_priority_counter': 'Counter',
                'panel_priority_strongest': 'Strongest',
                'panel_priority_weakest': 'Weakest',
                'panel_priority_nearest': 'Nearest',
                
                // Enemy info panel
                'enemy_info_title': '⚠ ENEMY INFO',
                'enemy_info_hp': 'HP',
                'enemy_info_speed': 'Speed',
                'enemy_info_reward': 'Reward',
                
                // Floating text
                'float_life': 'Life',
                'float_verified': '✓ VERIFIED',
                'float_unverified': 'Unverified!',
                'float_detected': '⚠ DETECTED!',
                'float_suppress': '⚡ SUPPRESS!',
                'float_miss': 'MISS',
                'float_purge': '⚡ PURGE!',
                'float_pierce': '💥 PIERCE!',
                'float_critical': '🎯 CRITICAL!',
                'float_shatter': '💎 SHATTER!',
                'float_blocked': '🛡️ BLOCKED',
                'float_mainnet_strike': '💥 MAINNET STRIKE!',
                'float_not_enough_gas': 'NOT ENOUGH GAS!',
                'float_cannon_limit': 'Mainnet Cannon Limit: 1/Level',
                'float_miner_limit': 'Miner Limit: Max 5',
                'float_cannot_sell_cannon': 'Cannot Sell Mainnet Cannon!',
                'float_max_level': 'Max Level!',
                'float_max_lives_up': 'Max Lives Increased!',
                'float_not_enough_gas_upgrade': 'Not Enough GAS!',
                'float_target_priority': 'Target: {0}',
                
                // Speed button
                'speed_normal': 'Normal Speed',
                'speed_double': '2x Speed',
                
                // Tower names
                'tower_validator_lv1': 'Validator Node',
                'tower_validator_lv2': 'Consensus Node',
                'tower_validator_lv3': 'Master Validator',
                'tower_miner_lv1': 'Miner',
                'tower_miner_lv2': 'Mining Pool',
                'tower_miner_lv3': 'Super Mining Farm',
                'tower_gasStation_lv1': 'Gas Optimizer',
                'tower_gasStation_lv2': 'Gas Accelerator',
                'tower_gasStation_lv3': 'Gas Overcharger',
                'tower_contract_lv1': 'Smart Contract Gate',
                'tower_contract_lv2': 'Contract Firewall',
                'tower_contract_lv3': 'Contract Fortress',
                'tower_sharding_lv1': 'Sharding Processor',
                'tower_sharding_lv2': 'Sharding Cannon',
                'tower_sharding_lv3': 'Sharding Annihilator',
                'tower_zkSniper_lv1': 'ZK Sniper',
                'tower_zkSniper_lv2': 'ZK Penetrator',
                'tower_zkSniper_lv3': 'ZK Annihilator',
                'tower_l2Channel_lv1': 'L2 Channel',
                'tower_l2Channel_lv2': 'L2 Laser',
                'tower_l2Channel_lv3': 'L2 Annihilation Beam',
                'tower_mainnetCannon': 'Mainnet Cannon',
                
                // Tower descriptions
                'tower_desc_validator': 'High single-target damage, early game core. Can upgrade 4 times',
                'tower_knowledge_validator': 'Asymmetric Encryption, Signature Verification',
                'tower_desc_miner': 'Passive income building. Upgrade to increase revenue',
                'tower_knowledge_miner': 'PoW Proof of Work - Mining generates income',
                'tower_desc_gasStation': 'Group slow control. Upgrade to enhance slow effect',
                'tower_knowledge_gasStation': 'Gas Fee Incentive Mechanism',
                'tower_desc_contract': 'Area slow + true sight. Upgrade to expand range',
                'tower_knowledge_contract': 'Code Logic Judgment (If-Else)',
                'tower_desc_sharding': 'Area AOE damage. Effective against splitters',
                'tower_knowledge_sharding': 'Sharding Technology - Parallel Processing',
                'tower_desc_zkSniper': 'Ultra-long range sniper, ignores shields. Effective against armored & BOSS',
                'tower_knowledge_zkSniper': 'Zero-Knowledge Proof (ZKP) - Precise Verification',
                'tower_desc_l2Channel': 'Continuous laser output. Effective against healers',
                'tower_knowledge_l2Channel': 'Layer 2 State Channel - High-speed Processing',
                'tower_desc_mainnetCannon': 'Ultimate weapon, full map AOE. 1 per level limit',
                'tower_knowledge_mainnetCannon': 'Mainnet Final Confirmation - Irreversible',
                
                // 知识卡片 - 通用
                'knowledge_unlocked': '🔓 New Technology Unlocked!',
                'btn_start_challenge': 'Start Challenge!',
                
                // 知识卡片 - 防御塔
                'knowledge_validator_title': 'Asymmetric Encryption',
                'knowledge_validator_principle': 'Each account has two keys: a private key (only you know, used for signing) and a public key (public, used for verification).',
                'knowledge_validator_analogy': 'Like your signature: only you can sign, but everyone can verify it\'s yours.',
                'knowledge_validator_application': 'Bitcoin addresses, Ethereum wallets, digital signature authentication',
                'knowledge_validator_gameplay': 'Validator checks each transaction\'s signature to ensure it truly comes from the account owner.',
                
                'knowledge_miner_title': 'Proof of Work (PoW)',
                'knowledge_miner_principle': 'Miners compete for the right to record transactions through massive computation. Whoever solves the puzzle first gets to package the block and receive rewards.',
                'knowledge_miner_analogy': 'Like a math competition: whoever solves the problem first wins the prize.',
                'knowledge_miner_application': 'Bitcoin mining, Ethereum 1.0 (now transitioned to PoS)',
                'knowledge_miner_gameplay': 'Mining pool generates GAS income every 3 seconds, your economic source.',
                
                'knowledge_gasStation_title': 'Gas Fee Mechanism',
                'knowledge_gasStation_principle': 'Users pay Gas fees to incentivize miners to prioritize their transactions. Higher Gas fees mean faster processing.',
                'knowledge_gasStation_analogy': 'Like express shipping fees: pay more, your package arrives faster.',
                'knowledge_gasStation_application': 'Ethereum transaction fees, smart contract execution costs',
                'knowledge_gasStation_gameplay': 'Gas optimizer boosts attack speed of nearby towers, processing transactions faster.',
                
                'knowledge_contract_title': 'Smart Contract',
                'knowledge_contract_principle': 'Self-executing code deployed on blockchain. Runs automatically when conditions are met, no human intervention needed.',
                'knowledge_contract_analogy': 'Like a vending machine: insert coin → select → automatic delivery, fully automated.',
                'knowledge_contract_application': 'DeFi protocols, NFT trading, DAO governance',
                'knowledge_contract_gameplay': 'Smart contract tower automatically detects and slows enemies in range, can also reveal invisible units.',
                
                'knowledge_sharding_title': 'Sharding Technology',
                'knowledge_sharding_principle': 'Divides blockchain network into multiple shards, each processing different transactions in parallel, greatly improving throughput.',
                'knowledge_sharding_analogy': 'Like a supermarket opening multiple checkout lanes instead of one long queue.',
                'knowledge_sharding_application': 'Ethereum 2.0 sharding, Zilliqa, Near Protocol',
                'knowledge_sharding_gameplay': 'Sharding cannon fires area attacks, processing multiple targets at once, demonstrating parallel processing power.',
                
                'knowledge_zkSniper_title': 'Zero-Knowledge Proof (ZKP)',
                'knowledge_zkSniper_principle': 'Proves a statement is true without revealing any additional information.',
                'knowledge_zkSniper_analogy': 'Like proving you\'re an adult without revealing your exact age.',
                'knowledge_zkSniper_application': 'zkSNARK, zkSTARK, privacy coin Zcash',
                'knowledge_zkSniper_gameplay': 'ZK sniper can "see through" invisibility and obfuscation, dealing extra damage to hidden units.',
                
                'knowledge_l2Channel_title': 'Layer 2 Scaling',
                'knowledge_l2Channel_principle': 'Processes large volumes of transactions off the main chain, only submitting final results to main chain, reducing costs and latency.',
                'knowledge_l2Channel_analogy': 'Like borrowing and lending money with friends without recording every transaction at the bank, settling up at the end.',
                'knowledge_l2Channel_application': 'Lightning Network, Polygon, Arbitrum, Optimism',
                'knowledge_l2Channel_gameplay': 'L2 channel fires continuous laser, high-frequency low-cost sustained damage.',
                
                'knowledge_mainnetCannon_title': 'Hard Fork',
                'knowledge_mainnetCannon_principle': 'Major protocol change incompatible with old versions. Equivalent to "rebooting" the network, a last resort.',
                'knowledge_mainnetCannon_analogy': 'Like a major OS upgrade where old software may not run.',
                'knowledge_mainnetCannon_application': 'Bitcoin Cash fork, Ethereum DAO incident fork',
                'knowledge_mainnetCannon_gameplay': 'Mainnet cannon is the ultimate weapon, dealing 30% of BOSS\'s current HP as massive damage, requires manual targeting.',
                
                // 知识卡片 - 敌人
                'knowledge_spam_title': 'Spam Transaction Attack',
                'knowledge_spam_principle': 'Attackers send massive meaningless transactions to clog the network, preventing normal transactions from being processed.',
                'knowledge_spam_analogy': 'Like someone constantly making prank calls, occupying the customer service line so real customers can\'t get through.',
                'knowledge_spam_application': '2017 Ethereum CryptoKitties congestion incident',
                'knowledge_spam_gameplay': 'Basic enemy, numerous but low HP, easy to clear.',
                
                'knowledge_doublespend_title': 'Double Spend Attack',
                'knowledge_doublespend_principle': 'Attackers attempt to spend the same money twice by controlling hash power or exploiting network delays.',
                'knowledge_doublespend_analogy': 'Like using the same counterfeit bill at two stores simultaneously.',
                'knowledge_doublespend_application': '51% attack, Race Attack, Finney Attack',
                'knowledge_doublespend_gameplay': 'Invisible, requires smart contract\'s true sight or ZK sniper to reveal.',
                
                'knowledge_splitter_title': 'Dust Attack',
                'knowledge_splitter_principle': 'Attackers send tiny amounts to fill victims\' wallets with "dust", making them hard to manage and exposing privacy.',
                'knowledge_splitter_analogy': 'Like someone dumping garbage at your doorstep, preventing normal access.',
                'knowledge_splitter_application': 'Bitcoin dust attacks, address tracking',
                'knowledge_splitter_gameplay': 'Splits into 3 fast-moving small units upon death, requires area attacks to clear.',
                
                'knowledge_armored_title': 'Mixing Service',
                'knowledge_armored_principle': 'Obfuscates transaction sources and destinations, making fund flows hard to trace.',
                'knowledge_armored_analogy': 'Like mixing your money with many others, shuffling, then returning it so no one knows which is yours.',
                'knowledge_armored_application': 'Tornado Cash, CoinJoin, mixers',
                'knowledge_armored_gameplay': 'Has 50% damage reduction, requires high damage or ZK sniper\'s penetrating attacks.',
                
                'knowledge_vampire_title': 'High-Frequency Trading Attack',
                'knowledge_vampire_principle': 'Exploits extremely fast transaction speeds to front-run, profiting from price fluctuations (front-running, sandwich attacks).',
                'knowledge_vampire_analogy': 'Like someone knowing stock prices 0.1 seconds early, always buying/selling before you.',
                'knowledge_vampire_application': 'MEV (Maximal Extractable Value), sandwich attacks',
                'knowledge_vampire_gameplay': 'Continuously heals, requires L2 channel\'s sustained damage to suppress healing.',
                
                'knowledge_boss_title': '51% Attack',
                'knowledge_boss_principle': 'Attacker controls over 50% of network hash power, can tamper with transaction records and perform double spends.',
                'knowledge_boss_analogy': 'Like someone controlling more than half the votes, able to modify voting results at will.',
                'knowledge_boss_application': 'Small blockchain 51% attack cases (ETC, BTG, etc.)',
                'knowledge_boss_gameplay': 'Ultimate BOSS, extremely high HP and damage reduction, requires all advanced towers coordinated, mainnet cannon is key to victory.',
                
                // 知识卡片 - 标签
                'knowledge_label_principle': 'Principle',
                'knowledge_label_analogy': 'Analogy',
                'knowledge_label_application': 'Application',
                'knowledge_label_gameplay': 'Game Mechanic',
                'knowledge_label_principle_icon': '💡 Principle:',
                'knowledge_label_gameplay_icon': '🎮 Game Mechanic:',
                'knowledge_ai_label': 'Chain AI',
                
                // 帮助屏幕
                'help_screen_title': 'Blockchain Knowledge',
                'help_screen_subtitle': 'BLOCKCHAIN KNOWLEDGE',
                'tab_guide': '📖 Operation Guide',
                'tab_encyclopedia': '📚 Blockchain Encyclopedia',
                
                // 帮助面板内容 - 游戏目标
                'help_goal_content_1': 'Protect your <span style="color:#00ffff">Block</span>!',
                'help_goal_content_2': '• <span style="color:#00ff88">Green blocks</span> = Valid transactions → <b>Let pass</b>',
                'help_goal_content_3': '• <span style="color:#ff0044">Red enemies</span> = Malicious data → <b>Eliminate</b>',
                'help_goal_content_4': '• Click the <span style="color:#ff0044">red icon</span> at path entrance to start wave',
                
                // 帮助面板 - 快捷键
                'help_hotkey_x_title': 'X - 2x Speed',
                'help_hotkey_x_desc': 'Toggle game speed (1x ↔ 2x)',
                'help_hotkey_n_title': 'N - Next Wave',
                'help_hotkey_n_desc': 'Skip preparation time, start next wave immediately',
                'help_hotkey_esc_title': 'ESC / P - Pause',
                'help_hotkey_esc_desc': 'Open pause menu',
                'help_hotkey_space_title': 'Space - Quick Pause',
                'help_hotkey_space_desc': 'Hold to pause, release to continue',
                'help_hotkey_w_title': 'W - Quick Upgrade',
                'help_hotkey_w_desc': 'Upgrade currently selected tower',
                'help_hotkey_q_title': 'Q - Quick Sell',
                'help_hotkey_q_desc': 'Sell currently selected tower',
                'help_hotkey_r_title': 'R - Mainnet Strike',
                'help_hotkey_r_desc': 'Activate Mainnet Cannon targeting mode (requires Mainnet Cannon)',
                'help_hotkey_1to8_title': '1-8 - Select Tower',
                'help_hotkey_1to8_desc': 'Quickly select tower by number for placement',
                
                // 帮助面板 - 操作说明
                'help_control_place_title': 'Place Tower',
                'help_control_place_desc': 'Click tower icon at bottom → Click empty space on map',
                'help_control_upgrade_title': 'Upgrade Tower',
                'help_control_upgrade_desc': 'Click placed tower → Click upgrade button (Max Lv10)',
                'help_control_sell_title': 'Sell Tower',
                'help_control_sell_desc': 'Click placed tower → Click sell button (70% refund)',
                'help_control_enemy_title': 'View Enemy Info',
                'help_control_enemy_desc': 'Click enemy to view detailed stats and abilities',
                
                // 帮助面板 - 防御塔详情
                'help_tower_validator_title': '🔐 Validator - Asymmetric Encryption',
                'help_tower_validator_desc': 'High single-target damage, early game core. Upgradeable to Lv10',
                'help_tower_validator_stats': 'Cost 25 | Range 110 | Damage 12 | Speed 1.0s',
                'help_tower_validator_special': '⚡ Counter: Spam (1.2x-2.5x)',
                'help_tower_miner_title': '⛏️ Miner - Proof of Work',
                'help_tower_miner_desc': 'Passive income building. Upgradeable to Lv10',
                'help_tower_miner_stats': 'Cost 50 | Income 2 GAS/3s | 90% refund on sell',
                'help_tower_gas_title': '⛽ Gas Station - Gas Fee Mechanism',
                'help_tower_gas_desc': 'Area speed boost. Upgradeable to Lv10',
                'help_tower_gas_stats': 'Cost 45 | Range 100 | Boost 25%-70%',
                'help_tower_contract_title': '📜 Contract Gate - Smart Contract',
                'help_tower_contract_desc': 'Area slow + true sight. Upgradeable to Lv10',
                'help_tower_contract_stats': 'Cost 65 | Range 140 | Slow 35%-80%',
                'help_tower_sharding_title': '💥 Sharding Cannon - Sharding Tech [Lv2 Unlock]',
                'help_tower_sharding_desc': 'AOE area damage. Upgradeable to Lv10',
                'help_tower_sharding_stats': 'Cost 75 | Range 150 | AOE Damage 30',
                'help_tower_sharding_special': '💎 Counter: Splitters (1.2x-2.5x)',
                'help_tower_zk_title': '🎯 ZK Sniper - Zero-Knowledge Proof [Lv3 Unlock]',
                'help_tower_zk_desc': 'Ultra long range. Upgradeable to Lv10',
                'help_tower_zk_stats': 'Cost 90 | Range 260 | Damage 50',
                'help_tower_zk_special': '💥 Counter: Armored/BOSS (1.5x-2.8x / 1.1x-2.0x)',
                'help_tower_l2_title': '⚡ L2 Channel - Layer 2 Scaling [Lv4 Unlock]',
                'help_tower_l2_desc': 'Continuous laser. Upgradeable to Lv10',
                'help_tower_l2_stats': 'Cost 100 | Range 180 | Damage 20/s',
                'help_tower_l2_special': '⚡ Counter: Healers (1.2x-2.5x + Suppress 40%-85%)',
                'help_tower_cannon_title': '☄️ Mainnet Cannon - Hard Fork [Lv5 Unlock]',
                'help_tower_cannon_desc': 'Manual bombardment, BOSS killer',
                'help_tower_cannon_stats': 'Cost 80 | Uses 150 GAS | AOE Damage 200',
                'help_tower_cannon_special': '💥 Deals 30% of BOSS current HP!',
                
                // 帮助面板 - 敌人类型
                'help_enemy_valid_title': '■ Valid Transaction',
                'help_enemy_valid_desc': 'Let it enter the block! Reward +5 GAS after verification',
                
                // 怪物介绍卡片
                'enemy_normal_name': 'Legitimate Transaction',
                'enemy_spam_name': 'Spam Virus',
                'enemy_doubleSpend_name': 'Double-Spend Ghost',
                'enemy_splitter_name': 'Dust Splitter',
                'enemy_shielded_name': 'Mixer Armored Beast',
                'enemy_healer_name': 'HFT Vampire',
                'enemy_boss_name': '51% Hashpower Titan',
                'enemy_splitChild_name': 'Fragment',
                'enemy_normal_desc': 'Green data packet - This is a normal transaction that needs to be packed into the block!',
                'enemy_normal_tip': 'Don\'t attack them, let them safely reach the block.',
                'enemy_spam_desc': 'Spam data virus - Invalid transactions trying to clog the network!',
                'enemy_spam_tip': 'Use validator nodes to quickly clean them up!',
                'enemy_doublespend_desc': 'Invisible double-spend attack - Trying to spend the same money twice!',
                'enemy_doublespend_tip': 'Need smart contract gates to reveal their true form!',
                'enemy_splitter_desc': 'Dust attack carrier - Splits into 3 fast-moving fragments on death!',
                'enemy_splitter_tip': 'Sharding cannons deal extra damage to splitters, AOE range can clear fragments at once!',
                'enemy_shielded_desc': 'Mixer shield - Has 50% damage reduction! Normal attacks only deal half damage!',
                'enemy_shielded_tip': 'ZK Sniper can penetrate shields and deal extra damage!',
                'enemy_healer_desc': 'High-frequency trading entity - Heals 8 HP per second! Must kill quickly or suppress healing!',
                'enemy_healer_tip': 'Layer 2 channel\'s sustained laser can suppress healing and deal extra damage!',
                'enemy_boss_desc': '51% attack behemoth - Controls over half the hash power! 10000 HP, 55% damage reduction, 3 HP/s regen!',
                'enemy_boss_tip': 'Must use advanced tower combinations! ZK Sniper deals extra damage to BOSS! Mainnet Cannon deals 30% current HP damage, key to victory!',
                'enemy_doubleSpend_desc': 'Invisible double-spend attack - Trying to spend the same money twice!',
                'enemy_doubleSpend_tip': 'Need smart contract gates to reveal their true form!',
                'help_enemy_spam_title': '🦠 Spam Virus',
                'help_enemy_spam_desc': 'Fast but fragile, reward 3 GAS',
                'help_enemy_double_title': '👻 Double-Spend Ghost [Invisible]',
                'help_enemy_double_desc': 'Invisible unit, requires true sight to attack',
                'help_enemy_splitter_title': '💎 Dust Splitter [Splits]',
                'help_enemy_splitter_desc': 'Splits into 3 small units on death',
                'help_enemy_shielded_title': '🛡️ Mixer Beast [Damage Reduction]',
                'help_enemy_shielded_desc': '200 HP + 50% damage reduction shield',
                'help_enemy_shielded_counter': 'Counter: ZK Sniper',
                'help_enemy_healer_title': '💚 HFT Vampire [Healing]',
                'help_enemy_healer_desc': '150 HP + Heals 8 HP per second',
                'help_enemy_healer_counter': 'Counter: Layer 2 Channel',
                'help_enemy_boss_title': '☠️ 51% Hash Titan [BOSS]',
                'help_enemy_boss_desc': '10000 HP + 55% damage reduction + 3 HP/s regen',
                'help_enemy_boss_counter': 'Counter: Mainnet Cannon + ZK Sniper',
                
                // 帮助面板 - 游戏技巧
                'help_tip_economy_title': 'Economy First',
                'help_tip_economy_desc': 'Build more miners early game to ensure economic growth',
                'help_tip_upgrade_title': 'Upgrade Over Build',
                'help_tip_upgrade_desc': 'Upgrading is ~2x more cost-effective, prioritize core towers to Lv10',
                'help_tip_priority_title': 'Target Priority',
                'help_tip_priority_desc': 'Click tower to set: First/Last/Counter/Strongest/Weakest/Nearest',
                'help_tip_combo_title': 'Smart Combos',
                'help_tip_combo_desc': 'Gas Station + Contract Gate + Main Tower = Perfect combo',
                'help_tip_counter_title': 'Counter Strategy',
                'help_tip_counter_desc': 'Spam→Validator | Armored→ZK Sniper | Splitter→Sharding | Healer→L2 Channel',
                
                // 帮助面板 - 学习模式
                'help_learn_card_title': 'Knowledge Cards',
                'help_learn_card_desc': 'Each tower unlock shows blockchain knowledge introduction',
                'help_learn_story_title': 'Story Mode',
                'help_learn_story_desc': 'Each level has opening and victory stories about blockchain',
                
                // 游戏界面UI
                'ui_speed_2x': '2x Speed',
                'ui_hotkey_x': 'Hotkey: X',
                'ui_tower_menu': 'Collapse',
                'ui_tower_validator': 'Validator',
                'ui_tower_miner': 'Miner',
                'ui_tower_gas': 'Gas Station',
                'ui_tower_contract': 'Contract',
                'ui_tower_sharding': 'Sharding',
                'ui_tower_zk': 'ZK Sniper',
                'ui_tower_l2': 'L2 Channel',
                'ui_tower_cannon': 'Mainnet',
                
                // 帮助面板标题
                'help_title_goal': 'Game Objective',
                'help_title_hotkeys': 'Hotkeys',
                'help_title_controls': 'Controls',
                'help_hotkey_x_title': 'Speed x2',
                'help_hotkey_n_title': 'Next Wave',
                'help_hotkey_esc_title': 'Pause',
                'help_hotkey_space_title': 'Quick Pause',
                'help_goal_content_2': 'Legitimate Transactions → Allow',
                'help_goal_content_3': 'Malicious Data → Destroy',
                'help_title_towers': '🗼 Tower List',
                'help_title_enemies': '👾 Enemy Types',
                'help_title_tips': '💡 Game Tips',
                'help_title_learning': '📚 Learning Mode',
                
                // 帮助面板 - 学习模式
                'help_learn_library_title': 'Knowledge Library',
                'help_learn_library_desc': 'Click "Knowledge Library" on level select screen to review',
                
                // 开场故事
                'opening_title': 'Guardian of the Digital World',
                'opening_subtitle': 'MISSION BRIEFING',
                'opening_content': 'In <span style="color:#00ffff">2045</span>, human society has become fully digitized.<br>Every transaction must be verified and recorded through <span style="color:#00ffff">blockchain</span> - a <span style="color:#00ffff">decentralized</span> ledger.<br><br>But <span style="color:#ff0044">hackers, scammers, and malicious programs</span> never stop attacking...<br><br>You are a <span style="color:#00ff88">blockchain security engineer</span>.<br>Your mission: Protect the <span style="color:#00ffff">blockchain</span> network and ensure every block contains only legitimate, secure transactions.',
                'opening_mechanics_title': '▼ CORE MECHANICS ▼',
                'opening_mechanics_allow': 'Legitimate Transactions → Allow',
                'opening_mechanics_destroy': 'Malicious Attacks → Destroy',
                'mechanics_legitimate_data': 'Legitimate Data',
                'mechanics_malicious_attack': 'Malicious Attack',
                'mechanics_pass': '>> PASS',
                'mechanics_kill': '>> KILL',
                
                // 关卡介绍 - 第1关
                'level1_opening_title': 'First Line of Defense',
                'level1_opening_subtitle': 'Level 1: Transaction Verification',
                'level1_opening_content': '<div style="text-align: left;"><strong>【Current Location】</strong><br><span style="color: #00ffff;">Transaction Pool (Mempool)</span><br><br><strong>【Mission Brief】</strong><br>All transactions queue here before going on-chain. You are the <span style="color: #00ffff;">first line of defense</span> and must prevent <span style="color: #ff6b6b;">spam transactions</span> from clogging the network.<br><br><strong>【Execution Orders】</strong><br>Deploy Facility: <span style="color: #00ffff;">Public Key Validator</span><br>Core Mechanism: <span style="color: #ffd700;">Check digital signatures</span> (like verifying bank ID)<br><br><strong>【Alert Targets】</strong><br><span style="color: #ff6b6b;">Spam Transactions / Malicious Attacks</span></div>',
                'level1_victory_title': 'Level 1 Complete',
                'level1_victory_subtitle': 'Defense Secured',
                'level1_victory_content': 'Well done! You successfully verified the first batch of transactions.\n\nBut this is just the beginning...\nAs blockchain becomes more popular, transaction volume explodes,\nSimple verification is no longer enough.\n\nWe need more powerful technology...',
                
                // 链灵对话 - 第1关
                'dialogue_level1_intro_1': 'This is the most basic defense! Spam transaction bugs are attacking the network.',
                'dialogue_level1_intro_2': 'Build validator nodes to clear them, but let the green legitimate transactions pass!',
                'dialogue_level1_victory_1': 'Excellent! You successfully protected the first batch of transactions!',
                'dialogue_level1_victory_2': 'But this is just the beginning... stronger enemies are coming.',
                
                // 关卡介绍 - 第2关
                'level2_opening_title': 'Scaling Crisis',
                'level2_opening_subtitle': 'Level 2: Network Scaling',
                'level2_opening_content': '<div style="text-align: left;"><strong>⚠️ Alert: Network Extremely Congested!</strong><br><br>Transaction volume surged <span style="color:#ff0044">100x</span>, single-chain processing has collapsed.<br><br>Must activate <span style="color:#00ffff">[Sharding Technology]</span> — divide the network into multiple parallel zones to process massive data simultaneously.<br><br><strong>Current Threat: Dust Attack</strong><br>Enemies split into countless tiny units, attempting to paralyze nodes with "swarm tactics".<br><br><strong>Tactical Orders:</strong><br>Conventional weapons are too inefficient, deploy <span style="color:#00ffff">[Sharding Cannon]</span> and use <span style="color:#ffd700">Area of Effect (AOE)</span> to clear them in batches!</div>',
                'level2_victory_title': 'Level 2 Complete',
                'level2_victory_subtitle': 'Network Clear',
                'level2_victory_content': 'Network restored! Transaction speed increased 10x!\n\nBut new threats have emerged...\nSomeone is using "mixers" to hide transaction sources.\n\nWe need more advanced technology to counter this...',
                
                // 链灵对话 - 第2关
                'dialogue_level2_intro_1': 'Oh no! Dust splitters have appeared!',
                'dialogue_level2_intro_2': 'They split into 3 small units after death... we need sharding processors!',
                'dialogue_level2_victory_1': 'Sharding technology really works! You learn fast!',
                
                // 关卡介绍 - 第3关
                'level3_opening_title': 'Privacy Battle',
                'level3_opening_subtitle': 'Level 3: Privacy & Proof',
                'level3_opening_content': '<div style="text-align: left;">⚠️ Alert: "<span style="color: #ff6b6b;">Double-Spend Attack</span>" detected!<br><br>Cunning enemies attempt to spend the same money twice, using encryption fog to remain in <span style="color: #ff6b6b;">[Stealth Mode]</span>. Conventional defense towers cannot lock onto targets.<br><br><span style="color: #00ffff;">Technology Unlocked: Zero-Knowledge Proof (ZK-SNARKs)</span><br>"Verify truth without knowing the details."<br><br><span style="color: #ffd700;">Tactical Orders:</span><br>Deploy <span style="color: #00ffff;">[ZK Sniper Tower]</span> immediately! It has <span style="color: #ffd700;">True Sight</span> ability to see through all stealth units and deal <span style="color: #ffd700;">critical damage</span>!</div>',
                'level3_victory_title': 'Level 3 Complete',
                'level3_victory_subtitle': 'Truth Revealed',
                'level3_victory_content': 'You found the balance between privacy and security!\n\nBut blockchain has a fatal weakness:\nMainchain processing is too slow, fees too expensive...\n\nTime to introduce Layer 2!',
                
                // 链灵对话 - 第3关
                'dialogue_level3_intro_1': 'Watch out! Double-spend ghosts can go invisible!',
                'dialogue_level3_intro_2': 'Use smart contract\'s true sight, or zero-knowledge prover\'s penetrating attack!',
                'dialogue_level3_victory_1': 'The power of zero-knowledge proof... even unseen, truth can be verified!',
                
                // 关卡介绍 - 第4关
                'level4_opening_title': 'Speed Revolution',
                'level4_opening_subtitle': 'Level 4: Lightning Network',
                'level4_opening_content': '<div style="text-align: left;">⚠️ Mainnet Congestion Alert: <span style="color: #ff6b6b;">Gas fees have skyrocketed!</span><br><br>On-chain confirmation is too slow, single transaction fees reach tens of dollars, conventional defenses have collapsed.<br><br><span style="color: #ff6b6b;">Powerful Enemy: Vampire Bot</span><br>They have <span style="color: #ff6b6b;">[Continuous Healing]</span> mechanism, normal tower damage can\'t keep up with their regeneration!<br><br><span style="color: #00ffff;">Technology Upgrade: Lightning Network</span><br>Establish off-chain Layer 2 channels for millisecond-level transactions!<br><br>Deploy <span style="color: #00ffff;">[L2 Rapid-Fire Cannon]</span>, use its <span style="color: #ffd700;">ultra-high attack speed</span> to create a firewall that forcibly suppresses and breaks enemy repair armor!</div>',
                'level4_victory_title': 'Level 4 Complete',
                'level4_victory_subtitle': 'Lightning Speed',
                'level4_victory_content': 'Transaction speed increased 1000x! Fees reduced 99%!\n\nBut the greatest threat lies ahead...\nSomeone is gathering hash power to launch a 51% attack!\n\nThis will be blockchain\'s ultimate test!',
                
                // 链灵对话 - 第4关
                'dialogue_level4_intro_1': 'Vampire bots! They keep healing!',
                'dialogue_level4_intro_2': 'Use Layer 2 channel\'s sustained damage to suppress their recovery!',
                'dialogue_level4_victory_1': 'Layer 2\'s speed... this is the future!',
                
                // 关卡介绍 - 第5关
                'level5_opening_title': 'Ultimate Threat',
                'level5_opening_subtitle': 'Level 5: 51% Attack',
                'level5_opening_content': '<div style="text-align: left;"><strong style="color: #ff0000;">🟥 RED ALERT: 51% Hash Power Attack!</strong><br><br>Attackers have controlled over <span style="color: #ff6b6b;">50% of network hash power</span>, attempting to <span style="color: #ff6b6b;">rewrite blockchain history</span>. If defenses fall, all transaction records will be tampered!<br><br><strong style="color: #ff6b6b;">⚠️ Battlefield Mutation: Dual-Channel Invasion</strong><br>Enemies will launch simultaneous attacks from <span style="color: #ff6b6b;">two entrances</span>, doubling defense pressure!<br><br><span style="color: #00ffff;">Ultimate Protocol Unlocked: Hard Fork</span><br>Conventional methods have failed. Must activate <span style="color: #00ffff;">[Mainnet Cannon]</span> to forcibly strip malicious hash power! This is the only way to deal with BOSS, capable of <span style="color: #ffd700;">devastating strikes</span>.<br><br><strong>This is the final battle, defend the genesis block at all costs!</strong></div>',
                'level5_victory_title': 'Level 5 Complete',
                'level5_victory_subtitle': 'Consensus Protected',
                'level5_victory_content': 'You repelled the 51% attack! The blockchain is safe!\n\nFrom transaction verification to defending against 51% attacks,\nyou mastered all defense technologies.\n\nAsymmetric encryption protected user identities,\nProof of Work secured the network,\nSharding improved processing speed,\nZero-knowledge proofs balanced privacy and transparency,\nLayer 2 made blockchain truly usable.\n\nYou are a true blockchain guardian!',
                
                // 链灵对话 - 第5关
                'dialogue_level5_intro_1': 'Alert! The 51% attack BOSS is here!',
                'dialogue_level5_intro_2': 'This is the ultimate test... use all defense technologies, activate mainnet cannon if necessary!',
                'dialogue_level5_victory_1': 'You did it! The blockchain is safe!',
                'dialogue_level5_victory_2': 'You are a true blockchain guardian!',
                
                // 对话界面
                'character_chain_spirit': 'Chain Spirit',
                'dialogue_continue': 'Click to continue ▼',
                
                // 剧情按钮
                'story_btn_start': 'Start Protecting!',
                'story_btn_deploy': 'Start Deployment',
                'story_btn_continue': 'Continue',
                'story_btn_final': 'Final Battle',
                'story_btn_complete': 'Mission Complete',
                
                // 胜利界面
                'victory_title': 'Mission Complete!',
                'victory_subtitle': 'MISSION ACCOMPLISHED',
                'victory_ending_title': '📜 Ending: Blockchain Guardian',
                'victory_story_1': 'In 2045, under your protection, the blockchain network withstood the most severe tests. From simple transaction validation to defending against 51% attacks, you mastered all defense technologies.',
                'victory_tech_1': 'Asymmetric encryption protected user identities',
                'victory_tech_2': 'Sharding technology enabled network scaling',
                'victory_tech_3': 'Zero-knowledge proofs ensured privacy',
                'victory_tech_4': 'Layer 2 improved transaction speed',
                'victory_tech_5': 'Decentralized consensus resisted attacks',
                'victory_quote': '"But this is not the end... As long as blockchain exists, threats will always exist.<br>And you will continue to protect this decentralized world."',
                'victory_thanks': 'Thanks for playing BlockRush!',
                'victory_tagline': 'Learn blockchain technology through gaming 🚀'
            },
            
            'ja-JP': {
                // 游戏标题
                'game_title': 'ブロック防衛戦',
                'game_subtitle': 'Block Rush',
                'game_description': 'ブロックチェーンを守れ！悪意のあるトランザクションがネットワークを汚染するのを阻止しよう。<br>正当な取引は通し、ハッカーや攻撃を排除せよ！',
                
                // 按钮文本
                'btn_story': '📖 ストーリー',
                'btn_start': 'ゲーム開始',
                'btn_pause': '⏸ 一時停止',
                'btn_resume': '▶ ゲーム再開',
                'btn_restart': '🔁 レベル再挑戦',
                'btn_levels': '🎮 レベル選択',
                'btn_back_level_select': '← レベル選択',
                'btn_back_main': '← メインメニュー',
                'btn_start_deploy': '🚀 デプロイ開始',
                'btn_credits': '私たちについて',
                'credits_title': '私たちについて',
                'credits_developers': '開発チーム：',
                'credits_thanks': '特別感謝：',
                'credits_kiro_desc': 'AI開発アシスタント',
                'credits_close': '閉じる',
                'btn_reset': '🔄 ゲームリセット',
                'btn_endless': '∞ エンドレスモード',
                
                // 关卡选择
                'level_select_title': 'レベル選択',
                'level_select_subtitle': 'SELECT LEVEL',
                'level_select_victory_tip': '💡 クリア条件：十分な<span style="color:#00ff88">正当な取引</span>(緑)をブロックに入れる + すべての<span style="color:#ff0044">悪意のあるデータ</span>(赤)を排除する',
                'btn_back': '← 戻る',
                'btn_back_main': '← メインに戻る',
                'btn_knowledge': '📚 ゲームガイド',
                'knowledge_title': 'ゲームガイド',
                'knowledge_subtitle': 'GAME GUIDE',
                
                // 游戏状态
                'status_victory': '勝利！',
                'status_defeat': '敗北...',
                'status_wave_complete': 'ウェーブクリア',
                'status_level_complete': 'レベルクリア',
                
                // 资源
                'resource_gas': 'GAS',
                'resource_hp': 'HP',
                'resource_wave': 'ウェーブ',
                'resource_level': 'レベル',
                
                // 提示
                'tip_not_enough_gas': 'GASが不足',
                'tip_max_level': '最大レベルに到達',
                'tip_cannot_build': 'ここには建設できません',
                
                // 快捷键提示
                'hotkeys_tip': 'ホットキー: スペース=一時停止 | X=2倍速 | N=次のウェーブ | M=音量 | ESC=メニュー',
                'traffic_tip_green': '🟢 緑 = 正当なトランザクション（通す）',
                'traffic_tip_red': '🔴 赤 = 悪意のあるデータ（排除）',
                'help_title_quick': 'クイックガイド',
                
                // ゲームUI
                'ui_level': 'レベル',
                'ui_block_height': 'ブロック高',
                'ui_transactions': 'トランザクション',
                'ui_wallet_balance': 'ウォレット残高',
                'ui_lives': 'ネットワーク整合性',
                'ui_wave': 'ウェーブ',
                'ui_wave_announce': 'ウェーブ {0} / {1}',
                'ui_enemies': '敵',
                'ui_remaining': '残り',
                'ui_menu_esc': 'メニュー ESC',
                'ui_volume': '音量',
                'ui_volume_control': '音量調整',
                'ui_bgm': '🎵 BGM',
                'ui_sfx': '🔊 効果音',
                
                // 测试按钮
                'btn_test_mode': '🎮 全コンテンツ体験',
                
                // 游戏界面
                'pause_title': 'ゲーム一時停止',
                'pause_subtitle': 'PAUSED',
                'pause_description': 'ESCキーまたはボタンをクリックして続行',
                'space_pause_title': '⏸ 一時停止中',
                'space_pause_hint': 'スペースキーまたは一時停止ボタンをクリックして続行',
                'pause_current_level': '現在のレベル',
                'pause_balance': '残高',
                'defeat_title': 'ブロック汚染！',
                'defeat_description': '悪意のあるトランザクションがブロックチェーンに侵入、コンセンサス失敗...',
                'endless_mode_name': 'エンドレスモード',
                'endless_unlock_title': '🌟 エンドレスモード解放！',
                'endless_unlock_desc': '限界に挑戦し、何ウェーブまで守れるか試そう！',
                'enemy_modal_btn': '了解 ゲーム続行',
                'enemy_new_appear': '⚠ 新しい敵が出現！',
                'enemy_tip_label': '💡 攻略ヒント：',
                'endless_desc': 'ランダムマップ | 無限チャレンジ',
                'endless_challenge': '🌟 究極の試練',
                'unlock_status_template': '🔒 レベル{0}クリアで解放',
                'knowledge_locked': '🔒 未解放',
                'knowledge_available': 'クリックして詳細表示',
                
                // レベル名
                'level_1_name': 'トランザクション検証',
                'level_2_name': 'ネットワーク拡張',
                'level_3_name': 'プライバシーと証明',
                'level_4_name': 'ライトニングネットワーク',
                'level_5_name': '51%攻撃',
                
                // レベル説明
                'level_1_desc': '直線マップ | 基本敵',
                'level_2_desc': 'Uターン | 分裂敵',
                'level_3_desc': 'Sカーブ | 装甲敵',
                'level_4_desc': '長直線 | 回復敵',
                'level_5_desc': '二重入口 | BOSS戦',
                
                // レベル解放
                'level_1_unlock': '🔐 検証ノード',
                'level_2_unlock': '💥 シャーディング砲',
                'level_3_unlock': '🎯 ZKスナイパー',
                'level_4_unlock': '⚡ L2チャネル',
                'level_5_unlock': '☄️ メインネット砲',
                'level_unlock_status_2': '🔒 レベル1クリアで解放',
                'level_unlock_status_3': '🔒 レベル2クリアで解放',
                'level_unlock_status_4': '🔒 レベル3クリアで解放',
                'level_unlock_status_5': '🔒 レベル4クリアで解放',
                'level_unlock_status_endless': '🔒 レベル5クリアで解放',
                
                // 難易度
                'difficulty_title': '難易度選択 DIFFICULTY',
                'difficulty_easy': '🛡 イージー (HP 70%)',
                'difficulty_normal': '⭐ ノーマル (HP 100%)',
                'difficulty_hard': '💀 ハード (HP 140%)',
                'difficulty_easy_short': 'イージー',
                'difficulty_normal_short': 'ノーマル',
                'difficulty_hard_short': 'ハード',
                
                // レベルステータス
                'level_status_start': '▶ スタート',
                'level_status_replay': '🔁 リプレイ',
                'level_status_challenge': '♾️ チャレンジ',
                
                // 技術解放ボタン
                'btn_start_challenge': 'チャレンジ開始！',
                'btn_next_tower': '次へ',
                
                // ゲーム内ヒント
                'click_to_start': 'クリックして開始',
                'click_spawn_icon': 'パス入口の赤いアイコンをクリックしてウェーブ開始',
                
                // ゲーム内ボタン
                'btn_pause': '一時停止',
                'btn_continue': '続行',
                'btn_next_wave': '次のウェーブ',
                'btn_help': '📖 ヘルプ',
                'btn_close': '✕ 閉じる',
                'enemy_modal_btn': '分かりました、ゲーム続行',
                'enemy_info_title': '⚠ 敵情報',
                'enemy_info_hp': 'HP',
                'enemy_info_speed': '速度',
                'enemy_info_reward': '報酬',
                'hotkey_space': 'スペース',
                'hotkey_n': 'ホットキー: N',
                
                // ツールチップテキスト
                'tooltip_locked': 'レベル{0}で解放',
                'tooltip_build': '建設',
                'tooltip_sell': '売却',
                'tooltip_income': '収入',
                'tooltip_range': '範囲',
                'tooltip_damage': 'ダメージ',
                'tooltip_attack_speed': '攻撃速度',
                'tooltip_slow': 'スロー',
                'tooltip_slow_range': 'スロー範囲',
                'tooltip_slow_effect': 'スロー効果',
                'tooltip_truesight_range': '真視範囲',
                'tooltip_full_map': 'マップ全体',
                'tooltip_none': 'なし',
                'tooltip_cannot_upgrade': 'アップグレード不可',
                'tooltip_can_upgrade': 'Lv10までアップグレード可能',
                'tooltip_recycle': 'リサイクル',
                'tooltip_counter_spam': '⚡ 特効：スパム (1.2x-2.5x、レベルで上昇)',
                'tooltip_counter_armored': '💥 特効：装甲 (1.5x-2.8x) | BOSS (1.1x-2.0x)',
                'tooltip_counter_splitter': '💎 特効：分裂 (1.2x-2.5x、レベルで上昇)',
                'tooltip_counter_healer': '⚡ 特効：回復 (1.2x-2.5x + 抑制40%-85%)',
                'tooltip_counter_boss': '💥 対BOSS：現在HP30%ダメージ！',
                'tooltip_aura_gas': '⚡ オーラ：範囲内の味方攻撃速度+15%-50%',
                'tooltip_truesight': '👁️ 真視：透明化解除 + スロー35%-50%',
                
                // タワー管理パネル
                'panel_level': 'レベル',
                'panel_stat_cost': 'コスト',
                'panel_stat_damage': 'ダメージ',
                'panel_stat_range': '射程',
                'panel_stat_speed': '攻速',
                'panel_stat_income': '収入',
                'panel_stat_boost': '加速',
                'panel_stat_slow_range': 'スロー範囲',
                'panel_stat_slow_effect': 'スロー効果',
                'panel_stat_sell_refund': '売却回収',
                'panel_stat_uses': '使用',
                'panel_stat_aoe_damage': 'AOEダメージ',
                'panel_stat_slow': '減速',
                'panel_stat_truesight': '真視範囲',
                'panel_upgrade_preview': 'アップグレード後:',
                'panel_upgrade_to': 'アップグレード先',
                'panel_upgrade': '⬆ アップグレード (W)',
                'panel_max_level': '⭐ 最大レベル！',
                'panel_current_level': '現在のレベル',
                'panel_max_level_btn': '⭐ 最大レベル',
                'panel_sell': '💰 売却 (Q)',
                'panel_cancel': 'キャンセル',
                'panel_sell_ratio': '売却返還 {0}%',
                'panel_miner_privilege': '(マイナー特権)',
                'panel_before_wave1': '(第1波前)',
                'panel_target_priority': 'ターゲット優先度',
                'panel_priority_first': '最初',
                'panel_priority_last': '最後',
                'panel_priority_counter': '特効',
                'panel_priority_strongest': '最強',
                'panel_priority_weakest': '最弱',
                'panel_priority_nearest': '最近',
                
                // 敵情報パネル
                'enemy_info_title': '⚠ 敵情報',
                'enemy_info_hp': 'HP',
                'enemy_info_speed': '速度',
                'enemy_info_reward': '報酬',
                
                // フローティングテキスト
                'float_life': 'ライフ',
                'float_verified': '✓ 検証済み',
                'float_unverified': '未検証!',
                'float_detected': '⚠ 検出!',
                'float_suppress': '⚡ 抑制!',
                'float_miss': 'ミス',
                'float_purge': '⚡ 浄化!',
                'float_pierce': '💥  貫通!',
                'float_critical': '🎯 クリティカル!',
                'float_shatter': '💎  粉砕!',
                'float_blocked': '🛡️ ブロック',
                'float_mainnet_strike': '💥 メインネット攻撃!',
                'float_not_enough_gas': 'GAS不足!',
                'float_cannon_limit': 'メインネット砲制限：1個/レベル',
                'float_miner_limit': 'マイナー制限：最大5個',
                'float_cannot_sell_cannon': 'メインネット砲は売却不可！',
                'float_max_level': '最大レベル！',
                'float_max_lives_up': '最大ライフ増加！',
                'float_not_enough_gas_upgrade': 'GAS不足！',
                'float_target_priority': 'ターゲット: {0}',
                
                // 速度ボタン
                'speed_normal': '通常速度',
                'speed_double': '2倍速',
                
                // タワー名
                'tower_validator_lv1': '検証ノード',
                'tower_validator_lv2': 'コンセンサスノード',
                'tower_validator_lv3': 'マスター検証者',
                'tower_miner_lv1': 'マイナー',
                'tower_miner_lv2': 'マイニングプール',
                'tower_miner_lv3': 'スーパーマイニングファーム',
                'tower_gasStation_lv1': 'Gas最適化',
                'tower_gasStation_lv2': 'Gas加速ステーション',
                'tower_gasStation_lv3': 'Gasオーバーチャージャー',
                'tower_contract_lv1': 'スマートコントラクトゲート',
                'tower_contract_lv2': 'コントラクトファイアウォール',
                'tower_contract_lv3': 'コントラクト要塞',
                'tower_sharding_lv1': 'シャーディングプロセッサ',
                'tower_sharding_lv2': 'シャーディング砲',
                'tower_sharding_lv3': 'シャーディング殲滅者',
                'tower_zkSniper_lv1': 'ZKスナイパー',
                'tower_zkSniper_lv2': 'ZK貫通砲',
                'tower_zkSniper_lv3': 'ZK殲滅者',
                'tower_l2Channel_lv1': 'L2チャネル',
                'tower_l2Channel_lv2': 'L2レーザー砲',
                'tower_l2Channel_lv3': 'L2殲滅ビーム',
                'tower_mainnetCannon': 'メインネット砲',
                
                // タワー説明
                'tower_desc_validator': '単体高ダメージ、序盤の主力。4回アップグレード可能',
                'tower_knowledge_validator': '非対称暗号化、署名検証',
                'tower_desc_miner': '受動的収入建物。アップグレードで収益向上',
                'tower_knowledge_miner': 'PoW作業証明 - マイニングで収入生成',
                'tower_desc_gasStation': '群体減速制御。アップグレードで減速効果向上',
                'tower_knowledge_gasStation': 'Gas手数料インセンティブメカニズム',
                'tower_desc_contract': '範囲減速+真視。アップグレードで範囲拡大',
                'tower_knowledge_contract': 'コードロジック判定 (If-Else)',
                'tower_desc_sharding': '範囲AOEダメージ。分裂モンスターに特効',
                'tower_knowledge_sharding': 'シャーディング技術 - 並列処理',
                'tower_desc_zkSniper': '超遠距離狙撃、シールド無視。装甲モンスターとBOSSに特効',
                'tower_knowledge_zkSniper': 'ゼロ知識証明 (ZKP) - 精密検証',
                'tower_desc_l2Channel': '持続レーザー出力。回復モンスターに特効',
                'tower_knowledge_l2Channel': 'Layer 2 ステートチャネル - 高速処理',
                'tower_desc_mainnetCannon': '究極兵器、全マップAOE。レベルごとに1個制限',
                'tower_knowledge_mainnetCannon': 'メインネット最終確認 - 不可逆',
                
                // 知識カード - 共通
                'knowledge_unlocked': '🔓 新技術解放！',
                'btn_start_challenge': 'チャレンジ開始！',
                
                // 知識カード - 防御塔
                'knowledge_validator_title': '非対称暗号化',
                'knowledge_validator_principle': '各アカウントには2つの鍵があります：秘密鍵（あなただけが知っている、署名用）と公開鍵（公開されている、検証用）。',
                'knowledge_validator_analogy': 'あなたの署名のようなもの：署名できるのはあなただけですが、誰でもそれがあなたのものか検証できます。',
                'knowledge_validator_application': 'ビットコインアドレス、イーサリアムウォレット、デジタル署名認証',
                'knowledge_validator_gameplay': '検証ノードは各トランザクションの署名をチェックし、本当にアカウント所有者からのものか確認します。',
                
                'knowledge_miner_title': 'プルーフ・オブ・ワーク (PoW)',
                'knowledge_miner_principle': 'マイナーは大量の計算を通じて記帳権を競い、最初に答えを出した人がブロックをパッケージ化し報酬を得ます。',
                'knowledge_miner_analogy': '数学コンテストのようなもの：最初に難問を解いた人が賞金を獲得します。',
                'knowledge_miner_application': 'ビットコインマイニング、イーサリアム1.0（現在はPoSに移行）',
                'knowledge_miner_gameplay': 'マイニングプールは3秒ごとにGAS収入を生成し、あなたの経済源となります。',
                
                'knowledge_gasStation_title': 'ガス料金メカニズム',
                'knowledge_gasStation_principle': 'ユーザーはガス料金を支払ってマイナーに自分のトランザクションを優先処理させます。ガス料金が高いほど、処理が速くなります。',
                'knowledge_gasStation_analogy': '速達料金のようなもの：より多く支払えば、荷物がより早く届きます。',
                'knowledge_gasStation_application': 'イーサリアムトランザクション手数料、スマートコントラクト実行コスト',
                'knowledge_gasStation_gameplay': 'ガス最適化装置は周囲の防御塔の攻撃速度を向上させ、トランザクションをより速く処理します。',
                
                'knowledge_contract_title': 'スマートコントラクト',
                'knowledge_contract_principle': 'ブロックチェーン上に展開された自動実行コード。条件が満たされると自動的に実行され、人間の介入は不要です。',
                'knowledge_contract_analogy': '自動販売機のようなもの：コイン投入→選択→自動配送、全て自動化されています。',
                'knowledge_contract_application': 'DeFiプロトコル、NFT取引、DAOガバナンス',
                'knowledge_contract_gameplay': 'スマートコントラクトタワーは範囲内の敵を自動検出して減速させ、透明ユニットを明らかにすることもできます。',
                
                'knowledge_sharding_title': 'シャーディング技術',
                'knowledge_sharding_principle': 'ブロックチェーンネットワークを複数のシャードに分割し、各シャードが異なるトランザクションを並行処理することで、スループットを大幅に向上させます。',
                'knowledge_sharding_analogy': 'スーパーマーケットが複数のレジを開設するようなもので、全員が1つの列に並ぶ必要がありません。',
                'knowledge_sharding_application': 'イーサリアム2.0シャーディング、Zilliqa、Near Protocol',
                'knowledge_sharding_gameplay': 'シャーディング砲は範囲攻撃を発射し、一度に複数のターゲットを処理し、並列処理の威力を示します。',
                
                'knowledge_zkSniper_title': 'ゼロ知識証明 (ZKP)',
                'knowledge_zkSniper_principle': '追加情報を明かすことなく、ある陳述が真実であることを証明します。',
                'knowledge_zkSniper_analogy': '具体的な年齢を教えずに成人であることを証明できるようなものです。',
                'knowledge_zkSniper_application': 'zkSNARK、zkSTARK、プライバシーコインZcash',
                'knowledge_zkSniper_gameplay': 'ZKスナイパーは透明化と混乱を「見抜く」ことができ、隠れたユニットに追加ダメージを与えます。',
                
                'knowledge_l2Channel_title': 'レイヤー2スケーリング',
                'knowledge_l2Channel_principle': 'メインチェーンの外で大量のトランザクションを処理し、最終結果のみをメインチェーンに提出することで、コストと遅延を削減します。',
                'knowledge_l2Channel_analogy': '友達とお金の貸し借りをするとき、毎回銀行に記録する必要がなく、最後に清算すればいいようなものです。',
                'knowledge_l2Channel_application': 'Lightning Network、Polygon、Arbitrum、Optimism',
                'knowledge_l2Channel_gameplay': 'L2チャネルは連続レーザーを発射し、高頻度低コストの持続ダメージを与えます。',
                
                'knowledge_mainnetCannon_title': 'ハードフォーク',
                'knowledge_mainnetCannon_principle': '旧バージョンと互換性のない、ブロックチェーンプロトコルの大きな変更。ネットワークを「再起動」するようなもので、最後の手段です。',
                'knowledge_mainnetCannon_analogy': 'OSの大規模アップグレードのようなもので、古いソフトウェアが動作しなくなる可能性があります。',
                'knowledge_mainnetCannon_application': 'ビットコインキャッシュフォーク、イーサリアムDAO事件後のフォーク',
                'knowledge_mainnetCannon_gameplay': 'メインネット砲は究極の武器で、BOSSの現在HPの30%を巨大ダメージとして与えますが、手動でターゲットを指定する必要があります。',
                
                // 知識カード - 敵
                'knowledge_spam_title': 'スパムトランザクション攻撃',
                'knowledge_spam_principle': '攻撃者が大量の無意味なトランザクションを送信してネットワークを詰まらせ、正常なトランザクションが処理されないようにします。',
                'knowledge_spam_analogy': '誰かが絶えずいたずら電話をかけて、カスタマーサービスラインを占有し、本当に助けが必要な人が電話できないようなものです。',
                'knowledge_spam_application': '2017年イーサリアムCryptoKitties混雑事件',
                'knowledge_spam_gameplay': '基本的な敵、数は多いがHPは低く、簡単に処理できます。',
                
                'knowledge_doublespend_title': '二重支払い攻撃',
                'knowledge_doublespend_principle': '攻撃者がハッシュパワーを制御したり、ネットワーク遅延を利用して、同じお金を2回使おうとします。',
                'knowledge_doublespend_analogy': '同じ偽札を2つの店で同時に使うようなものです。',
                'knowledge_doublespend_application': '51%攻撃、Race Attack、Finney Attack',
                'knowledge_doublespend_gameplay': '透明化しており、スマートコントラクトの真視能力またはZKスナイパーで明らかにする必要があります。',
                
                'knowledge_splitter_title': 'ダスト攻撃',
                'knowledge_splitter_principle': '攻撃者が微量の金額を送信して被害者のウォレットを「ダスト」で満たし、管理を困難にしてプライバシーを暴露します。',
                'knowledge_splitter_analogy': '誰かがあなたの玄関にゴミを捨てて、正常な出入りを妨げるようなものです。',
                'knowledge_splitter_application': 'ビットコインダスト攻撃、アドレス追跡',
                'knowledge_splitter_gameplay': '死亡時に3つの高速移動する小ユニットに分裂し、範囲攻撃で処理する必要があります。',
                
                'knowledge_armored_title': 'ミキシングサービス',
                'knowledge_armored_principle': 'トランザクションの送信元と送信先を混乱させ、資金の流れを追跡困難にします。',
                'knowledge_armored_analogy': 'あなたのお金を多くの人のお金と混ぜてシャッフルし、返却するので、どれがあなたのものか誰も分からないようなものです。',
                'knowledge_armored_application': 'Tornado Cash、CoinJoin、ミキサー',
                'knowledge_armored_gameplay': '50%のダメージ軽減を持ち、高ダメージまたはZKスナイパーの貫通攻撃が必要です。',
                
                'knowledge_vampire_title': '高頻度取引攻撃',
                'knowledge_vampire_principle': '極めて速いトランザクション速度を利用して先行実行し、価格変動から利益を得ます（フロントランニング、サンドイッチ攻撃）。',
                'knowledge_vampire_analogy': '誰かが0.1秒早く株価を知っていて、常にあなたより先に売買できるようなものです。',
                'knowledge_vampire_application': 'MEV（最大抽出可能価値）、サンドイッチ攻撃',
                'knowledge_vampire_gameplay': '継続的に回復するため、L2チャネルの持続ダメージで回復能力を抑制する必要があります。',
                
                'knowledge_boss_title': '51%攻撃',
                'knowledge_boss_principle': '攻撃者がネットワークハッシュパワーの50%以上を制御し、トランザクション記録を改ざんし、二重支払いを実行できます。',
                'knowledge_boss_analogy': '誰かが投票権の半数以上を制御し、投票結果を自由に変更できるようなものです。',
                'knowledge_boss_application': '小規模ブロックチェーンの51%攻撃事例（ETC、BTGなど）',
                'knowledge_boss_gameplay': '究極のBOSS、非常に高いHPとダメージ軽減を持ち、すべての高度なタワーの連携が必要で、メインネット砲が勝利の鍵です。',
                
                // 知識カード - ラベル
                'knowledge_label_principle': '原理',
                'knowledge_label_analogy': '類比',
                'knowledge_label_application': '応用',
                'knowledge_label_gameplay': 'ゲームメカニクス',
                'knowledge_label_principle_icon': '💡 原理：',
                'knowledge_label_gameplay_icon': '🎮 ゲームメカニクス：',
                'knowledge_ai_label': 'チェーンAI',
                
                // ヘルプ画面
                'help_screen_title': 'ブロックチェーン知識',
                'help_screen_subtitle': 'BLOCKCHAIN KNOWLEDGE',
                'tab_guide': '📖 操作ガイド',
                'tab_encyclopedia': '📚 ブロックチェーン百科',
                
                // ヘルプパネル内容 - ゲーム目標
                'help_goal_content_1': 'あなたの<span style="color:#00ffff">ブロック</span>を守れ！',
                'help_goal_content_2': '• <span style="color:#00ff88">緑のブロック</span> = 正当な取引 → <b>通す</b>',
                'help_goal_content_3': '• <span style="color:#ff0044">赤い敵</span> = 悪意のあるデータ → <b>排除</b>',
                'help_goal_content_4': '• パス入口の<span style="color:#ff0044">赤いアイコン</span>をクリックしてウェーブ開始',
                
                // ヘルプパネル - ホットキー
                'help_hotkey_x_title': 'X - 2倍速',
                'help_hotkey_x_desc': 'ゲーム速度切替（1倍 ↔ 2倍）',
                'help_hotkey_n_title': 'N - 次のウェーブ',
                'help_hotkey_n_desc': '準備時間をスキップ、すぐに次のウェーブを開始',
                'help_hotkey_esc_title': 'ESC / P - 一時停止',
                'help_hotkey_esc_desc': '一時停止メニューを開く',
                'help_hotkey_space_title': 'スペース - クイック一時停止',
                'help_hotkey_space_desc': '長押しで一時停止、離すと続行',
                'help_hotkey_w_title': 'W - クイックアップグレード',
                'help_hotkey_w_desc': '選択中のタワーをアップグレード',
                'help_hotkey_q_title': 'Q - クイック売却',
                'help_hotkey_q_desc': '選択中のタワーを売却',
                'help_hotkey_r_title': 'R - メインネット攻撃',
                'help_hotkey_r_desc': 'メインネット砲の照準モードを起動（メインネット砲が必要）',
                'help_hotkey_1to8_title': '1-8 - タワー選択',
                'help_hotkey_1to8_desc': '番号でタワーを素早く選択して配置',
                
                // ヘルプパネル - 操作説明
                'help_control_place_title': 'タワー配置',
                'help_control_place_desc': '下部のタワーアイコンをクリック → マップの空きスペースをクリック',
                'help_control_upgrade_title': 'タワーアップグレード',
                'help_control_upgrade_desc': '配置済みタワーをクリック → アップグレードボタンをクリック（最大Lv10）',
                'help_control_sell_title': 'タワー売却',
                'help_control_sell_desc': '配置済みタワーをクリック → 売却ボタンをクリック（70%返還）',
                'help_control_enemy_title': '敵情報表示',
                'help_control_enemy_desc': '敵をクリックして詳細なステータスと能力を表示',
                
                // ヘルプパネル - 防御塔詳細
                'help_tower_validator_title': '🔐 検証ノード - 非対称暗号化',
                'help_tower_validator_desc': '単体高ダメージ、序盤の主力。Lv10までアップグレード可能',
                'help_tower_validator_stats': 'コスト25 | 射程110 | ダメージ12 | 速度1.0s',
                'help_tower_validator_special': '⚡ 特効：スパム (1.2x-2.5x)',
                'help_tower_miner_title': '⛏️ マイナー - プルーフ・オブ・ワーク',
                'help_tower_miner_desc': '受動的収入建物。Lv10までアップグレード可能',
                'help_tower_miner_stats': 'コスト50 | 収入2 GAS/3s | 売却時90%返還',
                'help_tower_gas_title': '⛽ ガスステーション - ガス料金メカニズム',
                'help_tower_gas_desc': '範囲速度ブースト。Lv10までアップグレード可能',
                'help_tower_gas_stats': 'コスト45 | 範囲100 | ブースト25%-70%',
                'help_tower_contract_title': '📜 コントラクトゲート - スマートコントラクト',
                'help_tower_contract_desc': '範囲スロー+真視。Lv10までアップグレード可能',
                'help_tower_contract_stats': 'コスト65 | 範囲140 | スロー35%-80%',
                'help_tower_sharding_title': '💥 シャーディング砲 - シャーディング技術 [Lv2解放]',
                'help_tower_sharding_desc': 'AOE範囲ダメージ。Lv10までアップグレード可能',
                'help_tower_sharding_stats': 'コスト75 | 射程150 | AOEダメージ30',
                'help_tower_sharding_special': '💎 特効：分裂体 (1.2x-2.5x)',
                'help_tower_zk_title': '🎯 ZKスナイパー - ゼロ知識証明 [Lv3解放]',
                'help_tower_zk_desc': '超長射程。Lv10までアップグレード可能',
                'help_tower_zk_stats': 'コスト90 | 射程260 | ダメージ50',
                'help_tower_zk_special': '💥 特効：装甲/BOSS (1.5x-2.8x / 1.1x-2.0x)',
                'help_tower_l2_title': '⚡ L2チャネル - レイヤー2スケーリング [Lv4解放]',
                'help_tower_l2_desc': '連続レーザー。Lv10までアップグレード可能',
                'help_tower_l2_stats': 'コスト100 | 射程180 | ダメージ20/s',
                'help_tower_l2_special': '⚡ 特効：回復体 (1.2x-2.5x + 抑制40%-85%)',
                'help_tower_cannon_title': '☄️ メインネット砲 - ハードフォーク [Lv5解放]',
                'help_tower_cannon_desc': '手動爆撃、BOSS特効',
                'help_tower_cannon_stats': 'コスト80 | 使用150 GAS | AOEダメージ200',
                'help_tower_cannon_special': '💥 BOSSの現在HP30%ダメージ！',
                
                // ヘルプパネル - 敵タイプ
                'help_enemy_valid_title': '■ 正当な取引',
                'help_enemy_valid_desc': 'ブロックに入れよう！検証後+5 GAS報酬',
                
                // モンスター紹介カード
                'enemy_normal_name': '正当な取引',
                'enemy_spam_name': 'スパムウイルス',
                'enemy_doubleSpend_name': 'ダブルスペンドゴースト',
                'enemy_splitter_name': 'ダスト分裂体',
                'enemy_shielded_name': 'ミキサー装甲獣',
                'enemy_healer_name': 'HFTヴァンパイア',
                'enemy_boss_name': '51%ハッシュパワータイタン',
                'enemy_splitChild_name': 'フラグメント',
                'enemy_normal_desc': 'グリーンデータパケット - これは正常な取引で、ブロックにパックされる必要があります！',
                'enemy_normal_tip': '攻撃せず、安全にブロックに到達させてください。',
                'enemy_spam_desc': 'スパムデータウイルス - ネットワークを詰まらせようとする無効な取引！',
                'enemy_spam_tip': 'バリデーターノードで素早く清掃！',
                'enemy_doublespend_desc': '透明なダブルスペンド攻撃 - 同じお金を二度使おうとしています！',
                'enemy_doublespend_tip': 'スマートコントラクトゲートで正体を暴く必要があります！',
                'enemy_splitter_desc': 'ダスト攻撃キャリア - 死亡時に3つの高速移動する破片に分裂！',
                'enemy_splitter_tip': 'シャーディング砲は分裂体に追加ダメージ、AOE範囲で破片を一度に清掃可能！',
                'enemy_shielded_desc': 'ミキサーシールド - 50%ダメージ軽減！通常攻撃は半分のダメージのみ！',
                'enemy_shielded_tip': 'ZKスナイパーはシールドを貫通し、追加ダメージを与えます！',
                'enemy_healer_desc': '高頻度取引体 - 毎秒8 HP回復！素早く倒すか回復を抑制する必要があります！',
                'enemy_healer_tip': 'レイヤー2チャネルの持続レーザーで回復を抑制し、追加ダメージを与えられます！',
                'enemy_boss_desc': '51%攻撃巨獣 - ハッシュパワーの半分以上を制御！10000 HP、55%ダメージ軽減、毎秒3 HP再生！',
                'enemy_boss_tip': '高級タワーの組み合わせが必要！ZKスナイパーはBOSSに追加ダメージ！メインネット砲は現在HPの30%ダメージ、勝利の鍵！',
                'enemy_doubleSpend_desc': '透明なダブルスペンド攻撃 - 同じお金を二度使おうとしています！',
                'enemy_doubleSpend_tip': 'スマートコントラクトゲートで正体を暴く必要があります！',
                'help_enemy_spam_title': '🦠 スパムウイルス',
                'help_enemy_spam_desc': '速いが脆弱、報酬3 GAS',
                'help_enemy_double_title': '👻 ダブルスペンドゴースト [透明]',
                'help_enemy_double_desc': '透明ユニット、真視が必要',
                'help_enemy_splitter_title': '💎 ダストスプリッター [分裂]',
                'help_enemy_splitter_desc': '死亡時に3つの小ユニットに分裂',
                'help_enemy_shielded_title': '🛡️ ミキサービースト [ダメージ軽減]',
                'help_enemy_shielded_desc': '200 HP + 50%ダメージ軽減シールド',
                'help_enemy_shielded_counter': '対策：ZKスナイパー',
                'help_enemy_healer_title': '💚 HFTヴァンパイア [回復]',
                'help_enemy_healer_desc': '150 HP + 毎秒8 HP回復',
                'help_enemy_healer_counter': '対策：レイヤー2チャネル',
                'help_enemy_boss_title': '☠️ 51%ハッシュタイタン [BOSS]',
                'help_enemy_boss_desc': '10000 HP + 55%ダメージ軽減 + 3 HP/s再生',
                'help_enemy_boss_counter': '対策：メインネット砲 + ZKスナイパー',
                
                // ヘルプパネル - ゲームのコツ
                'help_tip_economy_title': '経済優先',
                'help_tip_economy_desc': '序盤は多くのマイナーを建設し、経済成長を確保',
                'help_tip_upgrade_title': 'アップグレード優先',
                'help_tip_upgrade_desc': 'アップグレードは約2倍のコスパ、コアタワーをLv10まで優先',
                'help_tip_priority_title': 'ターゲット優先度',
                'help_tip_priority_desc': 'タワーをクリックして設定：最初/最後/特効/最強/最弱/最近',
                'help_tip_combo_title': 'スマートコンボ',
                'help_tip_combo_desc': 'ガスステーション + コントラクトゲート + メインタワー = 完璧なコンボ',
                'help_tip_counter_title': '対策戦略',
                'help_tip_counter_desc': 'スパム→検証 | 装甲→ZKスナイパー | 分裂→シャーディング | 回復→L2チャネル',
                
                // ヘルプパネル - 学習モード
                'help_learn_card_title': '知識カード',
                'help_learn_card_desc': '各タワー解放時にブロックチェーン知識紹介を表示',
                'help_learn_story_title': 'ストーリーモード',
                'help_learn_story_desc': '各レベルにオープニングと勝利ストーリーがあり、ブロックチェーンの物語を学ぶ',
                
                // ストーリーボタン
                'story_btn_start': '守護開始！',
                'story_btn_deploy': '配置開始',
                'story_btn_continue': '続ける',
                'story_btn_final': '最終決戦',
                'story_btn_complete': 'ミッション完了',
                
                // 勝利画面
                'victory_title': 'ミッション完了！',
                'victory_subtitle': 'MISSION ACCOMPLISHED',
                'victory_ending_title': '📜 エンディング：ブロックチェーンガーディアン',
                'victory_story_1': '2045年、あなたの守護の下、ブロックチェーンネットワークは最も厳しい試練に耐えました。シンプルなトランザクション検証から51%攻撃の防御まで、すべての防御技術をマスターしました。',
                'victory_tech_1': '非対称暗号化がユーザーのアイデンティティを保護',
                'victory_tech_2': 'シャーディング技術がネットワーク拡張を実現',
                'victory_tech_3': 'ゼロ知識証明がプライバシーを保障',
                'victory_tech_4': 'Layer 2がトランザクション速度を向上',
                'victory_tech_5': '分散型コンセンサスが攻撃に抵抗',
                'victory_quote': '"しかし、これは終わりではありません...ブロックチェーンが存在する限り、脅威は常に存在します。<br>そしてあなたは、この分散型世界を守り続けるでしょう。"',
                'victory_thanks': 'BlockRushをプレイしていただきありがとうございます！',
                'victory_tagline': 'ゲームを通じてブロックチェーン技術を学ぶ 🚀',
                
                // 游戏界面UI
                'ui_speed_2x': '2倍速',
                'ui_hotkey_x': 'ホットキー: X',
                'ui_tower_menu': '折りたたむ',
                'ui_tower_validator': 'バリデーター',
                'ui_tower_miner': 'マイナー',
                'ui_tower_gas': 'ガスステーション',
                'ui_tower_contract': 'コントラクト',
                'ui_tower_sharding': 'シャーディング',
                'ui_tower_zk': 'ZKスナイパー',
                'ui_tower_l2': 'L2チャネル',
                'ui_tower_cannon': 'メインネット',
                
                // 帮助面板标题
                'help_title_goal': 'ゲーム目標',
                'help_title_hotkeys': 'ホットキー',
                'help_title_controls': '操作方法',
                'help_hotkey_x_title': '2倍速',
                'help_hotkey_n_title': '次の波',
                'help_hotkey_esc_title': '一時停止',
                'help_hotkey_space_title': 'クイック一時停止',
                'help_goal_content_2': '正当な取引 → 許可',
                'help_goal_content_3': '悪意のあるデータ → 破壊',
                'help_title_towers': '🗼 タワー一覧',
                'help_title_enemies': '👾 敵タイプ',
                'help_title_tips': '💡 ゲームのコツ',
                'help_title_learning': '📚 学習モード',
                
                // 帮助面板 - 学习模式
                'help_learn_library_title': 'ナレッジライブラリ',
                'help_learn_library_desc': 'レベル選択画面で「ナレッジライブラリ」をクリックして復習',
                
                // 开场故事
                'opening_title': 'デジタル世界の守護者',
                'opening_subtitle': 'ミッションブリーフィング / MISSION BRIEFING',
                'opening_content': '<span style="color:#00ffff">2045年</span>、人類社会は完全にデジタル化されました。<br>すべての取引は<span style="color:#00ffff">ブロックチェーン</span>という<span style="color:#00ffff">分散型</span>台帳を通じて検証・記録される必要があります。<br><br>しかし、<span style="color:#ff0044">ハッカー、詐欺師、悪意のあるプログラム</span>は攻撃を止めません...<br><br>あなたは<span style="color:#00ff88">ブロックチェーンセキュリティエンジニア</span>です。<br>あなたの使命：<span style="color:#00ffff">ブロックチェーン</span>ネットワークを守り、すべてのブロックに正当で安全な取引のみが含まれるようにすること。',
                'opening_mechanics_title': '▼ コアメカニクス / CORE MECHANICS ▼',
                'opening_mechanics_allow': '正当な取引 → 許可',
                'opening_mechanics_destroy': '悪意のある攻撃 → 排除',
                'mechanics_legitimate_data': '正当なデータ',
                'mechanics_malicious_attack': '悪意のある攻撃',
                'mechanics_pass': '>> PASS',
                'mechanics_kill': '>> KILL',
                
                // 链灵对话 - 第1关
                'dialogue_level1_intro_1': 'これは最も基本的な防御です！スパムトランザクションバグがネットワークを攻撃しています。',
                'dialogue_level1_intro_2': 'バリデーターノードを構築してクリアしますが、緑の正当な取引は通してください！',
                'dialogue_level1_victory_1': '素晴らしい！最初のトランザクションバッチを守ることに成功しました！',
                'dialogue_level1_victory_2': 'しかし、これは始まりに過ぎません...より強力な敵が来ています。',
                
                // 关卡介绍 - 第2关
                'level2_opening_title': 'スケーリング危機',
                'level2_opening_subtitle': 'レベル2：ネットワークスケーリング',
                'level2_opening_content': '<div style="text-align: left;"><strong>⚠️ 警報：ネットワーク極度の混雑！</strong><br><br>トランザクション量が <span style="color:#ff0044">100 倍</span> に激増、シングルチェーン処理が崩壊しました。<br><br><span style="color:#00ffff">[シャーディング技術 Sharding]</span> を起動する必要があります —— ネットワークを複数の並列ゾーンに分割し、大量のデータを同時に処理します。<br><br><strong>【現在の脅威】ダスト攻撃 (Dust Attack)</strong><br>敵は無数の小さなユニットに分裂し、「人海戦術」でノードを麻痺させようとしています。<br><br><strong>【戦術指令】</strong><br>通常武器では効率が低すぎます。<span style="color:#00ffff">[シャーディングキャノン]</span> を配置し、<span style="color:#ffd700">範囲攻撃 (AOE)</span> で一掃してください！</div>',
                'level2_victory_title': 'レベル2完了',
                'level2_victory_subtitle': 'ネットワーククリア',
                'level2_victory_content': 'ネットワークが復旧しました！トランザクション速度が10倍向上！\n\nしかし新たな脅威が現れました...\n誰かが「ミキサー」を使用してトランザクションソースを隠しています。\n\nより高度な技術で対応する必要があります...',
                
                // 链灵对话 - 第2关
                'dialogue_level2_intro_1': 'まずい！ダストスプリッターが現れました！',
                'dialogue_level2_intro_2': '死後3つの小さなユニットに分裂します...シャーディングプロセッサが必要です！',
                'dialogue_level2_victory_1': 'シャーディング技術は本当に効果的です！学習が早いですね！',
                
                // 关卡介绍 - 第3关
                'level3_opening_title': 'プライバシーバトル',
                'level3_opening_subtitle': 'レベル3：プライバシーと証明',
                'level3_opening_content': '<div style="text-align: left;">⚠️ 警報：「<span style="color: #ff6b6b;">ダブルスペンド攻撃</span>」(Double-Spend) を検出！<br><br>狡猾な敵が同じお金を二度使おうとし、暗号化の霧で <span style="color: #ff6b6b;">[ステルスモード]</span> に隠れています。通常の防御タワーでは目標をロックできません。<br><br><span style="color: #00ffff;">技術解放：ゼロ知識証明 (ZK-SNARKs)</span><br>「具体的な内容を知らなくても、真実を検証できる。」<br><br><span style="color: #ffd700;">戦術指令：</span><br>すぐに <span style="color: #00ffff;">[ZKスナイパータワー]</span> を配置！<span style="color: #ffd700;">真視 (True Sight)</span> 能力を持ち、すべてのステルスユニットの偽装を見破り、<span style="color: #ffd700;">致命的なクリティカル</span> を与えます！</div>',
                'level3_victory_title': 'レベル3完了',
                'level3_victory_subtitle': '真実が明らかに',
                'level3_victory_content': 'プライバシーとセキュリティのバランスを見つけました！\n\nしかしブロックチェーンには致命的な弱点があります：\nメインチェーンの処理速度が遅すぎ、手数料が高すぎます...\n\nLayer 2を導入する時が来ました！',
                
                // 链灵对话 - 第3关
                'dialogue_level3_intro_1': '注意！ダブルスペンドゴーストは透明化できます！',
                'dialogue_level3_intro_2': 'スマートコントラクトのトゥルーサイト、またはゼロ知識証明器の貫通攻撃を使用してください！',
                'dialogue_level3_victory_1': 'ゼロ知識証明の力...見えなくても、真実は検証できます！',
                
                // 关卡介绍 - 第4关
                'level4_opening_title': 'スピード革命',
                'level4_opening_subtitle': 'レベル4：ライトニングネットワーク',
                'level4_opening_content': '<div style="text-align: left;">⚠️ メインネット混雑警報：<span style="color: #ff6b6b;">Gas 費が天井知らず！</span><br><br>チェーン上の確認が遅すぎ、1回の手数料が数十ドルに達し、通常の防衛線は崩壊しました。<br><br><span style="color: #ff6b6b;">強敵遭遇：ヴァンパイアボット (Vampire Bot)</span><br><span style="color: #ff6b6b;">[持続回復]</span> メカニズムを持ち、通常の防御タワーのダメージより回復が速い！<br><br><span style="color: #00ffff;">技術アップグレード：ライトニングネットワーク (Lightning Network)</span><br>オフチェーン Layer 2 チャネルを構築し、ミリ秒レベルの取引を実現！<br><br><span style="color: #00ffff;">[L2 速射砲]</span> を配置し、その <span style="color: #ffd700;">超高攻撃速度</span> で形成される火力網で、敵の修復装甲を強制的に圧制し瓦解させてください！</div>',
                'level4_victory_title': 'レベル4完了',
                'level4_victory_subtitle': 'ライトニングスピード',
                'level4_victory_content': 'トランザクション速度が1000倍向上！手数料が99%削減！\n\nしかし最大の脅威はまだ先にあります...\n誰かがハッシュパワーを集結させ、51%攻撃を準備しています！\n\nこれがブロックチェーンの究極のテストです！',
                
                // 链灵对话 - 第4关
                'dialogue_level4_intro_1': 'ヴァンパイアボット！彼らは回復し続けます！',
                'dialogue_level4_intro_2': 'Layer 2チャネルの持続ダメージで回復能力を抑制してください！',
                'dialogue_level4_victory_1': 'Layer 2のスピード...これが未来です！',
                
                // 关卡介绍 - 第5关
                'level5_opening_title': '究極の脅威',
                'level5_opening_subtitle': 'レベル5：51%攻撃',
                'level5_opening_content': '<div style="text-align: left;"><strong style="color: #ff0000;">🟥 レッド最高警報：51% ハッシュパワー攻撃！</strong><br><br>攻撃者がネットワーク全体の <span style="color: #ff6b6b;">50% 以上のハッシュパワー</span> を制御し、<span style="color: #ff6b6b;">ブロックチェーン履歴の書き換え</span> を試みています。防衛線が崩壊すれば、すべての取引記録が改ざんされます！<br><br><strong style="color: #ff6b6b;">⚠️ 戦場突変：デュアルチャネル侵入</strong><br>敵は <span style="color: #ff6b6b;">2つの入口</span> から同時に猛攻を仕掛け、防衛圧力が倍増！<br><br><span style="color: #00ffff;">究極プロトコル解放：ハードフォーク (Hard Fork)</span><br>通常の手段は無効です。<span style="color: #00ffff;">[メインネットキャノン]</span> を起動し、悪意のあるハッシュパワーを強制的に剥離する必要があります！これは BOSS に対抗する唯一の手段で、<span style="color: #ffd700;">壊滅的な打撃</span> を与えられます。<br><br><strong>これが最後の戦い、創世ブロックを死守せよ！</strong></div>',
                'level5_victory_title': 'レベル5完了',
                'level5_victory_subtitle': 'コンセンサス保護',
                'level5_victory_content': '51%攻撃を撃退しました！ブロックチェーンは安全です！\n\nトランザクション検証から51%攻撃の防御まで、\nすべての防御技術をマスターしました。\n\n非対称暗号化がユーザーのアイデンティティを保護し、\nプルーフオブワークがネットワークを保護し、\nシャーディングが処理速度を向上させ、\nゼロ知識証明がプライバシーと透明性のバランスを取り、\nLayer 2がブロックチェーンを真に使えるものにしました。\n\nあなたは真のブロックチェーンガーディアンです！',
                
                // 链灵对话 - 第5关
                'dialogue_level5_intro_1': '警報！51%攻撃BOSSが来ました！',
                'dialogue_level5_intro_2': 'これは究極のテストです...すべての防御技術を使用し、必要に応じてメインネットキャノンを起動してください！',
                'dialogue_level5_victory_1': 'やりました！ブロックチェーンは安全です！',
                'dialogue_level5_victory_2': 'あなたは真のブロックチェーンガーディアンです！',
                
                // 对话界面
                'character_chain_spirit': 'チェーンスピリット',
                'dialogue_continue': 'クリックして続行 ▼',
                
                // 关卡介绍 - 第1关
                'level1_opening_title': '第一防衛線',
                'level1_opening_subtitle': 'レベル1：トランザクション検証',
                'level1_opening_content': '<div style="text-align: left;"><strong>【現在位置】</strong><br><span style="color: #00ffff;">トランザクションプール (Mempool)</span><br><br><strong>【任務概要】</strong><br>すべてのトランザクションはオンチェーン前にここでキューに入ります。あなたは<span style="color: #00ffff;">第一防衛線</span>であり、<span style="color: #ff6b6b;">スパムトランザクション</span>がネットワークを詰まらせるのを防ぐ必要があります。<br><br><strong>【実行命令】</strong><br>施設配置：<span style="color: #00ffff;">公開鍵バリデーター</span><br>コアメカニズム：<span style="color: #ffd700;">デジタル署名をチェック</span>（銀行IDの確認のように）<br><br><strong>【警戒対象】</strong><br><span style="color: #ff6b6b;">スパムトランザクション / 悪意のある攻撃</span></div>',
                'level1_victory_title': 'レベル1完了',
                'level1_victory_subtitle': '防衛線確保',
                'level1_victory_content': 'よくやった！最初のトランザクションバッチの検証に成功しました。\n\nしかし、これは始まりに過ぎません...\nブロックチェーンがより人気になるにつれ、トランザクション量が急増し、\n単純な検証だけでは不十分になりました。\n\nより強力な技術が必要です...'
            }
        };
        
        // 当前语言设置
        let currentLanguage = localStorage.getItem('gameLanguage') || 'zh-CN';
        
        // 语言配置
        const languageConfig = {
            'zh-CN': { flag: '🇨🇳', name: '中文' },
            'en-US': { flag: '🇺🇸', name: 'English' },
            'ja-JP': { flag: '🇯🇵', name: '日本語' }
        };
        
        // 获取文本函数
        function getText(key, ...args) {
            let text = i18nData[currentLanguage]?.[key] || i18nData['zh-CN']?.[key] || key;
            
            // 简单的字符串格式化：{0}, {1}, {2}...
            if (args.length > 0) {
                args.forEach((arg, index) => {
                    text = text.replace(new RegExp(`\\{${index}\\}`, 'g'), arg);
                });
            }
            
            return text;
        }
        
        // 更新所有文本
        function updateAllTexts() {
            // 更新所有带有 data-i18n 属性的元素
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                const text = getText(key);
                
                // 如果文本包含HTML标签，使用innerHTML，否则使用textContent
                if (text.includes('<br>') || text.includes('<')) {
                    element.innerHTML = text;
                } else {
                    element.textContent = text;
                }
            });
            
            // 更新动态生成的内容
            updateDynamicTexts();
            
            // 更新语言选择器显示
            updateLanguageSelector();
            
            // 更新HTML lang属性
            document.documentElement.lang = currentLanguage;
        }
        
        // 更新动态生成的文本内容
        function updateDynamicTexts() {
            // 更新关卡卡片的解锁状态
            if (typeof updateLevelCards === 'function') {
                updateLevelCards();
            }
            
            // 始终更新知识库内容（即使不可见）
            if (typeof renderKnowledgeLibrary === 'function') {
                renderKnowledgeLibrary();
            }
            
            // 更新当前难度显示
            if (typeof gameState !== 'undefined' && gameState.difficulty) {
                const difficultyKey = 'difficulty_' + gameState.difficulty + '_short';
                const difficultyTextElement = document.getElementById('currentDifficultyText');
                if (difficultyTextElement) {
                    difficultyTextElement.textContent = getText(difficultyKey);
                }
            }
            
            // 更新通关条件提示
            const victoryTipElement = document.getElementById('victoryTipText');
            if (victoryTipElement) {
                victoryTipElement.innerHTML = getText('level_select_victory_tip');
            }
            
            // 更新游戏中的关卡名称滚动
            if (typeof gameState !== 'undefined' && gameState.level && document.getElementById('gameUI').style.display !== 'none') {
                updateLevelNameScroll();
            }
        }
        
        // 更新关卡名称滚动状态
        function updateLevelNameScroll() {
            const levelNameElement = document.getElementById('levelName');
            if (!levelNameElement) return;
            
            const levelKey = `level_${gameState.level}_name`;
            const levelText = getText(levelKey);
            
            // 完全重置元素状态
            levelNameElement.style.animation = 'none';
            levelNameElement.textContent = levelText;
            
            // 强制重排以确保样式生效
            void levelNameElement.offsetWidth;
            
            // 检查文本是否溢出
            requestAnimationFrame(() => {
                const container = levelNameElement.parentElement;
                const elementWidth = levelNameElement.scrollWidth;
                const containerWidth = container.clientWidth;
                
                if (elementWidth > containerWidth) {
                    // 文本溢出，启用滚动
                    levelNameElement.textContent = levelText + '   ' + levelText;
                    levelNameElement.style.animation = 'scrollText 10s linear infinite';
                }
            });
        }
        
        // 更新语言选择器显示
        function updateLanguageSelector() {
            const config = languageConfig[currentLanguage];
            if (config) {
                document.getElementById('currentLanguageFlag').textContent = config.flag;
                document.getElementById('currentLanguageText').textContent = config.name;
            }
        }
        
        // 显示/隐藏语言选择器
        function showLanguageSelector() {
            const selector = document.getElementById('languageSelector');
            if (selector) {
                selector.style.display = 'block';
                selector.style.visibility = 'visible';
                selector.style.opacity = '1';
                console.log('Language selector shown');
            } else {
                console.error('Language selector element not found!');
            }
        }
        
        function hideLanguageSelector() {
            const selector = document.getElementById('languageSelector');
            if (selector) {
                selector.style.display = 'none';
                console.log('Language selector hidden');
                // 同时关闭下拉菜单
                const dropdown = document.getElementById('languageDropdown');
                const btn = document.getElementById('currentLanguageBtn');
                if (dropdown) dropdown.style.display = 'none';
                if (btn) btn.classList.remove('active');
            }
        }
        
        // 切换语言下拉菜单
        function toggleLanguageDropdown() {
            // 尝试主界面的语言选择器
            const dropdown = document.getElementById('languageDropdown');
            const btn = document.getElementById('currentLanguageBtn');
            
            // 尝试选关界面的语言选择器
            const levelSelectDropdown = document.getElementById('levelSelectLanguageDropdown');
            const levelSelectBtn = document.getElementById('levelSelectLanguageBtn');
            
            // 如果主界面的语言选择器存在且可见
            if (dropdown && btn) {
                if (dropdown.style.display === 'none') {
                    dropdown.style.display = 'block';
                    btn.classList.add('active');
                } else {
                    dropdown.style.display = 'none';
                    btn.classList.remove('active');
                }
            }
            
            // 如果选关界面的语言选择器存在且可见
            if (levelSelectDropdown && levelSelectBtn) {
                if (levelSelectDropdown.style.display === 'none') {
                    levelSelectDropdown.style.display = 'block';
                    levelSelectBtn.classList.add('active');
                } else {
                    levelSelectDropdown.style.display = 'none';
                    levelSelectBtn.classList.remove('active');
                }
            }
        }
        
        // 更改语言
        function changeLanguage(lang) {
            if (lang !== currentLanguage) {
                currentLanguage = lang;
                localStorage.setItem('gameLanguage', lang);
                updateAllTexts();
                
                // 播放UI音效
                if (typeof sound !== 'undefined') {
                    sound.uiClick();
                }
            }
            
            // 关闭所有下拉菜单
            const dropdown = document.getElementById('languageDropdown');
            const btn = document.getElementById('currentLanguageBtn');
            const levelSelectDropdown = document.getElementById('levelSelectLanguageDropdown');
            const levelSelectBtn = document.getElementById('levelSelectLanguageBtn');
            
            if (dropdown) dropdown.style.display = 'none';
            if (btn) btn.classList.remove('active');
            if (levelSelectDropdown) levelSelectDropdown.style.display = 'none';
            if (levelSelectBtn) levelSelectBtn.classList.remove('active');
        }
        
        // 点击外部关闭下拉菜单
        document.addEventListener('click', function(event) {
            const selector = document.getElementById('languageSelector');
            const levelSelectScreen = document.getElementById('levelSelectScreen');
            
            // 关闭主界面的语言选择器
            if (selector && !selector.contains(event.target)) {
                const dropdown = document.getElementById('languageDropdown');
                const btn = document.getElementById('currentLanguageBtn');
                if (dropdown) dropdown.style.display = 'none';
                if (btn) btn.classList.remove('active');
            }
            
            // 关闭选关界面的语言选择器
            const levelSelectBtn = document.getElementById('levelSelectLanguageBtn');
            const levelSelectDropdown = document.getElementById('levelSelectLanguageDropdown');
            if (levelSelectBtn && levelSelectDropdown && !event.target.closest('.language-dropdown')) {
                levelSelectDropdown.style.display = 'none';
                levelSelectBtn.classList.remove('active');
            }
        });
        
        // 页面加载时初始化语言
        document.addEventListener('DOMContentLoaded', function() {
            updateAllTexts();
            // 确保在主界面显示语言选择器
            showLanguageSelector();
        });
        
        // ==================== SOUND SYSTEM ====================
        class SoundSystem {
            constructor() {
                this.audioCtx = null;
                this.masterVolume = 0.3;
                this.enabled = true;
                this.initialized = false;
                this.bgmGain = null;
                this.bgmTimer = null;
                this.bgmPlaying = false;
                this.bgmVolume = 0.15;
            }
            
            init() {
                if (this.initialized) return;
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    this.bgmGain = this.audioCtx.createGain();
                    this.bgmGain.connect(this.audioCtx.destination);
                    this.bgmGain.gain.value = this.bgmVolume;
                    this.initialized = true;
                } catch (e) {
                    this.enabled = false;
                }
            }
            
            stopBgm() {
                this.bgmPlaying = false;
                if (this.bgmTimer) {
                    clearTimeout(this.bgmTimer);
                    this.bgmTimer = null;
                }
            }
            
            playBgm(level) {
                if (!this.enabled || !this.audioCtx) return;
                this.stopBgm();
                this.bgmPlaying = true;
                
                // 每关完全不同的电音风格 - 更长的循环
                const configs = {
                    1: { // House风格 - 轻快舞曲 (32拍循环)
                        melody: [
                            523, 659, 784, 1047, 784, 659, 523, 659,
                            523, 659, 784, 1047, 1175, 1047, 784, 659,
                            659, 784, 880, 1047, 880, 784, 659, 523,
                            523, 659, 784, 659, 523, 392, 523, 659
                        ],
                        bass: [131, 131, 165, 165, 196, 196, 165, 131, 131, 165, 196, 165, 131, 131, 165, 165],
                        tempo: 0.125,
                        leadType: 'sawtooth',
                        bassPattern: [1, 0, 1, 0, 1, 0, 1, 0],
                        kickPattern: [1, 0, 1, 0, 1, 0, 1, 0],
                        hihatPattern: [0, 1, 0, 1, 0, 1, 0, 1]
                    },
                    2: { // Dubstep风格 - 重低音 (24拍循环)
                        melody: [
                            440, 440, 523, 523, 659, 659, 523, 440,
                            440, 523, 659, 784, 659, 523, 440, 392,
                            440, 440, 523, 659, 523, 440, 392, 440
                        ],
                        bass: [
                            110, 110, 110, 117, 110, 110, 110, 117,
                            110, 117, 123, 117, 110, 110, 98, 110,
                            110, 110, 117, 110, 110, 98, 110, 110
                        ],
                        tempo: 0.2,
                        leadType: 'square',
                        bassPattern: [1, 1, 0, 1, 1, 0, 1, 1],
                        kickPattern: [1, 0, 0, 1, 0, 0, 1, 0],
                        wobble: true
                    },
                    3: { // Trance风格 - 迷幻上升 (32拍循环)
                        melody: [
                            587, 698, 784, 880, 988, 1047, 1175, 1319,
                            1175, 1047, 988, 880, 784, 698, 587, 523,
                            587, 698, 784, 880, 988, 1047, 1175, 1319,
                            1568, 1319, 1175, 1047, 988, 880, 784, 698
                        ],
                        bass: [147, 147, 147, 147, 175, 175, 175, 175, 196, 196, 196, 196, 175, 175, 147, 147],
                        tempo: 0.1,
                        leadType: 'sine',
                        bassPattern: [1, 0, 0, 0, 1, 0, 0, 0],
                        kickPattern: [1, 0, 0, 0, 1, 0, 0, 0],
                        arpeggio: true
                    },
                    4: { // Drum & Bass风格 - 快速断奏 (40拍循环)
                        melody: [
                            659, 784, 880, 784, 659, 587, 659, 784,
                            880, 988, 1047, 988, 880, 784, 659, 587,
                            659, 784, 880, 1047, 880, 784, 659, 523,
                            587, 659, 784, 880, 784, 659, 587, 523,
                            659, 784, 880, 988, 880, 784, 659, 587
                        ],
                        bass: [
                            165, 165, 196, 196, 220, 220, 196, 165,
                            165, 196, 220, 196, 165, 165, 147, 165,
                            165, 196, 220, 196, 165, 147, 165, 165,
                            165, 196, 196, 165, 165, 147, 165, 165,
                            165, 196, 220, 196, 165, 165, 147, 165
                        ],
                        tempo: 0.08,
                        leadType: 'sawtooth',
                        bassPattern: [1, 0, 1, 1, 1, 0, 1, 0],
                        kickPattern: [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0],
                        snarePattern: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]
                    },
                    5: { // Epic Electro风格 - 史诗电音 (48拍循环)
                        melody: [
                            523, 659, 784, 880, 1047, 1175, 1319, 1568,
                            1319, 1175, 1047, 880, 784, 659, 523, 659,
                            784, 880, 1047, 1175, 1319, 1568, 1760, 1568,
                            1319, 1175, 1047, 880, 784, 659, 523, 392,
                            523, 659, 784, 880, 1047, 1175, 1319, 1568,
                            1760, 1568, 1319, 1175, 1047, 880, 784, 1047
                        ],
                        bass: [
                            131, 165, 196, 220, 196, 165, 131, 165,
                            196, 220, 247, 220, 196, 165, 131, 165,
                            196, 220, 247, 262, 247, 220, 196, 165,
                            131, 165, 196, 220, 196, 165, 131, 98,
                            131, 165, 196, 220, 247, 262, 294, 262,
                            247, 220, 196, 165, 131, 165, 196, 220
                        ],
                        tempo: 0.15,
                        leadType: 'sawtooth',
                        bassPattern: [1, 1, 1, 1, 1, 1, 1, 1],
                        kickPattern: [1, 0, 1, 0, 1, 0, 1, 0],
                        epicChords: true
                    }
                };
                
                const config = configs[level] || configs[1];
                let beatIndex = 0;
                
                const playBeat = () => {
                    if (!this.bgmPlaying || !this.enabled || !this.audioCtx) return;
                    
                    const now = this.audioCtx.currentTime;
                    const melodyIdx = beatIndex % config.melody.length;
                    const bassIdx = beatIndex % config.bass.length;
                    const kickIdx = beatIndex % config.kickPattern.length;
                    
                    // 主旋律
                    const lead = this.audioCtx.createOscillator();
                    const leadGain = this.audioCtx.createGain();
                    const leadFilter = this.audioCtx.createBiquadFilter();
                    lead.connect(leadFilter);
                    leadFilter.connect(leadGain);
                    leadGain.connect(this.bgmGain);
                    lead.type = config.leadType;
                    lead.frequency.value = config.melody[melodyIdx];
                    leadFilter.type = 'lowpass';
                    leadFilter.frequency.value = config.arpeggio ? 3000 + Math.sin(beatIndex * 0.5) * 1000 : 2000;
                    leadGain.gain.setValueAtTime(0.2, now);
                    leadGain.gain.exponentialRampToValueAtTime(0.01, now + config.tempo * 0.8);
                    lead.start(now);
                    lead.stop(now + config.tempo);
                    
                    // 低音
                    if (config.bassPattern[bassIdx % config.bassPattern.length]) {
                        const bass = this.audioCtx.createOscillator();
                        const bassGain = this.audioCtx.createGain();
                        bass.connect(bassGain);
                        bassGain.connect(this.bgmGain);
                        bass.type = 'sine';
                        bass.frequency.value = config.bass[bassIdx];
                        if (config.wobble) {
                            bass.frequency.setValueAtTime(config.bass[bassIdx], now);
                            bass.frequency.exponentialRampToValueAtTime(config.bass[bassIdx] * 0.7, now + config.tempo * 0.5);
                        }
                        bassGain.gain.setValueAtTime(0.4, now);
                        bassGain.gain.exponentialRampToValueAtTime(0.01, now + config.tempo * 0.6);
                        bass.start(now);
                        bass.stop(now + config.tempo * 0.6);
                    }
                    
                    // Kick鼓
                    if (config.kickPattern[kickIdx]) {
                        const kick = this.audioCtx.createOscillator();
                        const kickGain = this.audioCtx.createGain();
                        kick.connect(kickGain);
                        kickGain.connect(this.bgmGain);
                        kick.type = 'sine';
                        kick.frequency.setValueAtTime(150, now);
                        kick.frequency.exponentialRampToValueAtTime(40, now + 0.05);
                        kickGain.gain.setValueAtTime(0.5, now);
                        kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        kick.start(now);
                        kick.stop(now + 0.1);
                    }
                    
                    // Hi-hat
                    if (config.hihatPattern && config.hihatPattern[kickIdx % config.hihatPattern.length]) {
                        const bufferSize = this.audioCtx.sampleRate * 0.03;
                        const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                        const hihat = this.audioCtx.createBufferSource();
                        const hihatGain = this.audioCtx.createGain();
                        const hihatFilter = this.audioCtx.createBiquadFilter();
                        hihat.buffer = buffer;
                        hihat.connect(hihatFilter);
                        hihatFilter.connect(hihatGain);
                        hihatGain.connect(this.bgmGain);
                        hihatFilter.type = 'highpass';
                        hihatFilter.frequency.value = 8000;
                        hihatGain.gain.setValueAtTime(0.1, now);
                        hihatGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                        hihat.start(now);
                    }
                    
                    // Snare (for DnB)
                    if (config.snarePattern && config.snarePattern[kickIdx % config.snarePattern.length]) {
                        const bufferSize = this.audioCtx.sampleRate * 0.08;
                        const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                        const snare = this.audioCtx.createBufferSource();
                        const snareGain = this.audioCtx.createGain();
                        snare.buffer = buffer;
                        snare.connect(snareGain);
                        snareGain.connect(this.bgmGain);
                        snareGain.gain.setValueAtTime(0.3, now);
                        snareGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        snare.start(now);
                    }
                    
                    // Epic和弦 (for level 5)
                    if (config.epicChords && melodyIdx % 4 === 0) {
                        [1, 1.25, 1.5].forEach((mult, i) => {
                            const chord = this.audioCtx.createOscillator();
                            const chordGain = this.audioCtx.createGain();
                            chord.connect(chordGain);
                            chordGain.connect(this.bgmGain);
                            chord.type = 'triangle';
                            chord.frequency.value = config.melody[melodyIdx] * mult;
                            chordGain.gain.setValueAtTime(0.08, now);
                            chordGain.gain.exponentialRampToValueAtTime(0.01, now + config.tempo * 4);
                            chord.start(now);
                            chord.stop(now + config.tempo * 4);
                        });
                    }
                    
                    beatIndex++;
                    this.bgmTimer = setTimeout(playBeat, config.tempo * 1000);
                };
                
                playBeat();
            }
            
            playTone(frequency, duration, type = 'square', volume = 0.3) {
                if (!this.enabled || !this.audioCtx) return;
                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                osc.connect(gain);
                gain.connect(this.audioCtx.destination);
                osc.type = type;
                osc.frequency.setValueAtTime(frequency, this.audioCtx.currentTime);
                gain.gain.setValueAtTime(volume * this.masterVolume, this.audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration);
                osc.start(this.audioCtx.currentTime);
                osc.stop(this.audioCtx.currentTime + duration);
            }
            
            playNoise(duration, volume = 0.3) {
                if (!this.enabled || !this.audioCtx) return;
                const bufferSize = this.audioCtx.sampleRate * duration;
                const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.audioCtx.createBufferSource();
                const gain = this.audioCtx.createGain();
                noise.buffer = buffer;
                noise.connect(gain);
                gain.connect(this.audioCtx.destination);
                gain.gain.setValueAtTime(volume * this.masterVolume, this.audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration);
                noise.start();
                noise.stop(this.audioCtx.currentTime + duration);
            }
            
            towerPlace() { this.playTone(800, 0.1, 'square', 0.2); setTimeout(() => this.playTone(1200, 0.15, 'sine', 0.2), 50); }
            towerSell() { this.playTone(1200, 0.1, 'sine', 0.2); setTimeout(() => this.playTone(600, 0.15, 'sine', 0.1), 80); }
            towerError() { this.playTone(200, 0.15, 'square', 0.3); }
            attackValidator() { this.playTone(2000, 0.05, 'square', 0.15); }
            attackMiner() { this.playTone(150, 0.3, 'sawtooth', 0.25); }
            attackContract() { this.playTone(800, 0.1, 'sine', 0.2); this.playTone(600, 0.15, 'sine', 0.15); }
            attackSharding() { this.playTone(400, 0.2, 'sawtooth', 0.3); this.playNoise(0.15, 0.2); }
            attackZK() { this.playTone(2500, 0.3, 'sine', 0.25); }
            attackL2() { this.playTone(1000, 0.05, 'sawtooth', 0.15); }
            attackMainnet() { this.playNoise(0.5, 0.4); this.playTone(100, 0.5, 'sawtooth', 0.35); }
            enemyHit() { this.playTone(300, 0.05, 'square', 0.15); }
            enemyDeath() { this.playNoise(0.15, 0.25); this.playTone(200, 0.1, 'square', 0.2); }
            bossDeath() { this.playNoise(0.4, 0.35); this.playTone(80, 0.3, 'sawtooth', 0.3); }
            txValid() { this.playTone(600, 0.1, 'sine', 0.2); setTimeout(() => this.playTone(1000, 0.15, 'sine', 0.2), 80); }
            waveStart() { this.playTone(400, 0.15, 'square', 0.25); setTimeout(() => this.playTone(800, 0.3, 'sawtooth', 0.25), 300); }
            newEnemy() { this.playTone(600, 0.1, 'square', 0.2); setTimeout(() => this.playTone(1000, 0.15, 'sawtooth', 0.25), 100); }
            waveComplete() { [523, 659, 784, 1047].forEach((freq, i) => setTimeout(() => this.playTone(freq, 0.2, 'sine', 0.2), i * 100)); }
            gameOver() { this.playTone(400, 0.3, 'sawtooth', 0.3); setTimeout(() => this.playTone(100, 0.6, 'sawtooth', 0.25), 400); }
            victory() { [523, 659, 784, 880, 1047].forEach((freq, i) => setTimeout(() => this.playTone(freq, 0.15, 'sine', 0.25), i * 80)); }
            uiClick() { this.playTone(1000, 0.05, 'square', 0.15); }
            modalOpen() { this.playTone(800, 0.1, 'sine', 0.25); this.playTone(1200, 0.15, 'sine', 0.2); }
        }
        
        const sound = new SoundSystem();
        
        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ==================== GAME STATE ====================
        // 全局已显示的敌人类型（不会重置）
        let globalShownEnemyTypes = new Set();
        
        let gameState = {
            running: false,
            paused: false,
            spacePaused: false,
            modalPaused: false,
            difficulty: 'normal', // 难度：easy(49%), normal(70%), hard(100%)
            balance: 150,
            blockHeight: 1024,
            level: null, // 初始为null，表示还没有选择关卡
            currentWave: 0,
            totalWaves: 0,
            txCount: 0,
            txRequired: 8,
            lives: 1, // 当前生命值
            maxLives: 1, // 最大生命值
            enemies: [],
            towers: [],
            projectiles: [],
            particles: [],
            floatingTexts: [],
            laserBeams: [],
            path: [],
            gridSize: 50,
            selectedTower: null,
            selectedPlacedTower: null,
            selectedEnemy: null,
            mouseX: 0,
            mouseY: 0,
            waveInProgress: false,
            wavePreparation: false,
            preparationTimer: 0,
            enemiesSpawned: 0,
            spawnTimer: 0,
            currentWaveEnemies: [],
            gameOver: false,
            victory: false,
            unlockedTowers: ['validator', 'miner', 'gasStation', 'contract'],
            cannonTargetMode: false,
            selectedCannon: null,
            gameSpeed: 1 // 游戏速度倍率：1 = 正常，2 = 二倍速
        };
        
        // ==================== 塔名称系统 ====================
        function getTowerName(towerType, level = 1) {
            // 使用多语言系统
            let lvKey;
            if (towerType === 'mainnetCannon') {
                lvKey = 'tower_mainnetCannon';
            } else {
                if (level <= 3) {
                    lvKey = `tower_${towerType}_lv1`;
                } else if (level <= 6) {
                    lvKey = `tower_${towerType}_lv2`;
                } else {
                    lvKey = `tower_${towerType}_lv3`;
                }
            }
            
            return getText(lvKey) || towerDefs[towerType]?.name || towerType;
        }
        
        // ==================== TOWER DEFINITIONS ====================
        const towerDefs = {
            validator: {
                name: '验证节点',
                names: {
                    lv1: '验证节点',
                    lv2: '共识节点', 
                    lv3: '主验证者'
                },
                cost: 25, range: 110, damage: 12, attackSpeed: 1.0,
                color: '#00ffff',
                description: '单体高伤，前期主力。可升级4次',
                knowledge: '非对称加密、签名验证',
                unlockLevel: 1
            },
            miner: {
                name: '矿池',
                names: {
                    lv1: '矿池',
                    lv2: '大型矿场',
                    lv3: '算力中心'
                },
                cost: 50, range: 0, damage: 0, attackSpeed: 0,
                color: '#ff8800',
                description: '被动收入建筑。升级提升收益',
                knowledge: 'PoW工作量证明 - 挖矿产生收益',
                unlockLevel: 1,
                isMiner: true,
                miningInterval: 3000, // 每3秒产钱
                miningReward: 2 // Lv1每次产2 GAS
            },
            gasStation: {
                name: 'Gas优化器',
                names: {
                    lv1: 'Gas优化器',
                    lv2: 'MEV提取器',
                    lv3: '区块打包器'
                },
                cost: 45, range: 100, damage: 5, attackSpeed: 0.6,
                color: '#00ff88',
                description: '群体减速控制。升级提升减速效果',
                knowledge: 'Gas Fee激励机制',
                unlockLevel: 1,
                speedBoost: 0.25 // Lv1减速25%
            },
            contract: {
                name: '智能合约',
                names: {
                    lv1: '智能合约',
                    lv2: 'DApp守卫',
                    lv3: '协议执行者'
                },
                cost: 65, range: 140, damage: 0, attackSpeed: 0,
                color: '#aa00ff',
                description: '范围减速+真视。升级扩大范围',
                knowledge: '代码逻辑判断 (If-Else)',
                unlockLevel: 1,
                isAura: true,
                slowFactor: 0.65, // Lv1减速35%
                truesightRange: 100
            },
            sharding: {
                name: '分片处理器',
                names: {
                    lv1: '分片处理器',
                    lv2: '并行执行器',
                    lv3: '分片协调者'
                },
                cost: 75, range: 150, damage: 30, attackSpeed: 1.8,
                color: '#0088ff',
                aoeRadius: 85,
                description: '范围AOE伤害。对分裂怪有特效',
                knowledge: '分片技术 (Sharding) - 并行处理',
                unlockLevel: 2
            },
            zkSniper: {
                name: '零知识证明器',
                names: {
                    lv1: '零知识证明器',
                    lv2: 'ZK卷叠',
                    lv3: 'ZK终极证明'
                },
                cost: 90, range: 260, damage: 50, attackSpeed: 2.0,
                color: '#ff00aa',
                piercing: true,
                truesight: true, // 自带真视，可以攻击隐身单位
                description: '超远狙击，无视护盾。对装甲怪和BOSS有特效',
                knowledge: '零知识证明 (ZKP) - 精准验证',
                unlockLevel: 3
            },
            l2Channel: {
                name: '二层网络桥',
                names: {
                    lv1: '二层网络桥',
                    lv2: '卷叠聚合器',
                    lv3: '跨链中继'
                },
                cost: 100, range: 180, damage: 20, attackSpeed: 0,
                color: '#ffcc00',
                isLaser: true,
                laserDuration: 3000, // Lv1激光持续3秒
                laserCooldown: 1000,
                description: '持续激光输出。对回血怪有特效',
                knowledge: 'Layer 2 状态通道 - 高速处理',
                unlockLevel: 4
            },
            mainnetCannon: {
                name: '主网炮台',
                names: {
                    lv1: '主网炮台',
                    lv2: '最终确认器',
                    lv3: '创世炮'
                },
                cost: 80, range: 0, damage: 200, attackSpeed: 0,
                color: '#ff4400',
                isManual: true,
                fireCost: 150,
                aoeRadius: 150,
                description: '手动轰炸，消耗150 GAS。限制1个/关卡，无法出售',
                knowledge: '硬分叉 (Hard Fork) - 最后手段',
                unlockLevel: 5
            }
        };
        
        // ==================== ENEMY DEFINITIONS ====================
        const enemyDefs = {
            normal: {
                hp: 50, speed: 1.0, reward: 3, color: '#00ff88',
                isEvil: false, name: '合法交易', size: 15,
                icon: '📦',
                description: '绿色数据包 - 这是正常的交易，需要被打包进区块！',
                tip: '不要攻击它们，让它们安全到达区块。',
                hpGrowth: 0.15  // 每波生命增长15%
            },
            spam: {
                hp: 30, speed: 1.5, reward: 2, color: '#ff0044',
                isEvil: true, name: '垃圾交易虫', size: 12,
                icon: '🦠',
                description: '垃圾数据病毒 - 试图堵塞网络的无效交易！',
                tip: '用验证节点快速清理！',
                hpGrowth: 0.12
            },
            doubleSpend: {
                hp: 70, speed: 1.2, reward: 7, color: '#ff00ff',
                isEvil: true, name: '双花幽灵', size: 18, invisible: true,
                icon: '👻',
                description: '隐形的双花攻击 - 试图把同一笔钱花两次！',
                tip: '需要智能合约门来揭露它的真身！',
                hpGrowth: 0.16,
                canBeRevealed: true  // 可以被真视显形
            },
            splitter: {
                hp: 130, speed: 0.9, reward: 6, color: '#00aaff',
                isEvil: true, name: '粉尘分裂体', size: 20, splits: true, splitCount: 3,
                icon: '💎',
                description: '粉尘攻击载体 - 死后会分裂成3个快速移动的小碎片！',
                tip: '分片加农炮对分裂怪造成额外伤害，AOE范围可以一次清理碎片！',
                hpGrowth: 0.2,
                weakToSharding: true  // 被分片炮克制
            },
            shielded: {
                hp: 200, speed: 0.7, reward: 8, color: '#888888',
                isEvil: true, name: '混币装甲兽', size: 22, damageReduction: 0.5,
                icon: '🛡️',
                description: '混币器护盾 - 拥有50%伤害减免！普通攻击只能造成一半伤害！',
                tip: 'ZK狙击塔可以穿透护盾，造成额外伤害！',
                hpGrowth: 0.22,
                weakToZK: true  // 被ZK狙击克制
            },
            healer: {
                hp: 150, speed: 0.8, reward: 9, color: '#00ff00',
                isEvil: true, name: '高频吸血蝠', size: 18, healsPerSecond: 8,
                icon: '💚',
                description: '高频交易体 - 每秒恢复8点生命！必须快速击杀或压制回血！',
                tip: 'Layer 2通道的持续激光能压制它的回血，并造成额外伤害！',
                hpGrowth: 0.25,
                canBeSuppressed: true  // 可以被压制回血
            },
            boss: {
                hp: 10000, speed: 0.6, reward: 30, color: '#ff0000',
                isEvil: true, name: '51%算力泰坦', size: 50, damageReduction: 0.55, healsPerSecond: 3,
                icon: '☠️',
                description: '51%攻击巨兽 - 拥有超过半数的算力！10000点血量，55%减伤，每秒回血3点！',
                tip: '必须使用高级塔组合！ZK狙击塔对BOSS造成额外伤害！主网大炮对BOSS造成30%当前HP伤害，是击杀关键！',
                hpGrowth: 0.3,
                isBoss: true,  // 标记为BOSS
                weakToZK: true,  // 被ZK狙击克制
                weakToCannon: true  // 被主网炮克制（30%当前HP伤害）
            },
            splitChild: {
                hp: 25, speed: 2.0, reward: 2, color: '#00ccff',
                isEvil: true, name: '碎片', size: 8,
                icon: '✦', noPopup: true,
                hpGrowth: 0.2
            }
        };
        
        // ==================== STORY DATA ====================
        const storyData = {
            opening: {
                titleKey: 'opening_title',
                subtitleKey: 'opening_subtitle',
                contentKey: 'opening_content',
                title: '数字世界的守护者',
                subtitle: '2045年',
                icon: '🌐',
                content: `2045年，人类社会已完全数字化。

在这个世界里，每一笔交易、每一条信息，
都需要通过"区块链"这个去中心化的账本来验证和记录。

但是，黑客、诈骗者、恶意程序从未停止攻击...

你是一名区块链安全工程师，
你的任务是：守护区块链网络，
确保每个区块都只包含合法、安全的交易。

记住：
🟢 绿色 = 合法交易（让它们通过）
🔴 红色 = 恶意数据（必须消灭）

准备好了吗？让我们开始守护数字世界！`,
                buttonText: '开始守护！'
            },
            levels: {
                1: {
                    opening: {
                        titleKey: 'level1_opening_title',
                        subtitleKey: 'level1_opening_subtitle',
                        contentKey: 'level1_opening_content',
                        title: '第一道防线',
                        subtitle: '关卡 1：交易验证',
                        icon: '🔐',
                        content: `"欢迎来到区块链网络的第一道防线。"

这里是交易池（Mempool），所有交易在被打包进区块前，
都会先来到这里等待验证。

你的第一个任务：
部署"公钥验证哨"，检查每笔交易的数字签名。

就像银行柜员验证你的身份证一样，
验证哨会检查交易是否真的来自账户主人。

⚠ 小心垃圾交易！它们会堵塞网络！`,
                        buttonText: '开始部署'
                    },
                    victory: {
                        titleKey: 'level1_victory_title',
                        subtitleKey: 'level1_victory_subtitle',
                        contentKey: 'level1_victory_content',
                        title: '第一关完成',
                        subtitle: '防线稳固',
                        icon: '✅',
                        content: `干得好！你成功验证了第一批交易。

但这只是开始...
随着区块链越来越受欢迎，交易量暴增，
单纯的验证已经不够了。

我们需要更强大的技术...`,
                        buttonText: '继续前进'
                    }
                },
                2: {
                    opening: {
                        titleKey: 'level2_opening_title',
                        subtitleKey: 'level2_opening_subtitle',
                        contentKey: 'level2_opening_content',
                        title: '扩容危机',
                        subtitle: '关卡 2：网络扩容',
                        icon: '💥',
                        content: `"交易量增长了100倍！网络快要崩溃了！"

当太多人同时使用区块链时，网络会变得拥堵。
这就是著名的"扩容问题"。

解决方案：分片技术（Sharding）
把数据分成多个部分，并行处理！

就像超市开设多个收银台，
而不是让所有人排一个队。

新武器解锁：分片加农炮
它的范围攻击能一次处理多个目标！`,
                        buttonText: '部署分片'
                    },
                    victory: {
                        titleKey: 'level2_victory_title',
                        subtitleKey: 'level2_victory_subtitle',
                        contentKey: 'level2_victory_content',
                        title: '扩容成功',
                        subtitle: '网络恢复',
                        icon: '✅',
                        content: `网络恢复正常！交易速度提升了10倍！

但新的威胁出现了...
有人开始使用"混币器"来隐藏交易来源。

我们需要更先进的技术来应对...`,
                        buttonText: '继续前进'
                    }
                },
                3: {
                    opening: {
                        titleKey: 'level3_opening_title',
                        subtitleKey: 'level3_opening_subtitle',
                        contentKey: 'level3_opening_content',
                        title: '隐私之战',
                        subtitle: '关卡 3：隐私与证明',
                        icon: '🎯',
                        content: `⚠️ 警报：检测到"<span style="color: #ff6b6b;">双花攻击</span>" (Double-Spend)！

狡猾的敌人试图将同一笔钱使用两次，并利用加密迷雾处于 <span style="color: #ff6b6b;">[隐身状态]</span>，常规防御塔无法锁定目标。

<span style="color: #00ffff;">技术解锁：零知识证明 (ZK-SNARKs)</span>
"无需知晓具体内容，也能验证真相。"

<span style="color: #ffd700;">战术指令：</span>
立即部署 <span style="color: #00ffff;">[ZK狙击塔]</span>！它拥有 <span style="color: #ffd700;">真视 (True Sight)</span> 能力，能直接识破所有隐身单位的伪装，并造成 <span style="color: #ffd700;">致命暴击</span>！`,
                        buttonText: '部署ZK技术'
                    },
                    victory: {
                        titleKey: 'level3_victory_title',
                        subtitleKey: 'level3_victory_subtitle',
                        contentKey: 'level3_victory_content',
                        title: '隐私平衡',
                        subtitle: '技术突破',
                        icon: '✅',
                        content: `你找到了隐私和安全的平衡点！

但区块链还有一个致命弱点：
主链处理速度太慢，手续费太高...

是时候引入Layer 2了！`,
                        buttonText: '继续前进'
                    }
                },
                4: {
                    opening: {
                        titleKey: 'level4_opening_title',
                        subtitleKey: 'level4_opening_subtitle',
                        contentKey: 'level4_opening_content',
                        title: '速度革命',
                        subtitle: '关卡 4：闪电网络',
                        icon: '⚡',
                        content: `⚠️ 主网拥堵警报：<span style="color: #ff6b6b;">Gas 费已突破天际！</span>

链上确认太慢，单笔手续费高达几十美元，常规防线已瘫痪。

<span style="color: #ff6b6b;">遭遇强敌：吸血鬼机器人 (Vampire Bot)</span>
它们拥有 <span style="color: #ff6b6b;">[持续回血]</span> 机制，普通防御塔的伤害还没有它们回血快！

<span style="color: #00ffff;">技术升级：闪电网络 (Lightning Network)</span>
建立链下 Layer 2 通道，实现毫秒级交易！

请部署 <span style="color: #00ffff;">[L2 速射炮]</span>，利用其 <span style="color: #ffd700;">超高攻速</span> 形成的火力网，强行压制并瓦解敌人的修复装甲！`,
                        buttonText: '部署L2'
                    },
                    victory: {
                        titleKey: 'level4_victory_title',
                        subtitleKey: 'level4_victory_subtitle',
                        contentKey: 'level4_victory_content',
                        title: '速度提升',
                        subtitle: '效率革命',
                        icon: '✅',
                        content: `交易速度提升1000倍！手续费降低99%！

但最大的威胁还在后面...
有人正在集结算力，准备发动51%攻击！

这是区块链的终极考验！`,
                        buttonText: '准备最终战'
                    }
                },
                5: {
                    opening: {
                        titleKey: 'level5_opening_title',
                        subtitleKey: 'level5_opening_subtitle',
                        contentKey: 'level5_opening_content',
                        title: '终极威胁',
                        subtitle: '关卡 5：51%攻击',
                        icon: '☠️',
                        content: `<strong style="color: #ff0000;">🟥 红色最高警报：51% 算力攻击！</strong>

攻击者已控制全网超过 <span style="color: #ff6b6b;">50% 的算力</span>，正在试图 <span style="color: #ff6b6b;">重写区块链历史</span>。一旦防线失守，所有交易记录将被篡改！

<strong style="color: #ff6b6b;">⚠️ 战场突变：双通道入侵</strong>
敌人将从 <span style="color: #ff6b6b;">两个入口</span> 同时发起猛攻，防守压力翻倍！

<span style="color: #00ffff;">终极协议解锁：硬分叉 (Hard Fork)</span>
常规手段已失效。必须启动 <span style="color: #00ffff;">[主网大炮]</span>，强制把恶意算力剥离！这是对付 BOSS 的唯一手段，能造成 <span style="color: #ffd700;">毁灭性打击</span>。

<strong>这是最后一战，誓死守卫创世区块！</strong>`,
                        buttonText: '最终决战'
                    },
                    victory: {
                        titleKey: 'level5_victory_title',
                        subtitleKey: 'level5_victory_subtitle',
                        contentKey: 'level5_victory_content',
                        title: '胜利',
                        subtitle: '区块链守护者',
                        icon: '🏆',
                        content: `你成功击退了51%攻击！
区块链网络安全了！

但这不是结束...
只要区块链存在，威胁就永远存在。

而你，将继续守护这个去中心化的世界。

感谢你，区块链守护者！

【无尽模式已解锁】
继续挑战，测试你的极限！`,
                        buttonText: '完成使命'
                    }
                }
            },
            failure: {
                title: '区块被污染',
                subtitle: '共识失败',
                icon: '⚠️',
                content: `"恶意交易进入了区块..."

但不要气馁！
每个伟大的工程师都经历过失败。

分析一下：
- 是防御布局的问题？
- 还是升级不够？
- 或者需要调整策略？

区块链的安全，需要不断学习和改进。

再试一次！`,
                buttonText: '重新挑战'
            }
        };
        
        // ==================== KNOWLEDGE CARDS DATA ====================
        const knowledgeCards = {
            // 防御塔知识库
            towers: {
                validator: {
                    title: '非对称加密',
                    principle: '每个账户有两把钥匙：私钥（只有你知道，用来签名）和公钥（公开的，用来验证签名）。',
                    analogy: '就像你的签名：只有你能签，但所有人都能验证是不是你签的。',
                    application: '比特币地址、以太坊钱包、数字签名认证',
                    gameplay: '验证哨检查每笔交易的签名，确保交易真的来自账户主人。'
                },
                miner: {
                    title: '工作量证明 (PoW)',
                    principle: '矿工通过大量计算来竞争记账权，谁先算出答案谁就能打包区块并获得奖励。',
                    analogy: '就像数学竞赛：谁先解出难题，谁就能获得奖金。',
                    application: '比特币挖矿、以太坊1.0（已转PoS）',
                    gameplay: '矿池每3秒产生GAS收入，是你的经济来源。'
                },
                gasStation: {
                    title: 'Gas费机制',
                    principle: '用户支付Gas费来激励矿工优先处理自己的交易。Gas费越高，交易越快被打包。',
                    analogy: '就像快递加急费：付更多钱，你的包裹就能更快送达。',
                    application: '以太坊交易费、智能合约执行成本',
                    gameplay: 'Gas优化器提升周围防御塔的攻击速度，让它们更快处理交易。'
                },
                contract: {
                    title: '智能合约',
                    principle: '自动执行的代码，部署在区块链上。满足条件就自动运行，不需要人工干预。',
                    analogy: '就像自动售货机：投币→选择→自动出货，全程无需人工。',
                    application: 'DeFi协议、NFT交易、DAO治理',
                    gameplay: '智能合约塔自动检测范围内的敌人并减速，还能揭露隐身单位。'
                },
                sharding: {
                    title: '分片技术',
                    principle: '将区块链网络分成多个分片，每个分片并行处理不同的交易，大幅提升吞吐量。',
                    analogy: '就像超市开设多个收银台，而不是让所有人排一个队。',
                    application: '以太坊2.0分片、Zilliqa、Near Protocol',
                    gameplay: '分片炮发射范围攻击，一次处理多个目标，体现并行处理的威力。'
                },
                zkSniper: {
                    title: '零知识证明 (ZKP)',
                    principle: '证明某个陈述为真，而不需要透露任何额外信息。',
                    analogy: '就像你能证明自己成年，而不需要告诉别人你的具体年龄。',
                    application: 'zkSNARK、zkSTARK、隐私币Zcash',
                    gameplay: 'ZK狙击塔能"看穿"隐身和混淆，对隐藏单位造成额外伤害。'
                },
                l2Channel: {
                    title: 'Layer 2扩容',
                    principle: '在主链之外处理大量交易，只把最终结果提交到主链，降低成本和延迟。',
                    analogy: '就像你和朋友之间的借还钱，不需要每次都找银行记账，最后算总账就行。',
                    application: 'Lightning Network、Polygon、Arbitrum、Optimism',
                    gameplay: 'L2通道持续发射激光，高频低成本的持续伤害。'
                },
                mainnetCannon: {
                    title: '硬分叉',
                    principle: '区块链协议的重大更改，不兼容旧版本。相当于"重启"网络，是最后的手段。',
                    analogy: '就像给操作系统做重大升级，旧版本的软件可能无法运行。',
                    application: '比特币现金分叉、以太坊DAO事件后的分叉',
                    gameplay: '主网大炮是终极武器，对BOSS造成当前生命值30%的巨额伤害，但需要手动点击发射。'
                }
            },
            // 敌人知识库
            enemies: {
                spam: {
                    title: '垃圾交易攻击',
                    principle: '攻击者发送大量无意义的交易，堵塞网络，让正常交易无法被处理。',
                    analogy: '就像有人不断拨打骚扰电话，占用客服热线，让真正需要帮助的人打不进来。',
                    application: '2017年以太坊CryptoKitties拥堵事件',
                    gameplay: '基础敌人，数量多但血量低，容易清理。'
                },
                valid: {
                    title: '合法交易',
                    principle: '正常的区块链交易，需要被验证并打包进区块。',
                    analogy: '就像正常的银行转账，需要被处理和记录。',
                    application: '所有正常的加密货币转账',
                    gameplay: '绿色的合法交易必须放行，否则会失去收入。'
                },
                doublespend: {
                    title: '双花攻击',
                    principle: '攻击者试图将同一笔钱花两次，通过控制算力或利用网络延迟。',
                    analogy: '就像用同一张假钞在两家店同时买东西。',
                    application: '51%攻击、Race Attack、Finney Attack',
                    gameplay: '会隐身，需要智能合约的真视能力或ZK狙击塔来揭露。'
                },
                splitter: {
                    title: '粉尘攻击',
                    principle: '攻击者发送大量微小金额的交易，让受害者的钱包充满"粉尘"，难以管理且暴露隐私。',
                    analogy: '就像有人往你家门口倒一堆垃圾，让你无法正常出入。',
                    application: '比特币粉尘攻击、地址追踪',
                    gameplay: '死后分裂成3个快速移动的小单位，需要范围攻击清理。'
                },
                armored: {
                    title: '混币服务',
                    principle: '通过混淆交易来源和去向，让资金流向难以追踪。',
                    analogy: '就像把你的钱和很多人的钱混在一起洗牌，然后再发回来，别人就不知道哪笔是你的了。',
                    application: 'Tornado Cash、CoinJoin、混币器',
                    gameplay: '拥有50%伤害减免，需要高伤害或ZK狙击塔的穿透攻击。'
                },
                vampire: {
                    title: '高频交易攻击',
                    principle: '利用极快的交易速度抢先执行，从价格波动中获利（抢跑、夹击）。',
                    analogy: '就像有人能提前0.1秒知道股票价格，总能抢在你前面买卖。',
                    application: 'MEV（最大可提取价值）、三明治攻击',
                    gameplay: '持续回血，需要L2通道的持续伤害来压制回血能力。'
                },
                boss: {
                    title: '51%攻击',
                    principle: '攻击者控制超过50%的网络算力，可以篡改交易记录、进行双花攻击。',
                    analogy: '就像有人控制了超过半数的投票权，可以随意修改投票结果。',
                    application: '小型区块链的51%攻击案例（ETC、BTG等）',
                    gameplay: '终极BOSS，超高血量和减伤，需要所有高级塔配合，主网大炮是击杀关键。'
                }
            }
        };
        
        // ==================== 链灵对话系统 ====================
        const chainSpiritDialogues = {
            prologue: {
                character: '链灵',
                icon: '✨',
                dialogues: [
                    {
                        text: '你好，我是链灵，区块链世界的守护精灵。',
                        emotion: 'happy'
                    },
                    {
                        text: '这里是区块链网络的核心，但现在正遭受恶意攻击...',
                        emotion: 'worried'
                    },
                    {
                        text: '我需要你的帮助！建造防御塔，保护合法交易通过！',
                        emotion: 'determined'
                    }
                ]
            },
            level1: {
                intro: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level1_intro_1',
                        text: '这是最基础的防御！垃圾交易虫正在攻击网络。',
                        emotion: 'serious'
                    },
                    {
                        character: '链灵',
                        textKey: 'dialogue_level1_intro_2',
                        text: '建造验证节点来清理它们，但要放行绿色的合法交易！',
                        emotion: 'teaching'
                    }
                ],
                victory: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level1_victory_1',
                        text: '太棒了！你成功保护了第一批交易！',
                        emotion: 'happy'
                    },
                    {
                        character: '链灵',
                        textKey: 'dialogue_level1_victory_2',
                        text: '但这只是开始...更强的敌人即将到来。',
                        emotion: 'worried'
                    }
                ]
            },
            level2: {
                intro: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level2_intro_1',
                        text: '糟糕！粉尘分裂体出现了！',
                        emotion: 'shocked'
                    },
                    {
                        character: '链灵',
                        textKey: 'dialogue_level2_intro_2',
                        text: '它们死后会分裂成3个小怪...我们需要分片处理器！',
                        emotion: 'determined'
                    }
                ],
                victory: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level2_victory_1',
                        text: '分片技术果然有效！你掌握得很快！',
                        emotion: 'proud'
                    }
                ]
            },
            level3: {
                intro: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level3_intro_1',
                        text: '小心！双花幽灵会隐身！',
                        emotion: 'alert'
                    },
                    {
                        character: '链灵',
                        textKey: 'dialogue_level3_intro_2',
                        text: '使用智能合约的真视功能，或者零知识证明器的穿透攻击！',
                        emotion: 'teaching'
                    }
                ],
                victory: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level3_victory_1',
                        text: '零知识证明的力量...即使看不见，也能验证真相！',
                        emotion: 'amazed'
                    }
                ]
            },
            level4: {
                intro: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level4_intro_1',
                        text: '吸血鬼机器人！它们会不断回血！',
                        emotion: 'worried'
                    },
                    {
                        character: '链灵',
                        textKey: 'dialogue_level4_intro_2',
                        text: '用Layer 2通道的持续伤害压制它们的恢复能力！',
                        emotion: 'confident'
                    }
                ],
                victory: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level4_victory_1',
                        text: 'Layer 2的速度...这就是未来！',
                        emotion: 'excited'
                    }
                ]
            },
            level5: {
                intro: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level5_intro_1',
                        text: '警报！51%攻击BOSS来了！',
                        emotion: 'serious'
                    },
                    {
                        character: '链灵',
                        textKey: 'dialogue_level5_intro_2',
                        text: '这是最终考验...使用所有防御技术，必要时启动主网大炮！',
                        emotion: 'determined'
                    }
                ],
                victory: [
                    {
                        character: '链灵',
                        textKey: 'dialogue_level5_victory_1',
                        text: '你做到了！区块链安全了！',
                        emotion: 'overjoyed'
                    },
                    {
                        character: '链灵',
                        textKey: 'dialogue_level5_victory_2',
                        text: '你是真正的区块链守护者！',
                        emotion: 'proud'
                    }
                ]
            }
        };
        
        // 对话系统状态
        let dialogueState = {
            active: false,
            currentDialogue: null,
            currentIndex: 0,
            callback: null
        };
        
        // 显示对话
        function showDialogue(dialogueKey, callback = null) {
            const dialogue = chainSpiritDialogues[dialogueKey];
            if (!dialogue) return;
            
            dialogueState.active = true;
            dialogueState.currentDialogue = dialogue;
            dialogueState.currentIndex = 0;
            dialogueState.callback = callback;
            
            // 隐藏语言选择器（对话界面）
            hideLanguageSelector();
            
            displayCurrentDialogue();
        }
        
        // 显示当前对话
        function displayCurrentDialogue() {
            const dialogue = dialogueState.currentDialogue;
            let currentText;
            
            if (dialogue.dialogues) {
                // 序章格式
                currentText = dialogue.dialogues[dialogueState.currentIndex];
            } else {
                // 关卡格式 - 默认显示intro
                currentText = dialogue.intro[dialogueState.currentIndex];
            }
            
            if (!currentText) return;
            
            // 获取翻译后的文本
            const displayText = currentText.textKey ? getText(currentText.textKey) : currentText.text;
            const characterName = getText('character_chain_spirit');
            const continueText = getText('dialogue_continue');
            
            // 创建对话框
            const overlay = document.createElement('div');
            overlay.className = 'dialogue-overlay';
            overlay.id = 'dialogueOverlay';
            
            overlay.innerHTML = `
                <div class="dialogue-box">
                    <div class="dialogue-character">
                        <div class="character-icon">${dialogue.icon || '✨'}</div>
                        <div class="character-name">${characterName}</div>
                    </div>
                    <div class="dialogue-text">${displayText}</div>
                    <div class="dialogue-continue" onclick="nextDialogue()">${continueText}</div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // 暂停游戏
            gameState.modalPaused = true;
        }
        
        // 下一段对话
        function nextDialogue() {
            const dialogue = dialogueState.currentDialogue;
            let maxIndex;
            
            if (dialogue.dialogues) {
                maxIndex = dialogue.dialogues.length - 1;
            } else {
                maxIndex = dialogue.intro.length - 1;
            }
            
            if (dialogueState.currentIndex < maxIndex) {
                dialogueState.currentIndex++;
                hideDialogue();
                setTimeout(() => displayCurrentDialogue(), 200);
            } else {
                // 对话结束
                hideDialogue();
                dialogueState.active = false;
                gameState.modalPaused = false;
                
                // 对话结束后，根据当前界面决定是否显示语言选择器
                setTimeout(() => {
                    const gameUI = document.getElementById('gameUI');
                    const levelSelect = document.getElementById('levelSelectScreen');
                    const startScreen = document.getElementById('startScreen');
                    
                    if (gameUI.style.display !== 'block' && 
                        (levelSelect.style.display === 'flex' || startScreen.style.display === 'flex')) {
                        showLanguageSelector();
                    }
                }, 100);
                
                if (dialogueState.callback) {
                    dialogueState.callback();
                }
            }
        }
        
        // 隐藏对话框
        function hideDialogue() {
            const overlay = document.getElementById('dialogueOverlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // ==================== LEVEL DEFINITIONS ====================
        const levels = [
            {
                id: 1,
                name: '交易验证',
                mapType: 'straight',
                txRequired: 8,  // 可获得8个，需要8个
                startBalance: 150,  // 提高初始金额，降低开局难度
                unlockTower: 'validator',
                knowledge: {
                    title: '交易验证',
                    icon: '🔐',
                    desc: '区块链节点利用公钥/私钥对来验证每笔交易的合法性。私钥签名，公钥验证——这就是非对称加密的魔力！',
                    tip: '建造验证哨来快速清理垃圾交易'
                },
                waves: [
                    [
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 5 }
                    ],
                    [
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 6 }
                    ],
                    [
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 8 }
                    ]
                ]
            },
            {
                id: 2,
                name: '网络扩容',
                mapType: 'uturn',
                txRequired: 15,  // 可获得15个，需要15个
                startBalance: 180,  // 提高初始金额，降低开局难度
                unlockTower: 'sharding',
                knowledge: {
                    title: '分片技术解锁！',
                    icon: '💥',
                    desc: '当交易量激增导致网络拥堵时，分片技术能将数据并行处理。就像把一条拥挤的公路变成多条高速通道！',
                    tip: '分片炮的AOE伤害能一次消灭成群的分裂碎片'
                },
                waves: [
                    [
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 4 }
                    ],
                    [
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 5 }
                    ],
                    [
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 4 },
                        { type: 'splitter', count: 1 }
                    ],
                    [
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 5 },
                        { type: 'splitter', count: 2 }
                    ],
                    [
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 6 },
                        { type: 'splitter', count: 3 }
                    ]
                ]
            },
            {
                id: 3,
                name: '隐私与证明',
                mapType: 'scurve',
                txRequired: 17,  // 可获得17个，需要17个
                startBalance: 220,  // 提高初始金额，降低开局难度
                unlockTower: 'zkSniper',
                knowledge: {
                    title: 'ZK零知识证明解锁！',
                    icon: '🎯',
                    desc: '面对混币器的加密保护，零知识证明能透过迷雾精准验证。不需要看到所有数据，数学证明就能揭示真相！',
                    tip: 'ZK狙击塔全图射程，无视护盾，优先攻击最危险的敌人'
                },
                waves: [
                    [ // 波1: 7个
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 4 }
                    ],
                    [ // 波2: 9个
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 5 },
                        { type: 'shielded', count: 1 }
                    ],
                    [ // 波3: 12个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 7 },
                        { type: 'shielded', count: 3 }
                    ],
                    [ // 波4: 16个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 9 },
                        { type: 'shielded', count: 3 },
                        { type: 'doubleSpend', count: 2 }
                    ],
                    [ // 波5: 20个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 11 },
                        { type: 'shielded', count: 4 },
                        { type: 'doubleSpend', count: 3 }
                    ],
                    [ // 波6: 20个（质量提升）
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 9 },
                        { type: 'shielded', count: 5 },
                        { type: 'doubleSpend', count: 4 }
                    ],
                    [ // 波7: 20个（最高质量）
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 7 },
                        { type: 'shielded', count: 6 },
                        { type: 'doubleSpend', count: 4 }
                    ]
                ]
            },
            {
                id: 4,
                name: '闪电网络',
                mapType: 'longstraight',
                txRequired: 23,  // 可获得23个，需要23个
                startBalance: 260,  // 提高初始金额，降低开局难度
                unlockTower: 'l2Channel',
                knowledge: {
                    title: 'Layer 2 通道解锁！',
                    icon: '⚡',
                    desc: '面对高频交易，Layer 2 通道就像高速公路。交易在链下极速处理，只把最终结果提交到主网，大大提升吞吐量！',
                    tip: 'L2通道的持续激光伤害能压制回血怪的恢复速度'
                },
                waves: [
                    [ // 波1: 7个敌人
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 4 }
                    ],
                    [ // 波2: 8个敌人
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 4 },
                        { type: 'healer', count: 1 }
                    ],
                    [ // 波3: 10个敌人
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 6 },
                        { type: 'healer', count: 2 }
                    ],
                    [ // 波4: 15个敌人
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 8 },
                        { type: 'healer', count: 3 },
                        { type: 'splitter', count: 2 }
                    ],
                    [ // 波5: 20个敌人
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 10 },
                        { type: 'healer', count: 4 },
                        { type: 'splitter', count: 3 },
                        { type: 'shielded', count: 1 }
                    ],
                    [ // 波6: 25个敌人
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 12 },
                        { type: 'healer', count: 5 },
                        { type: 'splitter', count: 4 },
                        { type: 'shielded', count: 2 }
                    ],
                    [ // 波7: 30个敌人
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 14 },
                        { type: 'healer', count: 6 },
                        { type: 'splitter', count: 5 },
                        { type: 'shielded', count: 3 }
                    ],
                    [ // 波8: 30个敌人（质量提升）
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 12 },
                        { type: 'healer', count: 7 },
                        { type: 'splitter', count: 5 },
                        { type: 'shielded', count: 4 }
                    ],
                    [ // 波9: 30个敌人（质量继续提升）
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 10 },
                        { type: 'healer', count: 8 },
                        { type: 'splitter', count: 5 },
                        { type: 'shielded', count: 5 }
                    ],
                    [ // 波10: 30个敌人（最高质量）
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 8 },
                        { type: 'healer', count: 9 },
                        { type: 'splitter', count: 5 },
                        { type: 'shielded', count: 5 }
                    ]
                ]
            },
            {
                id: 5,
                name: '51%攻击',
                mapType: 'double',
                txRequired: 35,  // 可获得35个，需要35个
                startBalance: 300,  // 提高初始金额，降低开局难度
                unlockTower: 'mainnetCannon',
                knowledge: {
                    title: '主网大炮解锁！',
                    icon: '☄️',
                    desc: '当攻击者掌控过半算力时，普通验证失效！社区必须付出巨大代价（硬分叉）来抵御攻击。这是区块链的最后防线！',
                    tip: '主网大炮每次发射消耗150 GAS，但对Boss只有50%伤害'
                },
                waves: [
                    [ // 波1: 8个
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 5 }
                    ],
                    [ // 波2: 9个
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 5 },
                        { type: 'splitter', count: 1 }
                    ],
                    [ // 波3: 10个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 6 },
                        { type: 'splitter', count: 2 }
                    ],
                    [ // 波4: 12个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 7 },
                        { type: 'shielded', count: 1 },
                        { type: 'healer', count: 2 }
                    ],
                    [ // 波5: 15个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 8 },
                        { type: 'shielded', count: 2 },
                        { type: 'healer', count: 3 }
                    ],
                    [ // 波6: 18个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 9 },
                        { type: 'splitter', count: 2 },
                        { type: 'shielded', count: 2 },
                        { type: 'healer', count: 3 }
                    ],
                    [ // 波7: 22个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 11 },
                        { type: 'splitter', count: 3 },
                        { type: 'shielded', count: 3 },
                        { type: 'healer', count: 3 }
                    ],
                    [ // 波8: 26个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 13 },
                        { type: 'splitter', count: 4 },
                        { type: 'shielded', count: 3 },
                        { type: 'healer', count: 4 }
                    ],
                    [ // 波9: 30个
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 14 },
                        { type: 'splitter', count: 5 },
                        { type: 'shielded', count: 4 },
                        { type: 'healer', count: 5 }
                    ],
                    [ // 波10: 30个（质量提升）
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 12 },
                        { type: 'splitter', count: 6 },
                        { type: 'shielded', count: 5 },
                        { type: 'healer', count: 5 }
                    ],
                    [ // 波11: 30个（质量继续提升）
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 10 },
                        { type: 'splitter', count: 6 },
                        { type: 'shielded', count: 6 },
                        { type: 'healer', count: 6 }
                    ],
                    [ // 波12: 30个（更高质量）
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 8 },
                        { type: 'splitter', count: 7 },
                        { type: 'shielded', count: 6 },
                        { type: 'healer', count: 7 }
                    ],
                    [ // 波13: 30个（最高质量）
                        { type: 'normal', count: 2 },
                        { type: 'spam', count: 6 },
                        { type: 'splitter', count: 7 },
                        { type: 'shielded', count: 7 },
                        { type: 'healer', count: 8 }
                    ],
                    [ // 波14: 30个（终极挑战）
                        { type: 'normal', count: 3 },
                        { type: 'spam', count: 5 },
                        { type: 'splitter', count: 8 },
                        { type: 'shielded', count: 7 },
                        { type: 'healer', count: 7 }
                    ],
                    [ // 波15: BOSS战
                        { type: 'normal', count: 3 },
                        { type: 'boss', count: 1 }
                    ]
                ]
            },
            {
                id: 'endless',
                name: '无尽模式',
                mapType: 'random',
                txRequired: 999999,
                startBalance: 600,  // 提高初始金额，降低开局难度
                isEndless: true
            }
        ];
        
        // ==================== ENDLESS MODE ====================
        function generateEndlessWave(waveNum) {
            const baseCount = Math.min(10 + waveNum * 2, 40); // 每波增加2个，上限40
            const wave = [];
            
            // 合法交易（固定3个）
            wave.push({ type: 'normal', count: 3 });
            
            let remainingCount = baseCount - 3;
            
            // 根据波次决定敌人类型分布
            if (waveNum <= 5) {
                // 前5波：主要是spam
                wave.push({ type: 'spam', count: remainingCount });
            } else if (waveNum <= 10) {
                // 6-10波：引入其他敌人
                const spamCount = Math.floor(remainingCount * 0.6);
                const shieldedCount = Math.floor(remainingCount * 0.2);
                const splitterCount = remainingCount - spamCount - shieldedCount;
                wave.push({ type: 'spam', count: spamCount });
                if (shieldedCount > 0) wave.push({ type: 'shielded', count: shieldedCount });
                if (splitterCount > 0) wave.push({ type: 'splitter', count: splitterCount });
            } else if (waveNum <= 20) {
                // 11-20波：更多样化
                const spamCount = Math.floor(remainingCount * 0.4);
                const shieldedCount = Math.floor(remainingCount * 0.2);
                const splitterCount = Math.floor(remainingCount * 0.2);
                const healerCount = Math.floor(remainingCount * 0.1);
                const doubleSpendCount = remainingCount - spamCount - shieldedCount - splitterCount - healerCount;
                wave.push({ type: 'spam', count: spamCount });
                if (shieldedCount > 0) wave.push({ type: 'shielded', count: shieldedCount });
                if (splitterCount > 0) wave.push({ type: 'splitter', count: splitterCount });
                if (healerCount > 0) wave.push({ type: 'healer', count: healerCount });
                if (doubleSpendCount > 0) wave.push({ type: 'doubleSpend', count: doubleSpendCount });
            } else {
                // 20波后：高质量敌人为主
                const spamCount = Math.floor(remainingCount * 0.2);
                const shieldedCount = Math.floor(remainingCount * 0.3);
                const splitterCount = Math.floor(remainingCount * 0.2);
                const healerCount = Math.floor(remainingCount * 0.2);
                const doubleSpendCount = remainingCount - spamCount - shieldedCount - splitterCount - healerCount;
                wave.push({ type: 'spam', count: spamCount });
                wave.push({ type: 'shielded', count: shieldedCount });
                wave.push({ type: 'splitter', count: splitterCount });
                wave.push({ type: 'healer', count: healerCount });
                if (doubleSpendCount > 0) wave.push({ type: 'doubleSpend', count: doubleSpendCount });
                
                // 每10波出现一个BOSS
                if (waveNum % 10 === 0) {
                    wave.push({ type: 'boss', count: 1 });
                }
            }
            
            return wave;
        }
        
        // ==================== RANDOM MAP POOL ====================
        const randomMapPool = [
            // 地图1: 极简上路
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.2) },
                    { x: w + 50, y: snapToGrid(h * 0.2) }
                ];
            },
            // 地图2: 极简下路
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.8) },
                    { x: w + 50, y: snapToGrid(h * 0.8) }
                ];
            },
            // 地图3: 急转弯（上到下）
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.2) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * 0.2) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * 0.75) },
                    { x: w + 50, y: snapToGrid(h * 0.75) }
                ];
            },
            // 地图4: 急转弯（下到上）
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.75) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * 0.75) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * 0.2) },
                    { x: w + 50, y: snapToGrid(h * 0.2) }
                ];
            },
            // 地图5: 双U型迷宫
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.2) },
                    { x: snapToGrid(w * 0.35), y: snapToGrid(h * 0.2) },
                    { x: snapToGrid(w * 0.35), y: snapToGrid(h * 0.6) },
                    { x: snapToGrid(w * 0.15), y: snapToGrid(h * 0.6) },
                    { x: snapToGrid(w * 0.15), y: snapToGrid(h * 0.35) },
                    { x: snapToGrid(w * 0.55), y: snapToGrid(h * 0.35) },
                    { x: snapToGrid(w * 0.55), y: snapToGrid(h * 0.75) },
                    { x: snapToGrid(w * 0.8), y: snapToGrid(h * 0.75) },
                    { x: snapToGrid(w * 0.8), y: snapToGrid(h * 0.5) },
                    { x: w + 50, y: snapToGrid(h * 0.5) }
                ];
            },
            // 地图6: 三段式之字
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.25), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.25), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.75), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.75), y: snapToGrid(h * 0.65) },
                    { x: w + 50, y: snapToGrid(h * 0.65) }
                ];
            },
            // 地图7: 反S型
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.7) },
                    { x: snapToGrid(w * 0.25), y: snapToGrid(h * 0.7) },
                    { x: snapToGrid(w * 0.25), y: snapToGrid(h * 0.45) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.45) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.65) },
                    { x: snapToGrid(w * 0.75), y: snapToGrid(h * 0.65) },
                    { x: snapToGrid(w * 0.75), y: snapToGrid(h * 0.3) },
                    { x: w + 50, y: snapToGrid(h * 0.3) }
                ];
            },
            // 地图8: 超长绕圈
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.1), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.1), y: snapToGrid(h * 0.15) },
                    { x: snapToGrid(w * 0.9), y: snapToGrid(h * 0.15) },
                    { x: snapToGrid(w * 0.9), y: snapToGrid(h * 0.85) },
                    { x: snapToGrid(w * 0.3), y: snapToGrid(h * 0.85) },
                    { x: snapToGrid(w * 0.3), y: snapToGrid(h * 0.5) },
                    { x: w + 50, y: snapToGrid(h * 0.5) }
                ];
            },
            // 地图9: 紧密螺旋
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.15), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.15), y: snapToGrid(h * 0.2) },
                    { x: snapToGrid(w * 0.65), y: snapToGrid(h * 0.2) },
                    { x: snapToGrid(w * 0.65), y: snapToGrid(h * 0.7) },
                    { x: snapToGrid(w * 0.3), y: snapToGrid(h * 0.7) },
                    { x: snapToGrid(w * 0.3), y: snapToGrid(h * 0.4) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.4) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.55) },
                    { x: w + 50, y: snapToGrid(h * 0.55) }
                ];
            },
            // 地图10: M型路径
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.6) },
                    { x: snapToGrid(w * 0.15), y: snapToGrid(h * 0.6) },
                    { x: snapToGrid(w * 0.15), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.35), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.35), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.7), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.7), y: snapToGrid(h * 0.7) },
                    { x: w + 50, y: snapToGrid(h * 0.7) }
                ];
            },
            // 地图11: 阶梯式下降
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.2) },
                    { x: snapToGrid(w * 0.2), y: snapToGrid(h * 0.2) },
                    { x: snapToGrid(w * 0.2), y: snapToGrid(h * 0.35) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * 0.35) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.6), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.6), y: snapToGrid(h * 0.65) },
                    { x: snapToGrid(w * 0.8), y: snapToGrid(h * 0.65) },
                    { x: snapToGrid(w * 0.8), y: snapToGrid(h * 0.8) },
                    { x: w + 50, y: snapToGrid(h * 0.8) }
                ];
            },
            // 地图12: 倒N型
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.3) },
                    { x: snapToGrid(w * 0.2), y: snapToGrid(h * 0.3) },
                    { x: snapToGrid(w * 0.2), y: snapToGrid(h * 0.7) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.7) },
                    { x: snapToGrid(w * 0.5), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.8), y: snapToGrid(h * 0.25) },
                    { x: snapToGrid(w * 0.8), y: snapToGrid(h * 0.65) },
                    { x: w + 50, y: snapToGrid(h * 0.65) }
                ];
            },
            // 地图13: 交叉回环
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.4) },
                    { x: snapToGrid(w * 0.3), y: snapToGrid(h * 0.4) },
                    { x: snapToGrid(w * 0.3), y: snapToGrid(h * 0.15) },
                    { x: snapToGrid(w * 0.7), y: snapToGrid(h * 0.15) },
                    { x: snapToGrid(w * 0.7), y: snapToGrid(h * 0.6) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * 0.6) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * 0.8) },
                    { x: w + 50, y: snapToGrid(h * 0.8) }
                ];
            },
            // 地图14: 波浪型
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.15), y: snapToGrid(h * 0.5) },
                    { x: snapToGrid(w * 0.15), y: snapToGrid(h * 0.3) },
                    { x: snapToGrid(w * 0.35), y: snapToGrid(h * 0.3) },
                    { x: snapToGrid(w * 0.35), y: snapToGrid(h * 0.6) },
                    { x: snapToGrid(w * 0.55), y: snapToGrid(h * 0.6) },
                    { x: snapToGrid(w * 0.55), y: snapToGrid(h * 0.35) },
                    { x: snapToGrid(w * 0.75), y: snapToGrid(h * 0.35) },
                    { x: snapToGrid(w * 0.75), y: snapToGrid(h * 0.7) },
                    { x: w + 50, y: snapToGrid(h * 0.7) }
                ];
            },
            // 地图15: 超复杂迷宫
            () => {
                const w = canvas.width, h = canvas.height;
                return [
                    { x: -50, y: snapToGrid(h * 0.35) },
                    { x: snapToGrid(w * 0.2), y: snapToGrid(h * 0.35) },
                    { x: snapToGrid(w * 0.2), y: snapToGrid(h * 0.15) },
                    { x: snapToGrid(w * 0.45), y: snapToGrid(h * 0.15) },
                    { x: snapToGrid(w * 0.45), y: snapToGrid(h * 0.55) },
                    { x: snapToGrid(w * 0.25), y: snapToGrid(h * 0.55) },
                    { x: snapToGrid(w * 0.25), y: snapToGrid(h * 0.75) },
                    { x: snapToGrid(w * 0.6), y: snapToGrid(h * 0.75) },
                    { x: snapToGrid(w * 0.6), y: snapToGrid(h * 0.3) },
                    { x: snapToGrid(w * 0.85), y: snapToGrid(h * 0.3) },
                    { x: snapToGrid(w * 0.85), y: snapToGrid(h * 0.6) },
                    { x: w + 50, y: snapToGrid(h * 0.6) }
                ];
            }
        ];
        
        function generateRandomPath() {
            // 从地图池中随机选择一个地图
            const randomMap = randomMapPool[Math.floor(Math.random() * randomMapPool.length)];
            const points = randomMap();
            
            // 向上偏移所有点，使路径更居中（负值表示向上）
            const yOffset = canvas.height * -0.05;
            points.forEach(point => {
                point.y = snapToGrid(Math.max(50, Math.min(point.y + yOffset, canvas.height - 50)));
            });
            
            gameState.path = points;
            gameState.blockPosition = { x: canvas.width - 100, y: points[points.length - 1].y };
            gameState.path2 = null;
        }
        
        // ==================== PATH GENERATION ====================
        // 对齐到网格中心的辅助函数
        function snapToGrid(value) {
            const grid = gameState.gridSize;
            return Math.round(value / grid) * grid + grid / 2;
        }
        
        function generatePath(mapType) {
            const points = [];
            const w = canvas.width;
            const h = canvas.height;
            const grid = gameState.gridSize;
            
            // 向上偏移，使路径更居中（负值表示向上）
            const topOffset = -0.05; // 向上偏移5%
            
            switch(mapType) {
                case 'straight':
                    points.push({ x: -50, y: snapToGrid(h * (0.5 + topOffset)) });
                    points.push({ x: w + 50, y: snapToGrid(h * (0.5 + topOffset)) });
                    break;
                    
                case 'uturn':
                    points.push({ x: -50, y: snapToGrid(h * (0.3 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.7), y: snapToGrid(h * (0.3 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.7), y: snapToGrid(h * (0.7 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.2), y: snapToGrid(h * (0.7 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.2), y: snapToGrid(h * (0.5 + topOffset)) });
                    points.push({ x: w + 50, y: snapToGrid(h * (0.5 + topOffset)) });
                    break;
                    
                case 'scurve':
                    points.push({ x: -50, y: snapToGrid(h * (0.25 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.25), y: snapToGrid(h * (0.25 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.25), y: snapToGrid(h * (0.6 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.5), y: snapToGrid(h * (0.6 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.5), y: snapToGrid(h * (0.3 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.75), y: snapToGrid(h * (0.3 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.75), y: snapToGrid(h * (0.7 + topOffset)) });
                    points.push({ x: w + 50, y: snapToGrid(h * (0.7 + topOffset)) });
                    break;
                    
                case 'longstraight':
                    points.push({ x: -50, y: snapToGrid(h * (0.5 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.15), y: snapToGrid(h * (0.5 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.15), y: snapToGrid(h * (0.25 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.85), y: snapToGrid(h * (0.25 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.85), y: snapToGrid(h * (0.5 + topOffset)) });
                    points.push({ x: w + 50, y: snapToGrid(h * (0.5 + topOffset)) });
                    break;
                    
                case 'double':
                    points.push({ x: -50, y: snapToGrid(h * (0.35 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.4), y: snapToGrid(h * (0.35 + topOffset)) });
                    points.push({ x: snapToGrid(w * 0.4), y: snapToGrid(h * (0.5 + topOffset)) });
                    points.push({ x: w + 50, y: snapToGrid(h * (0.5 + topOffset)) });
                    break;
            }
            
            gameState.path = points;
            gameState.blockPosition = { x: w - 100, y: points[points.length - 1].y };
            
            if (mapType === 'double') {
                gameState.path2 = [
                    { x: -50, y: snapToGrid(h * (0.65 + topOffset)) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * (0.65 + topOffset)) },
                    { x: snapToGrid(w * 0.4), y: snapToGrid(h * (0.5 + topOffset)) },
                    { x: w + 50, y: snapToGrid(h * (0.5 + topOffset)) }
                ];
            } else {
                gameState.path2 = null;
            }
        }
        
        // ==================== DRAWING FUNCTIONS ====================
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += gameState.gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gameState.gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function drawPath() {
            const drawSinglePath = (path, label) => {
                if (path.length < 2) return;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 40;
                ctx.stroke();
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#00ffff';
                ctx.font = '12px Orbitron';
                ctx.fillText(label, path[0].x + 60, path[0].y - 25);
            };
            
            drawSinglePath(gameState.path, 'MEMPOOL →');
            if (gameState.path2) {
                drawSinglePath(gameState.path2, 'MEMPOOL 2 →');
            }
            
            // 绘制刷怪图标（如果波次未开始且没有敌人）
            if (!gameState.waveInProgress && !gameState.wavePreparation && gameState.currentWave === 0 && gameState.enemies.length === 0) {
                // 使用屏幕内可见的位置（路径起点往右偏移）
                const spawnX = 50; // 屏幕左侧可见位置
                const spawnY = gameState.path[0].y;
                const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                
                // 绘制发光圆圈
                ctx.shadowBlur = 20 * pulse;
                ctx.shadowColor = '#ff0044';
                ctx.beginPath();
                ctx.arc(spawnX, spawnY, 35, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 0, 68, ${0.2 * pulse})`;
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 0, 68, ${0.8 * pulse})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 绘制图标
                ctx.shadowBlur = 10;
                ctx.font = '32px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ff0044';
                ctx.fillText('⚠', spawnX, spawnY + 10);
                
                // 绘制提示文字
                ctx.shadowBlur = 0;
                ctx.font = 'bold 12px Orbitron';
                ctx.fillStyle = '#ffff00';
                ctx.fillText(getText('click_to_start'), spawnX, spawnY + 50);
                ctx.textAlign = 'left';
            }
        }
        
        function drawBlock() {
            const pos = gameState.blockPosition;
            const size = 60;
            const progress = gameState.txCount / gameState.txRequired;
            
            ctx.shadowBlur = 30;
            ctx.shadowColor = progress >= 1 ? '#00ff00' : '#00ffff';
            
            ctx.fillStyle = 'rgba(0, 50, 80, 0.8)';
            ctx.strokeStyle = progress >= 1 ? '#00ff00' : '#00ffff';
            ctx.lineWidth = 3;
            ctx.fillRect(pos.x - size/2, pos.y - size/2, size, size);
            ctx.strokeRect(pos.x - size/2, pos.y - size/2, size, size);
            
            ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
            ctx.fillRect(pos.x - size/2, pos.y + size/2 - size * progress, size, size * progress);
            
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 10px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('BLOCK', pos.x, pos.y - 5);
            ctx.fillText('#' + gameState.blockHeight, pos.x, pos.y + 8);
            ctx.textAlign = 'left';
        }
        
        function drawTowers() {
            for (const tower of gameState.towers) {
                const def = towerDefs[tower.type];
                const stats = getTowerStats(tower);
                const isSelected = gameState.selectedPlacedTower === tower;
                
                if (tower.showRange || isSelected) {
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, stats.range, 0, Math.PI * 2);
                    ctx.fillStyle = isSelected ? 'rgba(255, 102, 0, 0.15)' : 'rgba(0, 255, 255, 0.1)';
                    ctx.fill();
                    ctx.strokeStyle = isSelected ? '#ff6600' : 'rgba(0, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                if (tower.type === 'gasStation') {
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, stats.range, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
                    ctx.fill();
                }
                
                if (tower.type === 'contract') {
                    const pulse = Math.sin(Date.now() * 0.003) * 0.2 + 0.8;
                    
                    // 绘制紫色减速光环（外圈）
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, stats.range, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(170, 0, 255, ${0.15 * pulse})`;
                    ctx.fill();
                    ctx.strokeStyle = `rgba(170, 0, 255, ${0.4 * pulse})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 绘制粉色真视光环（内圈）
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, stats.truesightRange, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 100, 255, ${0.1 * pulse})`;
                    ctx.fill();
                    ctx.strokeStyle = `rgba(255, 100, 255, ${0.3 * pulse})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                if (tower.type === 'l2Channel') {
                    // 只在实际发射激光时显示射线（在攻击逻辑中通过laserBeams绘制）
                    // 不再显示初始的静态射线
                }
                
                // Buff高亮效果
                if (tower.buffed) {
                    const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                    ctx.shadowBlur = 25 * pulse;
                    ctx.shadowColor = def.color;
                    
                    // 绘制外圈光环
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, 28, 0, Math.PI * 2);
                    ctx.strokeStyle = def.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5 * pulse;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = isSelected ? '#ff6600' : def.color;
                }
                
                // 塔的固定大小（不随等级变化）
                const towerSize = 20;
                
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, towerSize, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(20, 30, 50, 0.9)';
                ctx.fill();
                
                // 根据等级改变边框颜色强度
                let borderColor = def.color;
                if (tower.level >= 10) {
                    borderColor = '#ffff00'; // 满级金色
                } else if (tower.level >= 7) {
                    borderColor = '#ffaa00'; // 高级橙色
                } else if (tower.level >= 4) {
                    borderColor = '#ff00ff'; // 3级紫色
                }
                
                // 边框宽度固定，不随等级变化
                ctx.strokeStyle = isSelected ? '#ff6600' : (tower.buffed ? def.color : borderColor);
                ctx.lineWidth = isSelected ? 4 : (tower.buffed ? 4 : 3);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                ctx.font = '20px sans-serif';
                ctx.textAlign = 'center';
                const icons = { 
                    validator: '🔐', miner: '⚡', gasStation: '⛽', contract: '📜',
                    sharding: '💥', zkSniper: '🎯', l2Channel: '🌐', mainnetCannon: '☄️'
                };
                ctx.fillText(icons[tower.type], tower.x, tower.y + 7);
                
                // 显示等级（如果不是1级）
                if (tower.level && tower.level > 1) {
                    ctx.font = 'bold 10px Orbitron';
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#ffff00';
                    ctx.fillText('Lv' + tower.level, tower.x, tower.y + 30);
                    ctx.shadowBlur = 0;
                }
                
                ctx.textAlign = 'left';
                
                // 显示真视标记（小眼睛）
                if (tower.truesight) {
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#aa00ff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#aa00ff';
                    ctx.fillText('👁', tower.x, tower.y - 25);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
                
                if (tower.type === 'miner') {
                    // 显示挖矿进度条
                    const minerDef = towerDefs.miner;
                    const progress = tower.miningTimer ? 1 - (tower.miningTimer / minerDef.miningInterval) : 0;
                    
                    ctx.fillStyle = '#ff8800';
                    ctx.font = '10px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('MINING', tower.x, tower.y - 30);
                    
                    // 进度条
                    const barWidth = 40;
                    const barHeight = 4;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(tower.x - barWidth/2, tower.y - 22, barWidth, barHeight);
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(tower.x - barWidth/2, tower.y - 22, barWidth * progress, barHeight);
                    
                    ctx.textAlign = 'left';
                }
                
                if (tower.type === 'mainnetCannon') {
                    ctx.fillStyle = '#ff6600';
                    ctx.font = '8px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('CLICK TO FIRE', tower.x, tower.y + 35);
                    ctx.fillText('150 GAS', tower.x, tower.y + 45);
                    ctx.textAlign = 'left';
                }
            }
        }
        
        function drawEnemies() {
            for (const enemy of gameState.enemies) {
                const def = enemyDefs[enemy.type];
                const isInvisible = def.invisible && !enemy.revealed;
                
                ctx.save();
                if (isInvisible) ctx.globalAlpha = 0.15;
                if (enemy.frozen) ctx.globalAlpha = 0.7;
                
                ctx.shadowBlur = 15;
                ctx.shadowColor = enemy.color || def.color;
                
                const x = enemy.renderX;
                const y = enemy.renderY;
                const size = enemy.size || def.size;
                
                if (enemy.type === 'boss') {
                    drawHexagon(x, y, size, def.color, enemy.frozen);
                } else if (enemy.type === 'shielded') {
                    drawShieldedEnemy(x, y, size, def.color);
                } else if (enemy.type === 'healer') {
                    drawHealerEnemy(x, y, size, def.color);
                } else if (enemy.type === 'splitter' || enemy.type === 'splitChild') {
                    drawCrystalEnemy(x, y, size, def.color);
                } else {
                    drawDataPacket(x, y, size, enemy.color || def.color, def.isEvil, enemy.frozen, enemy.verified);
                }
                
                ctx.shadowBlur = 0;
                
                // 只有恶意交易才显示血条，合法交易无敌不显示
                if (!isInvisible && enemy.hp < enemy.maxHp && def.isEvil) {
                    const barWidth = size * 2;
                    const barHeight = 4;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(x - barWidth/2, y - size - 10, barWidth, barHeight);
                    ctx.fillStyle = '#ff0044';
                    ctx.fillRect(x - barWidth/2, y - size - 10, barWidth * (enemy.hp / enemy.maxHp), barHeight);
                }
                
                if (enemy.type === 'shielded' && !isInvisible) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                if (enemy.type === 'healer' && !isInvisible) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('+', x, y - size - 15);
                    ctx.textAlign = 'left';
                }
                
                ctx.restore();
            }
        }
        
        function drawDataPacket(x, y, size, color, isEvil, frozen, verified) {
            // 已验证的合法交易冒金光
            if (verified && !isEvil) {
                const time = Date.now() / 1000;
                const pulse = Math.sin(time * 5) * 0.3 + 0.7;
                ctx.shadowBlur = 20 * pulse;
                ctx.shadowColor = '#ffd700';
                
                // 绘制金色光环
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(x, y, size + 8 + i * 4, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 - i * 0.1})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // 金色粒子效果
                for (let i = 0; i < 4; i++) {
                    const angle = time * 2 + (Math.PI / 2) * i;
                    const radius = size + 12;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    ctx.fillStyle = `rgba(255, 215, 0, ${pulse})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.beginPath();
            if (isEvil) {
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI / 4) * i - Math.PI / 2;
                    const r = i % 2 === 0 ? size : size * 0.5;
                    const px = x + r * Math.cos(angle);
                    const py = y + r * Math.sin(angle);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
            } else {
                ctx.rect(x - size * 0.7, y - size * 0.7, size * 1.4, size * 1.4);
            }
            ctx.fillStyle = frozen ? '#8888ff' : color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawHexagon(x, y, size, color, frozen) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 2;
                const px = x + size * Math.cos(angle);
                const py = y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = frozen ? '#8888ff' : color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#000';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('☠', x, y + 8);
            ctx.textAlign = 'left';
        }
        
        function drawCrystalEnemy(x, y, size, color) {
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x + size * 0.7, y);
            ctx.lineTo(x, y + size);
            ctx.lineTo(x - size * 0.7, y);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawShieldedEnemy(x, y, size, color) {
            ctx.beginPath();
            ctx.arc(x, y, size * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        function drawHealerEnemy(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x - size * 0.2, y - size * 0.6, size * 0.4, size * 1.2);
            ctx.fillRect(x - size * 0.6, y - size * 0.2, size * 1.2, size * 0.4);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - size * 0.6, y - size * 0.6, size * 1.2, size * 1.2);
        }
        
        function drawProjectiles() {
            for (const p of gameState.projectiles) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = p.color;
                
                if (p.type === 'miner') {
                    ctx.strokeStyle = '#ffcc00';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(p.x - 10, p.y);
                    ctx.lineTo(p.x + 10, p.y);
                    ctx.stroke();
                } else if (p.type === 'sharding') {
                    ctx.fillStyle = '#0088ff';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'zkSniper') {
                    ctx.strokeStyle = '#ff00aa';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(p.startX, p.startY);
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
            
            for (const beam of gameState.laserBeams) {
                ctx.strokeStyle = `rgba(255, 204, 0, ${beam.alpha})`;
                ctx.lineWidth = 6;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffcc00';
                ctx.beginPath();
                ctx.moveTo(beam.x1, beam.y1);
                ctx.lineTo(beam.x2, beam.y2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }
        
        function drawParticles() {
            for (const p of gameState.particles) {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
            }
            ctx.globalAlpha = 1;
        }
        
        function drawFloatingTexts() {
            for (const t of gameState.floatingTexts) {
                ctx.globalAlpha = t.life / 60;
                ctx.fillStyle = t.color;
                ctx.font = 'bold 14px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(t.text, t.x, t.y);
                ctx.textAlign = 'left';
            }
            ctx.globalAlpha = 1;
        }
        
        function drawPlacementPreview() {
            if (!gameState.selectedTower) return;
            
            const def = towerDefs[gameState.selectedTower];
            const x = Math.floor(gameState.mouseX / gameState.gridSize) * gameState.gridSize + gameState.gridSize / 2;
            const y = Math.floor(gameState.mouseY / gameState.gridSize) * gameState.gridSize + gameState.gridSize / 2;
            
            const onPath = isOnPath(x, y);
            const occupied = gameState.towers.some(t => Math.hypot(t.x - x, t.y - y) < 40);
            const canAfford = gameState.balance >= def.cost;
            const valid = !onPath && !occupied && canAfford;
            
            if (def.range > 0 && def.range < 9999) {
                // 智能合约需要显示两个范围圆圈
                if (gameState.selectedTower === 'contract') {
                    // 减速范围（外圈）
                    ctx.beginPath();
                    ctx.arc(x, y, def.range, 0, Math.PI * 2);
                    ctx.fillStyle = valid ? 'rgba(170, 0, 255, 0.15)' : 'rgba(255, 0, 68, 0.15)';
                    ctx.fill();
                    ctx.strokeStyle = valid ? '#aa00ff' : '#ff0044';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 真视范围（内圈）
                    ctx.beginPath();
                    ctx.arc(x, y, def.truesightRange, 0, Math.PI * 2);
                    ctx.fillStyle = valid ? 'rgba(255, 100, 255, 0.1)' : 'rgba(255, 0, 68, 0.1)';
                    ctx.fill();
                    ctx.strokeStyle = valid ? '#ff64ff' : '#ff0044';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else {
                    // 其他塔的正常范围显示
                    ctx.beginPath();
                    ctx.arc(x, y, def.range, 0, Math.PI * 2);
                    ctx.fillStyle = valid ? 'rgba(0, 255, 136, 0.15)' : 'rgba(255, 0, 68, 0.15)';
                    ctx.fill();
                    ctx.strokeStyle = valid ? '#00ff88' : '#ff0044';
                    ctx.stroke();
                }
            }
            
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.fillStyle = valid ? '#1a2a3a' : '#3a1a1a';
            ctx.fill();
            ctx.strokeStyle = def.color;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            const icons = { 
                validator: '🔐', miner: '⚡', gasStation: '⛽', contract: '📜',
                sharding: '💥', zkSniper: '🎯', l2Channel: '🌐', mainnetCannon: '☄️'
            };
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(icons[gameState.selectedTower], x, y + 7);
            ctx.textAlign = 'left';
            ctx.globalAlpha = 1;
        }
        
        // ==================== GAME LOGIC ====================
        function isOnPath(x, y) {
            const checkPath = (path) => {
                for (let i = 0; i < path.length - 1; i++) {
                    const p1 = path[i];
                    const p2 = path[i + 1];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const t = Math.max(0, Math.min(1, ((x - p1.x) * dx + (y - p1.y) * dy) / (len * len)));
                    const projX = p1.x + t * dx;
                    const projY = p1.y + t * dy;
                    const dist = Math.sqrt((x - projX) ** 2 + (y - projY) ** 2);
                    if (dist < 35) return true;
                }
                return false;
            };
            
            if (checkPath(gameState.path)) return true;
            if (gameState.path2 && checkPath(gameState.path2)) return true;
            return false;
        }
        
        function spawnEnemy(type, useSecondPath = false) {
            const def = enemyDefs[type];
            const path = useSecondPath && gameState.path2 ? gameState.path2 : gameState.path;
            
            if (!def.noPopup && !globalShownEnemyTypes.has(type)) {
                showEnemyModal(type);
            }
            
            // 计算随波次递增的生命值
            const waveNum = gameState.currentWave + 1;
            const baseGrowth = def.hpGrowth || 0.15;
            
            // 无尽模式：前15波线性增长，15-40波加速增长，40波后降低增长速率
            let hpMultiplier;
            if (gameState.level === 'endless' && waveNum > 15) {
                // 前15波的增长
                const wave15Multiplier = 1 + 14 * baseGrowth;
                
                if (waveNum <= 40) {
                    // 15-40波：使用更高的增长率（原增长率的2.5倍）+ 指数增长
                    const wavesAfter15 = waveNum - 15;
                    const acceleratedGrowth = baseGrowth * 2.5;
                    const exponentialFactor = Math.pow(1.08, wavesAfter15); // 每波额外8%指数增长
                    hpMultiplier = wave15Multiplier * (1 + wavesAfter15 * acceleratedGrowth) * exponentialFactor;
                } else {
                    // 40波后：大幅降低增长速率，使用较小的线性增长
                    const wave40Multiplier = wave15Multiplier * (1 + 25 * baseGrowth * 2.5) * Math.pow(1.08, 25);
                    const wavesAfter40 = waveNum - 40;
                    const slowGrowth = baseGrowth * 0.3; // 降低到原增长率的30%
                    hpMultiplier = wave40Multiplier * (1 + wavesAfter40 * slowGrowth);
                }
            } else {
                // 普通模式或前15波：保持原有线性增长
                hpMultiplier = 1 + (waveNum - 1) * baseGrowth;
            }
            
            // 根据难度调整生命值
            const difficultyMultiplier = gameState.difficulty === 'easy' ? 0.49 : (gameState.difficulty === 'hard' ? 1.0 : 0.7);
            const scaledHp = Math.floor(def.hp * hpMultiplier * difficultyMultiplier);
            
            const enemy = {
                x: path[0].x,
                y: path[0].y,
                renderX: path[0].x,
                renderY: path[0].y,
                type: type,
                hp: scaledHp,
                maxHp: scaledHp,
                speed: def.speed,
                color: def.color,
                isEvil: def.isEvil,
                size: def.size,
                pathIndex: 0,
                pathProgress: 0,
                frozen: false,
                frozenTimer: 0,
                revealed: !def.invisible,
                usePath2: useSecondPath && gameState.path2,
                damageReduction: def.damageReduction || 0,
                healsPerSecond: def.healsPerSecond || 0
            };
            gameState.enemies.push(enemy);
        }
        
        function showEnemyModal(type) {
            const def = enemyDefs[type];
            globalShownEnemyTypes.add(type);
            gameState.modalPaused = true;
            
            document.getElementById('enemyModalIcon').textContent = def.icon;
            document.getElementById('enemyModalIcon').style.color = def.color;
            document.getElementById('enemyModal').style.borderColor = def.color;
            
            // 使用翻译键获取敌人名称
            const nameKey = `enemy_${type}_name`;
            document.getElementById('enemyModalTitle').textContent = getText(nameKey) || def.name;
            document.getElementById('enemyModalTitle').style.color = def.color;
            
            // 使用翻译键获取描述和提示文本
            const descKey = `enemy_${type}_desc`;
            const tipKey = `enemy_${type}_tip`;
            document.getElementById('enemyModalDesc').textContent = getText(descKey) || def.description;
            document.getElementById('enemyModalTipText').textContent = getText(tipKey) || def.tip;
            
            document.getElementById('enemyModalOverlay').style.display = 'flex';
            
            sound.modalOpen();
        }
        
        function closeEnemyModal() {
            document.getElementById('enemyModalOverlay').style.display = 'none';
            gameState.modalPaused = false;
            sound.uiClick();
        }
        
        function showEnemyInfo(enemy) {
            const def = enemyDefs[enemy.type];
            gameState.selectedEnemy = enemy;
            
            // 更新面板内容
            document.getElementById('enemyInfoIcon').textContent = def.icon;
            // 使用翻译键获取敌人名称
            const nameKey = `enemy_${enemy.type}_name`;
            document.getElementById('enemyInfoName').textContent = getText(nameKey) || def.name;
            document.getElementById('enemyInfoType').textContent = enemy.type;
            document.getElementById('enemyInfoHp').textContent = Math.ceil(enemy.hp);
            document.getElementById('enemyInfoMaxHp').textContent = enemy.maxHp;
            document.getElementById('enemyInfoSpeed').textContent = def.speed.toFixed(1);
            // 合法交易到达终点奖励5 GAS，恶意敌人被击杀奖励为定义中的reward
            const rewardAmount = enemy.isEvil ? def.reward : 5;
            document.getElementById('enemyInfoReward').textContent = rewardAmount + ' GAS';
            
            // 更新血条
            const hpPercent = (enemy.hp / enemy.maxHp) * 100;
            document.getElementById('enemyInfoHpBar').style.width = hpPercent + '%';
            
            // 显示特殊能力
            let specialText = '';
            if (def.invisible) specialText = '隐身';
            else if (def.splits) specialText = '死亡分裂';
            else if (def.damageReduction) specialText = `减伤${Math.round(def.damageReduction * 100)}%`;
            else if (def.healsPerSecond) specialText = `回血${def.healsPerSecond}%/s`;
            else if (!enemy.isEvil) specialText = '合法交易';
            
            if (specialText) {
                document.getElementById('enemyInfoSpecial').style.display = 'block';
                document.getElementById('enemyInfoSpecialText').textContent = specialText;
            } else {
                document.getElementById('enemyInfoSpecial').style.display = 'none';
            }
            
            // 显示面板
            document.getElementById('enemyInfoPanel').style.display = 'block';
            sound.uiClick();
        }
        
        function closeEnemyInfo() {
            document.getElementById('enemyInfoPanel').style.display = 'none';
            gameState.selectedEnemy = null;
        }
        
        function updateEnemyInfoPanel() {
            // 如果没有选中的敌人，不更新
            if (!gameState.selectedEnemy) return;
            
            const enemy = gameState.selectedEnemy;
            
            // 检查敌人是否还存活
            if (!gameState.enemies.includes(enemy)) {
                closeEnemyInfo();
                return;
            }
            
            // 实时更新血量
            document.getElementById('enemyInfoHp').textContent = Math.ceil(enemy.hp);
            const hpPercent = (enemy.hp / enemy.maxHp) * 100;
            document.getElementById('enemyInfoHpBar').style.width = hpPercent + '%';
        }
        
        function showKnowledgeModal(level) {
            const k = level.knowledge;
            const towerType = level.unlockTower;
            const card = knowledgeCards.towers[towerType];
            
            gameState.modalPaused = true;
            
            // 为不同的塔设置不同的图标大小，让所有图标看起来一样大
            const iconSizes = {
                validator: '160px',  // 验证节点作为基准
                miner: '160px',
                gasStation: '160px',
                contract: '160px',
                sharding: '200px',   // 分片炮需要更大
                zkSniper: '200px',   // ZK狙击需要更大
                l2Channel: '200px',  // L2通道需要更大
                mainnetCannon: '200px' // 主网大炮需要更大
            };
            const fontSize = iconSizes[towerType] || '160px';
            document.getElementById('knowledgeModalIcon').innerHTML = `<div style="font-size: ${fontSize}; line-height: 1; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">${k.icon}</div>`;
            
            // 使用翻译系统获取标题
            const titleKey = `knowledge_${towerType}_title`;
            document.getElementById('knowledgeModalTitle').textContent = getText(titleKey);
            
            // 使用翻译系统构建描述
            if (card) {
                const desc = `
                    <div style="text-align: left; line-height: 1.8;">
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_principle')}：</strong>${getText(`knowledge_${towerType}_principle`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_analogy')}：</strong>${getText(`knowledge_${towerType}_analogy`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_application')}：</strong>${getText(`knowledge_${towerType}_application`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_gameplay')}：</strong>${getText(`knowledge_${towerType}_gameplay`)}</div>
                    </div>
                `;
                document.getElementById('knowledgeModalDesc').innerHTML = desc;
            } else {
                document.getElementById('knowledgeModalDesc').textContent = k.desc;
            }
            
            document.getElementById('knowledgeModalOverlay').style.display = 'flex';
            
            sound.modalOpen();
        }
        
        // 依次显示多个塔的知识介绍
        function showMultipleTowerKnowledge(towerTypes, index) {
            if (index >= towerTypes.length) {
                return; // 所有塔介绍完毕
            }
            
            const towerType = towerTypes[index];
            const card = knowledgeCards.towers[towerType];
            const towerDef = towerDefs[towerType];
            
            if (!card || !towerDef) {
                // 如果没有数据，跳到下一个
                showMultipleTowerKnowledge(towerTypes, index + 1);
                return;
            }
            
            gameState.modalPaused = true;
            
            // 设置图标和标题 - 在方框中心显示防御塔图标
            const icons = { 
                validator: '🔐', miner: '⚡', gasStation: '⛽', contract: '📜',
                sharding: '💥', zkSniper: '🎯', l2Channel: '🌐', mainnetCannon: '☄️'
            };
            // 为不同的塔设置不同的图标大小，让所有图标看起来一样大
            const iconSizes = {
                validator: '160px',  // 验证节点作为基准
                miner: '160px',
                gasStation: '160px',
                contract: '160px',
                sharding: '200px',   // 分片炮需要更大
                zkSniper: '200px',   // ZK狙击需要更大
                l2Channel: '200px',  // L2通道需要更大
                mainnetCannon: '200px' // 主网大炮需要更大
            };
            const iconElement = document.getElementById('knowledgeModalIcon');
            // 调试：输出towerType和对应的图标
            console.log('Tower Type:', towerType, 'Icon:', icons[towerType]);
            const fontSize = iconSizes[towerType] || '160px';
            iconElement.innerHTML = `<div style="font-size: ${fontSize}; line-height: 1; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">${icons[towerType] || '📚'}</div>`;
            const titleKey = `knowledge_${towerType}_title`;
            document.getElementById('knowledgeModalTitle').textContent = `${getText(titleKey)} - ${getTowerName(towerType, 1)}`;
            
            // 使用翻译系统构建描述，添加关键词高亮
            function highlightKeywords(text) {
                // 高亮关键词：私钥、公钥、Gas、金币、减速、签名等
                const keywords = {
                    '私钥': '#ff6b6b',
                    '公钥': '#4ecdc4',
                    'Gas': '#ffd700',
                    'GAS': '#ffd700',
                    '金币': '#ffd700',
                    '减速': '#00ff88',
                    '签名': '#00ffff',
                    '攻击速度': '#ff6b6b',
                    '范围': '#4ecdc4',
                    '伤害': '#ff6b6b',
                    '收入': '#ffd700',
                    '隐身': '#9b59b6',
                    '并行': '#00ff88',
                    '激光': '#ff6b6b'
                };
                
                let result = text;
                for (const [keyword, color] of Object.entries(keywords)) {
                    const regex = new RegExp(keyword, 'g');
                    result = result.replace(regex, `<span style="color: ${color}; font-weight: bold;">${keyword}</span>`);
                }
                return result;
            }
            
            const desc = `
                <div style="text-align: left; line-height: 1.7; font-size: 13px;">
                    <div style="margin-bottom: 10px;"><strong style="color: #00ffff;">${getText('knowledge_label_principle_icon')}</strong>${highlightKeywords(getText(`knowledge_${towerType}_principle`))}</div>
                    <div style="margin-bottom: 10px;"><strong style="color: #00ffff;">${getText('knowledge_label_gameplay_icon')}</strong>${highlightKeywords(getText(`knowledge_${towerType}_gameplay`))}</div>
                </div>
            `;
            document.getElementById('knowledgeModalDesc').innerHTML = desc;
            
            // 修改按钮文本和行为
            const btn = document.querySelector('#knowledgeModalOverlay .enemy-modal-btn');
            if (index < towerTypes.length - 1) {
                btn.textContent = `${getText('btn_next_tower')} (${index + 1}/${towerTypes.length})`;
                btn.onclick = () => {
                    document.getElementById('knowledgeModalOverlay').style.display = 'none';
                    sound.uiClick();
                    setTimeout(() => showMultipleTowerKnowledge(towerTypes, index + 1), 300);
                };
            } else {
                btn.textContent = getText('btn_start_challenge');
                btn.onclick = () => {
                    closeKnowledgeModal();
                };
            }
            
            document.getElementById('knowledgeModalOverlay').style.display = 'flex';
            sound.modalOpen();
        }
        
        function closeKnowledgeModal() {
            document.getElementById('knowledgeModalOverlay').style.display = 'none';
            gameState.modalPaused = false;
            sound.uiClick();
            // 不自动开始波次，等待玩家点击出口图标
        }
        
        function updateEnemies() {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const def = enemyDefs[enemy.type];
                const path = enemy.usePath2 ? gameState.path2 : gameState.path;
                
                if (enemy.healsPerSecond > 0 && enemy.hp < enemy.maxHp) {
                    let healAmount = enemy.healsPerSecond / 60;
                    
                    // 应用回血压制
                    if (enemy.healSuppressed) {
                        healAmount *= (1 - enemy.healSuppressed);
                    }
                    
                    enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
                }
                
                if (enemy.frozen) {
                    enemy.frozenTimer -= 16;
                    if (enemy.frozenTimer <= 0) enemy.frozen = false;
                    continue;
                }
                
                // 检查敌人是否已经到达或超过终点
                if (enemy.pathIndex >= path.length) {
                    // 敌人到达终点
                    if (enemy.isEvil) {
                        // 恶意敌人（包括小碎片splitChild）到达终点，扣除生命值
                        gameState.lives--;
                        console.log(`恶意敌人到达终点: ${enemy.type}, isEvil: ${enemy.isEvil}, 剩余生命: ${gameState.lives}/${gameState.maxLives}`);
                        sound.enemyHit();
                        addFloatingText(enemy.x, enemy.y, `-1 ${getText('float_life')}`, '#ff0044');
                        
                        // 生命值归零，游戏结束
                        if (gameState.lives <= 0) {
                            console.log('生命值归零，游戏结束！');
                            gameState.gameOver = true;
                        }
                    } else {
                        // 合法交易必须被验证过才能获得奖励
                        if (enemy.verified) {
                            gameState.txCount++;
                            gameState.balance += 5; // 合法交易到达终点奖励5 GAS
                            sound.txValid();
                            addFloatingText(enemy.x, enemy.y, '+1 TX', '#00ff88');
                            addFloatingText(enemy.x, enemy.y - 20, '+5 GAS', '#ffff00');
                        } else {
                            // 未验证的合法交易不计数也不给钱
                            sound.enemyHit();
                            addFloatingText(enemy.x, enemy.y, getText('float_unverified'), '#ff8800');
                        }
                    }
                    gameState.enemies.splice(i, 1);
                    updateUI();
                    continue;
                }
                
                // 敌人在路径上移动
                if (enemy.pathIndex < path.length - 1) {
                    const current = path[enemy.pathIndex];
                    const next = path[enemy.pathIndex + 1];
                    const dx = next.x - current.x;
                    const dy = next.y - current.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // 应用减速效果
                    let effectiveSpeed = enemy.speed;
                    if (enemy.slowed && enemy.slowFactor) {
                        effectiveSpeed *= enemy.slowFactor;
                    }
                    // 重置减速标记（每帧重新检测）
                    enemy.slowed = false;
                    
                    enemy.pathProgress += effectiveSpeed / dist;
                    
                    if (enemy.pathProgress >= 1) {
                        enemy.pathProgress = 0;
                        enemy.pathIndex++;
                        if (enemy.pathIndex < path.length) {
                            enemy.x = path[enemy.pathIndex].x;
                            enemy.y = path[enemy.pathIndex].y;
                        }
                    }
                    
                    if (enemy.pathIndex < path.length - 1) {
                        const curr = path[enemy.pathIndex];
                        const nxt = path[enemy.pathIndex + 1];
                        enemy.x = curr.x + (nxt.x - curr.x) * enemy.pathProgress;
                        enemy.y = curr.y + (nxt.y - curr.y) * enemy.pathProgress;
                    }
                    
                    enemy.renderX += (enemy.x - enemy.renderX) * 0.2;
                    enemy.renderY += (enemy.y - enemy.renderY) * 0.2;
                } else if (enemy.pathIndex === path.length - 1) {
                    // 在最后一个路径点，继续向前移动一小段距离后到达终点
                    // 应用减速效果
                    let effectiveSpeed = enemy.speed;
                    if (enemy.slowed && enemy.slowFactor) {
                        effectiveSpeed *= enemy.slowFactor;
                    }
                    enemy.slowed = false;
                    
                    // 继续增加 pathProgress，当达到1时，pathIndex 会增加
                    enemy.pathProgress += effectiveSpeed / 50; // 使用固定距离50
                    
                    if (enemy.pathProgress >= 1) {
                        enemy.pathIndex++; // 增加到 path.length，下一帧会被删除
                    }
                    
                    enemy.renderX += (enemy.x - enemy.renderX) * 0.2;
                    enemy.renderY += (enemy.y - enemy.renderY) * 0.2;
                }
                
                if (enemy.hp <= 0) {
                    for (let j = 0; j < 15; j++) {
                        gameState.particles.push({
                            x: enemy.x, y: enemy.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 30,
                            color: enemy.color || def.color,
                            size: Math.random() * 6 + 2
                        });
                    }
                    
                    if (enemy.type === 'splitter') {
                        for (let j = 0; j < 3; j++) {
                            setTimeout(() => {
                                const child = {
                                    x: enemy.x + (Math.random() - 0.5) * 20,
                                    y: enemy.y + (Math.random() - 0.5) * 20,
                                    renderX: enemy.x,
                                    renderY: enemy.y,
                                    type: 'splitChild',
                                    hp: enemyDefs.splitChild.hp,
                                    maxHp: enemyDefs.splitChild.hp,
                                    speed: enemyDefs.splitChild.speed,
                                    color: enemyDefs.splitChild.color,
                                    isEvil: true,
                                    size: enemyDefs.splitChild.size,
                                    pathIndex: enemy.pathIndex,
                                    pathProgress: enemy.pathProgress,
                                    frozen: false, frozenTimer: 0,
                                    revealed: true,
                                    usePath2: enemy.usePath2
                                };
                                gameState.enemies.push(child);
                            }, j * 100);
                        }
                    }
                    
                    if (enemy.isEvil) {
                        if (enemy.type === 'boss') sound.bossDeath();
                        else sound.enemyDeath();
                        gameState.balance += def.reward;
                        addFloatingText(enemy.x, enemy.y, '+' + def.reward + ' GAS', '#ffff00');
                    }
                    
                    gameState.enemies.splice(i, 1);
                    updateUI();
                }
            }
        }
        
        function updateTowers() {
            gameState.laserBeams = [];
            
            // 重置所有塔的真视状态和加速buff（每帧重新检测）
            for (const tower of gameState.towers) {
                const def = towerDefs[tower.type];
                // 保留塔定义中自带的真视属性（如ZK狙击塔）
                tower.truesight = def.truesight || false;
                tower.buffed = false;
                tower.speedBoostValue = 0;
            }
            
            for (const tower of gameState.towers) {
                const def = towerDefs[tower.type];
                tower.cooldown -= 16;
                tower.attacking = false;
                
                // 矿机周期性产钱（只有在波次开始后才运行）
                if (tower.type === 'miner') {
                    // 矿机在第一波开始后持续工作，包括波次间隔期间
                    const hasStartedFirstWave = gameState.currentWave > 0 || gameState.waveInProgress || gameState.wavePreparation;
                    
                    if (hasStartedFirstWave) {
                        const stats = getTowerStats(tower);
                        if (!tower.miningTimer) {
                            tower.miningTimer = def.miningInterval;
                        }
                        
                        tower.miningTimer -= 16;
                        
                        if (tower.miningTimer <= 0) {
                            tower.miningTimer = def.miningInterval;
                            const reward = stats.miningReward;
                            gameState.balance += reward;
                            sound.attackMiner();
                            addFloatingText(tower.x, tower.y - 30, '+' + reward + ' GAS', '#ffff00');
                            updateUI();
                            
                            // 挖矿动画效果
                            for (let j = 0; j < 10; j++) {
                                gameState.particles.push({
                                    x: tower.x,
                                    y: tower.y,
                                    vx: (Math.random() - 0.5) * 5,
                                    vy: -Math.random() * 5 - 2,
                                    life: 30,
                                    color: '#ffaa00',
                                    size: Math.random() * 6 + 3
                                });
                            }
                        }
                    }
                    continue;
                }
                
                if (tower.type === 'gasStation') {
                    const stats = getTowerStats(tower); // 获取当前等级的属性
                    for (const other of gameState.towers) {
                        if (other === tower) continue;
                        if (other.type === 'mainnetCannon') continue; // 主网大炮不受加油站影响
                        const dist = Math.hypot(other.x - tower.x, other.y - tower.y);
                        if (dist < stats.range) {
                            other.buffed = true; // 使用等级相关的范围
                            other.speedBoostValue = stats.speedBoost; // 记录实际的加速值
                        }
                    }
                    for (const enemy of gameState.enemies) {
                        const dist = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                        if (dist < stats.range && Math.random() < 0.01) { // 使用等级相关的范围
                            gameState.balance += 1;
                            addFloatingText(enemy.x, enemy.y, '+1', '#ffff00');
                            updateUI();
                        }
                    }
                    continue;
                }
                
                // 合约门光环效果：减速并显形，给范围内的塔提供反隐能力
                if (tower.type === 'contract') {
                    const stats = getTowerStats(tower); // 获取当前等级的属性
                    // 给范围内的其他塔提供反隐能力
                    for (const other of gameState.towers) {
                        if (other === tower) continue;
                        const dist = Math.hypot(other.x - tower.x, other.y - tower.y);
                        if (dist < stats.truesightRange) { // 使用等级相关的真视范围
                            other.truesight = true; // 真视能力
                        }
                    }
                    
                    // 对范围内的敌人：减速并显形
                    for (const enemy of gameState.enemies) {
                        if (!enemy.isEvil) continue; // 不影响合法交易
                        const dist = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                        if (dist < stats.range) { // 使用等级相关的范围
                            // 显形隐身敌人
                            if (!enemy.revealed) {
                                enemy.revealed = true;
                                addFloatingText(enemy.x, enemy.y - 30, getText('float_detected'), '#ff00ff');
                            }
                            // 标记为被减速
                            enemy.slowed = true;
                            enemy.slowFactor = stats.slowFactor; // 使用等级相关的减速效果
                        }
                    }
                    continue;
                }
                
                if (tower.type === 'mainnetCannon') continue;
                
                if (tower.type === 'l2Channel') {
                    const stats = getTowerStats(tower);
                    // 初始化L2通道状态
                    if (!tower.laserState) {
                        tower.laserState = 'idle'; // idle, firing, cooldown
                        tower.laserTimer = 0;
                        tower.laserAngle = null;
                    }
                    
                    // 更新计时器
                    tower.laserTimer -= 16;
                    
                    if (tower.laserState === 'idle') {
                        // 初始化索敌优先级（如果没有设置）
                        if (!tower.targetPriority) {
                            tower.targetPriority = 'first';
                        }
                        
                        // 使用索敌优先级选择目标
                        const targetEnemy = selectTargetByPriority(tower, stats, gameState.enemies);
                        
                        // 发现敌人，开始射击
                        if (targetEnemy) {
                            tower.laserState = 'firing';
                            tower.laserTimer = stats.laserDuration;
                            tower.laserAngle = Math.atan2(targetEnemy.y - tower.y, targetEnemy.x - tower.x);
                            sound.attackL2();
                        }
                    } else if (tower.laserState === 'firing') {
                        // 射击中，绘制激光并造成伤害
                        const laserLength = 3000; // 贯穿全图
                        const endX = tower.x + Math.cos(tower.laserAngle) * laserLength;
                        const endY = tower.y + Math.sin(tower.laserAngle) * laserLength;
                        
                        gameState.laserBeams.push({
                            x1: tower.x, y1: tower.y,
                            x2: endX, y2: endY,
                            alpha: 0.7 + Math.sin(Date.now() * 0.02) * 0.3
                        });
                        
                        // 对激光路径上的所有敌人造成伤害
                        for (const enemy of gameState.enemies) {
                            if (!enemy.isEvil) continue;
                            
                            // 隐形敌人无法被激光伤害（除非有真视）
                            const enemyDef = enemyDefs[enemy.type];
                            if (enemyDef.invisible && !enemy.revealed && !tower.truesight) continue;
                            
                            const dist = pointToLineDistance(enemy.x, enemy.y, tower.x, tower.y, endX, endY);
                            if (dist < 25) {
                                let frameDamage = stats.damage / 60; // 每帧伤害
                                
                                // Layer 2特攻倍率（重新平衡：根据等级动态变化）
                                const towerLevel = tower.level || 1;
                                const damageMultipliers = [1.2, 1.3, 1.4, 1.6, 1.7, 1.8, 2.0, 2.1, 2.3, 2.5];
                                const suppressRates = [0.40, 0.45, 0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85];
                                
                                // Layer 2对回血怪：动态倍率伤害 + 动态压制回血
                                if (enemy.type === 'healer') {
                                    const mult = damageMultipliers[towerLevel - 1] || 2.5;
                                    const suppress = suppressRates[towerLevel - 1] || 0.85;
                                    frameDamage *= mult;
                                    enemy.healSuppressed = suppress;
                                    
                                    if (Math.random() < 0.05) {
                                        addFloatingText(enemy.x, enemy.y - 25, getText('float_suppress'), '#ffcc00');
                                    }
                                }
                                // Layer 2对BOSS：较低倍率 + 较低压制
                                else if (enemy.type === 'boss' && enemy.healsPerSecond > 0) {
                                    const mult = (damageMultipliers[towerLevel - 1] || 2.5) * 0.6; // BOSS倍率降低
                                    const suppress = (suppressRates[towerLevel - 1] || 0.85) * 0.6; // BOSS压制降低
                                    frameDamage *= mult;
                                    enemy.healSuppressed = suppress;
                                }
                                else {
                                    enemy.healSuppressed = 0;
                                }
                                
                                enemy.hp -= frameDamage;
                            } else if (enemy.healSuppressed) {
                                enemy.healSuppressed = 0; // 离开激光范围，解除压制
                            }
                        }
                        
                        // 射击时间结束
                        if (tower.laserTimer <= 0) {
                            tower.laserState = 'cooldown';
                            tower.laserTimer = def.laserCooldown;
                        }
                    } else if (tower.laserState === 'cooldown') {
                        // 冷却中
                        if (tower.laserTimer <= 0) {
                            tower.laserState = 'idle';
                        }
                    }
                    
                    continue;
                }
                
                if (tower.cooldown > 0) continue;
                
                const stats = getTowerStats(tower);
                
                // 初始化索敌优先级（如果没有设置）
                if (!tower.targetPriority) {
                    tower.targetPriority = 'first';
                }
                
                // 根据索敌优先级选择目标
                let target = selectTargetByPriority(tower, stats, gameState.enemies);
                
                
                if (target) {
                    tower.attacking = true;
                    // 使用实际的加速效果，如果没有被加速则为1（无加速）
                    const cooldownMod = tower.buffed ? (1 - (tower.speedBoostValue || 0.25)) : 1;
                    tower.cooldown = stats.attackSpeed * 1000 * cooldownMod;
                    // 不再重置buff，因为buff会在每帧开始时统一重置和重新应用
                    
                    const sounds = {
                        validator: () => sound.attackValidator(),
                        sharding: () => sound.attackSharding(),
                        zkSniper: () => sound.attackZK()
                    };
                    if (sounds[tower.type]) sounds[tower.type]();
                    
                    const proj = {
                        x: tower.x, y: tower.y,
                        startX: tower.x, startY: tower.y,
                        targetX: target.x, targetY: target.y,
                        target: target,
                        damage: stats.damage,
                        color: def.color,
                        type: tower.type,
                        speed: tower.type === 'zkSniper' ? 50 : (tower.type === 'miner' ? 8 : 15),
                        piercing: def.piercing,
                        aoeRadius: stats.aoeRadius || def.aoeRadius,
                        tower: tower  // 保存tower引用用于机制杀
                    };
                    gameState.projectiles.push(proj);
                }
            }
        }
        
        function findNearestPathPoint(x, y) {
            let nearestDist = Infinity;
            let nearest = { x: x + 100, y: y };
            
            const checkPath = (path) => {
                for (let i = 0; i < path.length - 1; i++) {
                    const midX = (path[i].x + path[i+1].x) / 2;
                    const midY = (path[i].y + path[i+1].y) / 2;
                    const dist = Math.hypot(midX - x, midY - y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = { x: midX, y: midY };
                    }
                }
            };
            
            checkPath(gameState.path);
            if (gameState.path2) checkPath(gameState.path2);
            return nearest;
        }
        
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            return Math.hypot(px - xx, py - yy);
        }
        
        function updateProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const p = gameState.projectiles[i];
                
                if (p.target && p.target.hp > 0) {
                    p.targetX = p.target.x;
                    p.targetY = p.target.y;
                }
                
                const dx = p.targetX - p.x;
                const dy = p.targetY - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < p.speed) {
                    if (p.aoeRadius) {
                        for (const enemy of gameState.enemies) {
                            const d = Math.hypot(enemy.x - p.targetX, enemy.y - p.targetY);
                            if (d < p.aoeRadius && enemy.isEvil) {
                                dealDamage(enemy, p.damage, p.piercing, p.type, p.tower);
                            }
                        }
                        for (let j = 0; j < 20; j++) {
                            gameState.particles.push({
                                x: p.targetX, y: p.targetY,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10,
                                life: 20,
                                color: p.color,
                                size: Math.random() * 8 + 3
                            });
                        }
                    } else if (p.target && p.target.hp > 0) {
                        dealDamage(p.target, p.damage, p.piercing, p.type, p.tower);
                    }
                    gameState.projectiles.splice(i, 1);
                } else {
                    p.x += (dx / dist) * p.speed;
                    p.y += (dy / dist) * p.speed;
                }
            }
        }
        
        function dealDamage(enemy, damage, piercing, type, tower) {
            // 合法交易不受伤害（除了验证哨的验证）
            if (!enemy.isEvil) {
                // 验证哨击中合法交易时进行验证
                if (type === 'validator' && !enemy.verified) {
                    enemy.verified = true;
                    enemy.speed = 4.0; // 加速
                    addFloatingText(enemy.x, enemy.y - 20, getText('float_verified'), '#00ff88');
                    sound.enemyHit();
                }
                return; // 合法交易无敌，不受任何伤害
            }
            
            // 隐形且未被显形的敌人无法受伤（除非攻击者有真视能力）
            const enemyDef = enemyDefs[enemy.type];
            const attackerHasTruesight = tower && tower.truesight;
            if (enemyDef.invisible && !enemy.revealed && !attackerHasTruesight) {
                addFloatingText(enemy.x, enemy.y - 20, getText('float_miss'), '#888888');
                return;
            }
            
            let actualDamage = damage;
            
            // === 特攻系统：根据塔等级动态变化的克制倍率 ===
            const towerLevel = tower ? (tower.level || 1) : 1;
            
            // 特攻倍率表（重新平衡：降低倍率）
            const multipliers = {
                'validator-spam': [1.2, 1.3, 1.4, 1.6, 1.7, 1.8, 2.0, 2.1, 2.3, 2.5],
                'zkSniper-shielded': [1.5, 1.6, 1.7, 1.9, 2.0, 2.1, 2.3, 2.4, 2.6, 2.8],
                'zkSniper-boss': [1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0],
                'sharding-splitter': [1.2, 1.3, 1.4, 1.6, 1.7, 1.8, 2.0, 2.1, 2.3, 2.5],
                'sharding-splitChild': [1.2, 1.3, 1.4, 1.6, 1.7, 1.8, 2.0, 2.1, 2.3, 2.5],
                'l2Channel-healer': [1.2, 1.3, 1.4, 1.6, 1.7, 1.8, 2.0, 2.1, 2.3, 2.5]
            };
            
            // 1. 验证哨对垃圾交易：动态倍率
            if (type === 'validator' && enemy.type === 'spam') {
                const mult = multipliers['validator-spam'][towerLevel - 1] || 2.5;
                actualDamage = damage * mult;
                addFloatingText(enemy.x, enemy.y - 25, getText('float_purge'), '#00ffff');
            }
            // 2. ZK狙击对双花幽灵：2倍伤害（自带真视）
            else if (type === 'zkSniper' && enemy.type === 'doubleSpend') {
                actualDamage = damage * 2.0;
                addFloatingText(enemy.x, enemy.y - 25, getText('float_pierce'), '#ff00aa');
            }
            // 3. ZK狙击对装甲怪：动态倍率（无视护盾）
            else if (type === 'zkSniper' && enemy.type === 'shielded') {
                const mult = multipliers['zkSniper-shielded'][towerLevel - 1] || 2.8;
                actualDamage = damage * mult;
                addFloatingText(enemy.x, enemy.y - 25, getText('float_pierce'), '#ff00aa');
            }
            // 4. ZK狙击对BOSS：动态倍率
            else if (type === 'zkSniper' && enemy.type === 'boss') {
                const mult = multipliers['zkSniper-boss'][towerLevel - 1] || 2.0;
                actualDamage = damage * mult;
                addFloatingText(enemy.x, enemy.y - 25, getText('float_critical'), '#ff00aa');
            }
            // 4. 分片炮对分裂怪：动态倍率
            else if (type === 'sharding' && enemy.type === 'splitter') {
                const mult = multipliers['sharding-splitter'][towerLevel - 1] || 2.5;
                actualDamage = damage * mult;
                addFloatingText(enemy.x, enemy.y - 25, getText('float_shatter'), '#0088ff');
            }
            else if (type === 'sharding' && enemy.type === 'splitChild') {
                const mult = multipliers['sharding-splitChild'][towerLevel - 1] || 2.5;
                actualDamage = damage * mult;
                addFloatingText(enemy.x, enemy.y - 25, getText('float_shatter'), '#0088ff');
            }
            // 5. 护盾减伤（穿透攻击无视）
            else if (enemy.damageReduction > 0 && !piercing) {
                actualDamage *= (1 - enemy.damageReduction);
                if (enemy.damageReduction >= 0.5) {
                    addFloatingText(enemy.x, enemy.y - 20, getText('float_blocked'), '#888888');
                }
            }
            
            enemy.hp -= actualDamage;
            sound.enemyHit();
            
            // 伤害粒子效果
            const isMechanicKill = actualDamage > damage * 2;
            const particleCount = isMechanicKill ? 10 : 5; // 机制杀产生更多粒子
            let particleColor = '#ffffff';
            
            // 机制杀使用特殊颜色
            if (isMechanicKill) {
                if (type === 'validator') particleColor = '#00ffff';
                else if (type === 'zkSniper') particleColor = '#ff00aa';
                else if (type === 'sharding') particleColor = '#0088ff';
            }
            
            for (let j = 0; j < particleCount; j++) {
                gameState.particles.push({
                    x: enemy.x, y: enemy.y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 15,
                    color: particleColor,
                    size: isMechanicKill ? 4 : 3
                });
            }
        }
        
        function fireMainnetCannon(event) {
            if (!gameState.cannonTargetMode) return;
            
            const x = event.clientX;
            const y = event.clientY;
            
            if (gameState.balance < 150) {
                addFloatingText(x, y, getText('float_not_enough_gas'), '#ff0044');
                sound.towerError();
                return;
            }
            
            gameState.balance -= 150;
            sound.attackMainnet();
            
            for (const enemy of gameState.enemies) {
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist < 120 && enemy.isEvil) {
                    // 隐形敌人无法被主网大炮伤害
                    const enemyDef = enemyDefs[enemy.type];
                    if (enemyDef.invisible && !enemy.revealed) continue;
                    
                    let baseDamage = 200;
                    
                    // 无尽模式下，主网大炮伤害随波次增长
                    if (gameState.currentLevel === 6) {
                        const wave = gameState.currentWave;
                        if (wave <= 15) {
                            // 前15波：线性增长
                            baseDamage = 200 * (1 + wave * 0.1);
                        } else if (wave <= 40) {
                            // 15-40波：加速增长，匹配敌人HP增长
                            const baseGrowth = 200 * (1 + 15 * 0.1);
                            const extraWaves = wave - 15;
                            const acceleratedGrowth = Math.pow(1.08, extraWaves) * 2.5;
                            baseDamage = baseGrowth * acceleratedGrowth;
                        } else {
                            // 40波后：降低增长速率
                            const wave40Damage = 200 * (1 + 15 * 0.1) * Math.pow(1.08, 25) * 2.5;
                            const extraWaves = wave - 40;
                            const slowGrowth = 1 + extraWaves * 0.03; // 每波增长3%
                            baseDamage = wave40Damage * slowGrowth;
                        }
                    }
                    
                    let damage = baseDamage;
                    
                    // 主网大炮对BOSS：30%当前HP伤害（取较大值）
                    if (enemy.type === 'boss') {
                        const percentDamage = enemy.hp * 0.3;
                        damage = Math.max(damage, percentDamage);
                        addFloatingText(enemy.x, enemy.y - 25, getText('float_mainnet_strike'), '#ff4400');
                    }
                    
                    enemy.hp -= damage;
                }
            }
            
            for (let i = 0; i < 50; i++) {
                gameState.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 40,
                    color: '#ff4400',
                    size: Math.random() * 15 + 5
                });
            }
            
            addFloatingText(x, y, '☄️ -150 GAS', '#ff6600');
            
            exitCannonMode();
            updateUI();
        }
        
        function exitCannonMode() {
            gameState.cannonTargetMode = false;
            document.getElementById('cannonTargetOverlay').style.display = 'none';
            const previewCanvas = document.getElementById('cannonPreviewCanvas');
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        }
        
        function updateCannonPreview(event) {
            if (!gameState.cannonTargetMode) return;
            
            const previewCanvas = document.getElementById('cannonPreviewCanvas');
            const previewCtx = previewCanvas.getContext('2d');
            
            // 设置canvas尺寸
            if (previewCanvas.width !== window.innerWidth || previewCanvas.height !== window.innerHeight) {
                previewCanvas.width = window.innerWidth;
                previewCanvas.height = window.innerHeight;
            }
            
            // 清空画布
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            const x = event.clientX;
            const y = event.clientY;
            const radius = 120; // 主网大炮的攻击范围
            
            // 绘制外圈（红色警告圈）
            previewCtx.beginPath();
            previewCtx.arc(x, y, radius, 0, Math.PI * 2);
            previewCtx.strokeStyle = 'rgba(255, 68, 0, 0.8)';
            previewCtx.lineWidth = 3;
            previewCtx.stroke();
            
            // 绘制内圈填充
            previewCtx.beginPath();
            previewCtx.arc(x, y, radius, 0, Math.PI * 2);
            previewCtx.fillStyle = 'rgba(255, 68, 0, 0.15)';
            previewCtx.fill();
            
            // 绘制中心十字准星
            previewCtx.strokeStyle = 'rgba(255, 68, 0, 0.9)';
            previewCtx.lineWidth = 2;
            previewCtx.beginPath();
            previewCtx.moveTo(x - 15, y);
            previewCtx.lineTo(x + 15, y);
            previewCtx.moveTo(x, y - 15);
            previewCtx.lineTo(x, y + 15);
            previewCtx.stroke();
            
            // 绘制脉冲效果
            const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
            previewCtx.beginPath();
            previewCtx.arc(x, y, radius * pulse, 0, Math.PI * 2);
            previewCtx.strokeStyle = `rgba(255, 68, 0, ${0.4 * pulse})`;
            previewCtx.lineWidth = 2;
            previewCtx.stroke();
        }
        
        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.vy += 0.2;
                if (p.life <= 0) gameState.particles.splice(i, 1);
            }
        }
        
        function addFloatingText(x, y, text, color) {
            gameState.floatingTexts.push({ x, y, text, color, life: 60, vy: -2 });
        }
        
        function updateFloatingTexts() {
            for (let i = gameState.floatingTexts.length - 1; i >= 0; i--) {
                const t = gameState.floatingTexts[i];
                t.y += t.vy;
                t.life--;
                if (t.life <= 0) gameState.floatingTexts.splice(i, 1);
            }
        }
        
        function placeTower(type, x, y) {
            const def = towerDefs[type];
            if (!gameState.unlockedTowers.includes(type)) return false;
            if (gameState.balance < def.cost) return false;
            if (isOnPath(x, y)) return false;
            if (gameState.towers.some(t => Math.hypot(t.x - x, t.y - y) < 40)) return false;
            
            // Mainnet cannon limit: only 1 per level
            if (type === 'mainnetCannon') {
                const cannonCount = gameState.towers.filter(t => t.type === 'mainnetCannon').length;
                if (cannonCount >= 1) {
                    addFloatingText(x, y, getText('float_cannon_limit'), '#ff0044');
                    return false;
                }
            }
            
            // Miner limit: maximum 5 per level
            if (type === 'miner') {
                const minerCount = gameState.towers.filter(t => t.type === 'miner').length;
                if (minerCount >= 5) {
                    addFloatingText(x, y, getText('float_miner_limit'), '#ff0044');
                    return false;
                }
            }
            
            gameState.balance -= def.cost;
            gameState.towers.push({
                x, y, type,
                level: 1,  // 初始等级为1
                totalInvested: def.cost,  // 记录总投入（建造+升级）
                cooldown: 0,
                showRange: false,
                buffed: false,
                attacking: false,
                angle: null,
                truesight: def.truesight || false  // 从定义中复制真视属性
            });
            
            // 首次建造当前关卡新解锁的塔时显示知识卡片
            if (!gameState.shownTowerTutorials) {
                gameState.shownTowerTutorials = {};
            }
            
            // 第一关特殊处理：首次建造基础塔时显示知识卡片
            if (gameState.level === 1) {
                const level1Towers = ['validator', 'miner', 'gasStation', 'contract'];
                if (level1Towers.includes(type) && !gameState.shownTowerTutorials[type]) {
                    gameState.shownTowerTutorials[type] = true;
                    setTimeout(() => {
                        showMultipleTowerKnowledge([type], 0);
                    }, 500);
                }
            } else if (gameState.level !== 'endless') {
                // 第2-5关：首次建造当前关卡新解锁的塔时显示知识卡片
                const currentLevel = levels[gameState.level - 1];
                const levelUnlockTower = currentLevel.unlockTower;
                
                // 检查是否是当前关卡新解锁的塔，并且是首次放置
                if (levelUnlockTower && type === levelUnlockTower && !gameState.shownTowerTutorials[type]) {
                    gameState.shownTowerTutorials[type] = true;
                    // 延迟显示知识卡片，让玩家先看到塔被建造
                    setTimeout(() => {
                        showMultipleTowerKnowledge([type], 0);
                    }, 500);
                }
            }
            
            updateUI();
            return true;
        }
        
        function showSellPanel(tower) {
            // Cannot sell mainnet cannon
            if (tower.type === 'mainnetCannon') {
                addFloatingText(tower.x, tower.y, getText('float_cannot_sell_cannon'), '#ff0044');
                sound.towerError();
                return;
            }
            
            gameState.selectedPlacedTower = tower;
            const def = towerDefs[tower.type];
            const stats = getTowerStats(tower);
            
            // 判断第一波是否已经开始
            const hasStartedFirstWave = gameState.currentWave > 0 || gameState.waveInProgress || gameState.wavePreparation;
            
            // 第一波开始前100%回收，之后矿机90%回收，其他塔70%回收
            let sellRatio;
            if (!hasStartedFirstWave) {
                sellRatio = 1.0; // 第一波前100%回收
            } else {
                sellRatio = tower.type === 'miner' ? 0.9 : 0.7;
            }
            const sellPrice = Math.floor(tower.totalInvested * sellRatio);
            const upgradeCost = calculateUpgradeCost(tower);
            
            // 基本信息
            document.getElementById('sellTowerName').textContent = getTowerName(tower.type, tower.level);
            document.getElementById('towerLevel').innerHTML = `<span data-i18n="panel_level">${getText('panel_level')}</span>: Lv${tower.level}`;
            document.getElementById('sellPrice').textContent = sellPrice;
            
            // 更新出售比例提示
            const sellRatioPercent = Math.round(sellRatio * 100);
            let sellRatioText;
            if (!hasStartedFirstWave) {
                // 第一波前显示100%回收提示
                sellRatioText = getText('panel_sell_ratio', sellRatioPercent) + ` ${getText('panel_before_wave1')}`;
            } else {
                // 第一波后显示正常回收率
                const minerPrivilege = tower.type === 'miner' ? ` ${getText('panel_miner_privilege')}` : '';
                sellRatioText = getText('panel_sell_ratio', sellRatioPercent) + minerPrivilege;
            }
            document.getElementById('sellRatioText').textContent = sellRatioText;
            
            // 显示当前属性
            const statsDiv = document.getElementById('towerStats');
            if (tower.type === 'miner') {
                statsDiv.innerHTML = `<div><span data-i18n="panel_stat_income">${getText('panel_stat_income')}</span>: <span class="text-cyan-400">${stats.miningReward} GAS/3s</span></div>`;
            } else if (tower.type === 'gasStation') {
                statsDiv.innerHTML = `
                    <div><span data-i18n="panel_stat_range">${getText('panel_stat_range')}</span>: <span class="text-cyan-400">${stats.range}</span></div>
                    <div><span data-i18n="panel_stat_boost">${getText('panel_stat_boost')}</span>: <span class="text-cyan-400">${Math.round(stats.speedBoost * 100)}%</span></div>
                `;
            } else if (tower.type === 'contract') {
                statsDiv.innerHTML = `
                    <div><span data-i18n="panel_stat_slow_range">${getText('panel_stat_slow_range')}</span>: <span class="text-purple-400">${stats.range}</span></div>
                    <div><span data-i18n="panel_stat_slow_effect">${getText('panel_stat_slow_effect')}</span>: <span class="text-purple-400">${Math.round((1 - stats.slowFactor) * 100)}%</span></div>
                    <div><span data-i18n="panel_stat_truesight">${getText('panel_stat_truesight')}</span>: <span class="text-pink-400">${stats.truesightRange}</span></div>
                `;
            } else {
                // 计算实际攻速（考虑加油站加成）
                let actualAttackSpeed = stats.attackSpeed;
                let speedBoostText = '';
                
                // 检查是否在加油站范围内
                for (const gasStation of gameState.towers) {
                    if (gasStation.type !== 'gasStation') continue;
                    const gasStats = getTowerStats(gasStation);
                    const dist = Math.hypot(tower.x - gasStation.x, tower.y - gasStation.y);
                    if (dist < gasStats.range) {
                        // 应用加速效果
                        actualAttackSpeed = stats.attackSpeed * (1 - gasStats.speedBoost);
                        speedBoostText = ` <span class="text-green-400">(+${Math.round(gasStats.speedBoost * 100)}%)</span>`;
                        break; // 只取第一个加油站的效果
                    }
                }
                
                statsDiv.innerHTML = `
                    <div><span data-i18n="panel_stat_damage">${getText('panel_stat_damage')}</span>: <span class="text-cyan-400">${stats.damage}</span></div>
                    <div><span data-i18n="panel_stat_range">${getText('panel_stat_range')}</span>: <span class="text-cyan-400">${stats.range}</span></div>
                    <div><span data-i18n="panel_stat_speed">${getText('panel_stat_speed')}</span>: <span class="text-cyan-400">${actualAttackSpeed.toFixed(2)}s</span>${speedBoostText}</div>
                `;
            }
            
            // 升级部分
            // 主网大炮不可升级
            const maxLevel = tower.type === 'mainnetCannon' ? 1 : 10;
            if (tower.level >= maxLevel) {
                document.getElementById('upgradeSection').style.display = 'none';
                document.getElementById('maxLevelSection').style.display = 'block';
                document.getElementById('currentMaxLevel').textContent = tower.level;
            } else {
                document.getElementById('upgradeSection').style.display = 'block';
                document.getElementById('maxLevelSection').style.display = 'none';
                document.getElementById('nextLevel').textContent = tower.level + 1;
                document.getElementById('upgradeCost').textContent = upgradeCost;
                
                // 显示升级预览（下一级属性）
                const nextLevelTower = { type: tower.type, level: tower.level + 1 };
                const nextStats = getTowerStats(nextLevelTower);
                let previewHtml = `<div class="text-gray-500 text-xs mt-2" style="opacity: 0.7;"><span data-i18n="panel_upgrade_preview">${getText('panel_upgrade_preview')}</span></div>`;
                
                if (tower.type === 'miner') {
                    previewHtml += `<div class="text-green-400 text-xs"><span data-i18n="panel_stat_income">${getText('panel_stat_income')}</span>: ${nextStats.miningReward} GAS/3s</div>`;
                } else if (tower.type === 'gasStation') {
                    previewHtml += `<div class="text-green-400 text-xs"><span data-i18n="panel_stat_range">${getText('panel_stat_range')}</span>: ${nextStats.range} | <span data-i18n="panel_stat_boost">${getText('panel_stat_boost')}</span>: ${Math.round(nextStats.speedBoost * 100)}%</div>`;
                } else if (tower.type === 'contract') {
                    previewHtml += `<div class="text-green-400 text-xs"><span data-i18n="panel_stat_slow_range">${getText('panel_stat_slow_range')}</span>: ${nextStats.range} | <span data-i18n="panel_stat_slow_effect">${getText('panel_stat_slow_effect')}</span>: ${Math.round((1 - nextStats.slowFactor) * 100)}% | <span data-i18n="panel_stat_truesight">${getText('panel_stat_truesight')}</span>: ${nextStats.truesightRange}</div>`;
                } else {
                    previewHtml += `<div class="text-green-400 text-xs"><span data-i18n="panel_stat_damage">${getText('panel_stat_damage')}</span>: ${nextStats.damage} | <span data-i18n="panel_stat_range">${getText('panel_stat_range')}</span>: ${nextStats.range} | <span data-i18n="panel_stat_speed">${getText('panel_stat_speed')}</span>: ${nextStats.attackSpeed.toFixed(2)}s</div>`;
                }
                
                // 将预览添加到statsDiv后面
                statsDiv.innerHTML += previewHtml;
            }
            
            // 索敌优先级部分（只对攻击型塔显示）
            const attackTowers = ['validator', 'sharding', 'zkSniper', 'l2Channel', 'gasStation'];
            const prioritySection = document.getElementById('targetPrioritySection');
            if (attackTowers.includes(tower.type)) {
                prioritySection.style.display = 'block';
                
                // 初始化优先级（如果没有设置）
                if (!tower.targetPriority) {
                    tower.targetPriority = 'first'; // 默认第一个
                }
                
                // 更新UI显示
                const priorities = ['first', 'last', 'counter', 'strongest', 'weakest', 'nearest'];
                priorities.forEach(p => {
                    const elem = document.getElementById(`priority-${p}`);
                    if (elem) {
                        elem.textContent = p === tower.targetPriority ? '✅' : '⭕';
                    }
                });
            } else {
                prioritySection.style.display = 'none';
            }
            
            const panel = document.getElementById('sellPanel');
            panel.style.display = 'block';
            
            // 获取面板尺寸（需要先显示才能获取）
            const panelWidth = panel.offsetWidth || 200; // 默认200px
            const panelHeight = panel.offsetHeight || 300; // 默认300px
            
            // 获取窗口尺寸
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // 计算初始位置（塔的右侧）
            let left = tower.x + 30;
            let top = tower.y - 80;
            
            // 边界检测 - 水平方向
            if (left + panelWidth > windowWidth - 20) {
                // 如果右侧超出，放在塔的左侧
                left = tower.x - panelWidth - 30;
            }
            
            // 如果左侧也超出，强制在屏幕内
            if (left < 20) {
                left = 20;
            }
            
            // 边界检测 - 垂直方向
            if (top < 20) {
                // 如果顶部超出，向下移动
                top = 20;
            }
            
            if (top + panelHeight > windowHeight - 20) {
                // 如果底部超出，向上移动
                top = windowHeight - panelHeight - 20;
            }
            
            // 应用位置
            panel.style.left = left + 'px';
            panel.style.top = top + 'px';
        }
        
        function upgradeSelectedTower() {
            if (!gameState.selectedPlacedTower) return;
            const tower = gameState.selectedPlacedTower;
            const success = upgradeTower(tower);
            if (success) {
                // 刷新面板显示
                showSellPanel(tower);
                
                // 如果升级的是加油站，需要刷新所有受影响的塔的面板（如果它们的面板正在显示）
                if (tower.type === 'gasStation') {
                    // 由于我们只能同时显示一个面板，这里只需要刷新当前面板即可
                    // 面板已经在上面刷新过了
                }
            }
        }
        
        function closeSellPanel() {
            gameState.selectedPlacedTower = null;
            document.getElementById('sellPanel').style.display = 'none';
        }
        
        // 根据索敌优先级选择目标
        function selectTargetByPriority(tower, stats, enemies) {
            const priority = tower.targetPriority || 'first';
            
            // 筛选可攻击的敌人
            const validEnemies = enemies.filter(enemy => {
                const dist = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                
                // 超出射程
                if (dist > stats.range) return false;
                
                // 隐形且未被显形的敌人无法被锁定（除非塔有真视能力）
                const enemyDef = enemyDefs[enemy.type];
                if (enemyDef.invisible && !enemy.revealed && !tower.truesight) {
                    return false;
                }
                
                // 非验证哨不能攻击合法交易
                if (!enemy.isEvil && tower.type !== 'validator') {
                    return false;
                }
                
                // 已验证的合法交易不再被验证哨攻击
                if (!enemy.isEvil && enemy.verified && tower.type === 'validator') {
                    return false;
                }
                
                return true;
            });
            
            if (validEnemies.length === 0) return null;
            
            // 根据优先级排序
            switch (priority) {
                case 'first': // 第一个（路径进度最大，离终点最近）
                    return validEnemies.reduce((best, enemy) => {
                        const progress = enemy.pathIndex + enemy.pathProgress;
                        const bestProgress = best.pathIndex + best.pathProgress;
                        return progress > bestProgress ? enemy : best;
                    });
                    
                case 'last': // 最后一个（路径进度最小，离终点最远）
                    return validEnemies.reduce((best, enemy) => {
                        const progress = enemy.pathIndex + enemy.pathProgress;
                        const bestProgress = best.pathIndex + best.pathProgress;
                        return progress < bestProgress ? enemy : best;
                    });
                    
                case 'counter': // 特攻目标
                    // 定义特攻关系
                    const counterTargets = {
                        'validator': ['spam'],
                        'zkSniper': ['shielded', 'boss'],
                        'sharding': ['splitter', 'splitChild'],
                        'l2Channel': ['healer']
                    };
                    
                    const preferredTypes = counterTargets[tower.type] || [];
                    
                    // 优先选择特攻目标
                    const counterEnemies = validEnemies.filter(e => preferredTypes.includes(e.type));
                    if (counterEnemies.length > 0) {
                        // 在特攻目标中选择路径进度最大的（第一个）
                        return counterEnemies.reduce((best, enemy) => {
                            const progress = enemy.pathIndex + enemy.pathProgress;
                            const bestProgress = best.pathIndex + best.pathProgress;
                            return progress > bestProgress ? enemy : best;
                        });
                    }
                    // 没有特攻目标，回退到攻击第一个（路径进度最大）
                    return validEnemies.reduce((best, enemy) => {
                        const progress = enemy.pathIndex + enemy.pathProgress;
                        const bestProgress = best.pathIndex + best.pathProgress;
                        return progress > bestProgress ? enemy : best;
                    });
                    
                case 'strongest': // 血量最高
                    return validEnemies.reduce((best, enemy) => {
                        return enemy.hp > best.hp ? enemy : best;
                    });
                    
                case 'weakest': // 血量最低
                    return validEnemies.reduce((best, enemy) => {
                        return enemy.hp < best.hp ? enemy : best;
                    });
                    
                case 'nearest': // 最近（默认）
                default:
                    return validEnemies.reduce((best, enemy) => {
                        const dist = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                        const bestDist = Math.hypot(best.x - tower.x, best.y - tower.y);
                        return dist < bestDist ? enemy : best;
                    });
            }
        }
        
        function setTargetPriority(priority) {
            if (!gameState.selectedPlacedTower) return;
            
            gameState.selectedPlacedTower.targetPriority = priority;
            
            // 更新UI显示
            const priorities = ['first', 'last', 'counter', 'strongest', 'weakest', 'nearest'];
            priorities.forEach(p => {
                const elem = document.getElementById(`priority-${p}`);
                if (elem) {
                    elem.textContent = p === priority ? '✅' : '⭕';
                }
            });
            
            // 显示提示
            const priorityNames = {
                'first': '第一个敌人',
                'last': '最后一个敌人',
                'counter': '特攻目标',
                'strongest': '血量最高',
                'weakest': '血量最低',
                'nearest': '最近的敌人'
            };
            addFloatingText(
                gameState.selectedPlacedTower.x, 
                gameState.selectedPlacedTower.y - 30, 
                '🎯 ' + priorityNames[priority], 
                '#00ffff'
            );
            sound.towerPlace();
        }
        
        // ==================== UPGRADE SYSTEM ====================
        
        function calculateUpgradeCost(tower) {
            // 主网大炮不可升级
            if (tower.type === 'mainnetCannon') return 0;
            
            const maxLevel = 10;
            if (tower.level >= maxLevel) return 0;  // 已满级
            
            const def = towerDefs[tower.type];
            // 10级升级成本公式（重新平衡：更高成本）
            const costMultipliers = [0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2];
            return Math.floor(def.cost * costMultipliers[tower.level - 1]);
        }
        
        function getTowerStats(tower) {
            const def = towerDefs[tower.type];
            const level = tower.level || 1;
            
            // 根据塔类型和等级计算属性
            const stats = {
                damage: def.damage,
                range: def.range,
                attackSpeed: def.attackSpeed
            };
            
            // 不同塔类型有不同的升级加成（10级系统）
            switch(tower.type) {
                case 'validator':
                    stats.damage = [12, 18, 26, 36, 48, 64, 84, 110, 142, 180][level - 1] || 180;
                    stats.range = [110, 115, 120, 125, 130, 135, 140, 145, 150, 155][level - 1] || 155;
                    stats.attackSpeed = [1.0, 0.95, 0.90, 0.85, 0.80, 0.75, 0.70, 0.65, 0.60, 0.55][level - 1] || 0.55;
                    break;
                case 'miner':
                    stats.miningReward = [2, 3, 5, 7, 10, 14, 19, 26, 35, 46][level - 1] || 46;
                    break;
                case 'gasStation':
                    stats.damage = [5, 8, 12, 18, 26, 36, 50, 68, 90, 118][level - 1] || 118;
                    stats.range = [100, 110, 120, 130, 140, 150, 160, 170, 180, 200][level - 1] || 200;
                    stats.attackSpeed = [0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6][level - 1] || 0.6;
                    // 加速效果：15% → 50%，前期增长较快，后期放缓
                    stats.speedBoost = [0.15, 0.20, 0.25, 0.30, 0.34, 0.38, 0.42, 0.45, 0.47, 0.50][level - 1] || 0.50;
                    break;
                case 'contract':
                    // 减速效果：35% → 50%，slowFactor越小减速越强
                    stats.slowFactor = [0.65, 0.62, 0.60, 0.58, 0.56, 0.54, 0.52, 0.51, 0.505, 0.50][level - 1] || 0.50;
                    stats.range = [140, 155, 170, 185, 200, 215, 230, 245, 260, 280][level - 1] || 280;
                    stats.truesightRange = [100, 115, 130, 145, 160, 175, 190, 205, 220, 240][level - 1] || 240;
                    break;
                case 'sharding':
                    stats.damage = [30, 42, 58, 78, 102, 130, 162, 198, 238, 282][level - 1] || 282;
                    stats.range = [150, 155, 160, 165, 170, 175, 180, 185, 190, 195][level - 1] || 195;
                    stats.attackSpeed = [1.8, 1.7, 1.6, 1.5, 1.4, 1.3, 1.2, 1.1, 1.0, 0.9][level - 1] || 0.9;
                    stats.aoeRadius = [85, 90, 95, 100, 105, 110, 115, 120, 125, 130][level - 1] || 130;
                    break;
                case 'zkSniper':
                    stats.damage = [50, 68, 90, 116, 146, 180, 218, 260, 306, 356][level - 1] || 356;
                    stats.range = [260, 270, 280, 290, 300, 310, 320, 330, 340, 350][level - 1] || 350;
                    stats.attackSpeed = [2.0, 1.9, 1.8, 1.7, 1.6, 1.5, 1.4, 1.3, 1.2, 1.1][level - 1] || 1.1;
                    break;
                case 'l2Channel':
                    stats.damage = [20, 28, 38, 50, 64, 80, 98, 118, 140, 164][level - 1] || 164;  // 每秒伤害
                    stats.range = [180, 195, 210, 225, 240, 255, 270, 285, 300, 320][level - 1] || 320;
                    stats.laserDuration = [3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 5000][level - 1] || 5000;
                    break;
            }
            
            return stats;
        }
        
        function upgradeTower(tower) {
            const maxLevel = tower.type === 'mainnetCannon' ? 1 : 10;
            if (tower.level >= maxLevel) {
                addFloatingText(tower.x, tower.y, getText('float_max_level'), '#ffaa00');
                sound.towerError();
                return false;
            }
            
            const upgradeCost = calculateUpgradeCost(tower);
            if (gameState.balance < upgradeCost) {
                addFloatingText(tower.x, tower.y, 'GAS不足！', '#ff0044');
                sound.towerError();
                return false;
            }
            
            gameState.balance -= upgradeCost;
            tower.totalInvested += upgradeCost;
            tower.level++;
            
            // 播放升级特效
            addFloatingText(tower.x, tower.y, '升级！Lv' + tower.level, '#00ff00');
            sound.towerPlace();
            
            // 添加升级粒子效果
            for (let i = 0; i < 20; i++) {
                gameState.particles.push({
                    x: tower.x,
                    y: tower.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 30,
                    color: '#00ff00',
                    size: Math.random() * 6 + 3
                });
            }
            
            updateUI();
            return true;
        }
        
        function sellSelectedTower() {
            if (!gameState.selectedPlacedTower) return;
            
            const tower = gameState.selectedPlacedTower;
            
            // 判断第一波是否已经开始
            const hasStartedFirstWave = gameState.currentWave > 0 || gameState.waveInProgress || gameState.wavePreparation;
            
            // 第一波开始前100%回收，之后矿机90%回收，其他塔70%回收
            let sellRatio;
            if (!hasStartedFirstWave) {
                sellRatio = 1.0; // 第一波前100%回收
            } else {
                sellRatio = tower.type === 'miner' ? 0.9 : 0.7;
            }
            const sellPrice = Math.floor(tower.totalInvested * sellRatio);
            
            // 如果售卖的是加油站，清除所有被它加速的塔的buff状态
            if (tower.type === 'gasStation') {
                const stats = getTowerStats(tower);
                for (const other of gameState.towers) {
                    if (other === tower) continue;
                    if (other.type === 'mainnetCannon') continue;
                    const dist = Math.hypot(other.x - tower.x, other.y - tower.y);
                    if (dist < stats.range) {
                        // 清除这个塔的加速buff
                        other.buffed = false;
                        other.speedBoostValue = 0;
                    }
                }
            }
            
            const index = gameState.towers.indexOf(tower);
            if (index > -1) gameState.towers.splice(index, 1);
            
            gameState.balance += sellPrice;
            addFloatingText(tower.x, tower.y, '+' + sellPrice + ' GAS', '#ffff00');
            sound.towerSell();
            
            updateUI();
            closeSellPanel();
        }
        
        function startLevel(levelNum, skipStory = false) {
            const level = levelNum === 'endless' ? levels[levels.length - 1] : levels[levelNum - 1];
            gameState.level = levelNum;
            gameState.currentWave = 0;
            gameState.totalWaves = level.isEndless ? 999 : level.waves.length;
            gameState.txCount = 0;
            gameState.txRequired = level.txRequired;
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.blockHeight += Math.floor(Math.random() * 100);
            
            // 重置塔教程显示状态，让每关的新塔首次放置时都显示知识卡片
            gameState.shownTowerTutorials = {};
            
            if (level.unlockTower && !gameState.unlockedTowers.includes(level.unlockTower)) {
                gameState.unlockedTowers.push(level.unlockTower);
            }
            
            document.querySelectorAll('[data-tower]').forEach(el => {
                const type = el.dataset.tower;
                if (gameState.unlockedTowers.includes(type)) {
                    el.classList.remove('locked');
                }
            });
            
            if (level.mapType === 'random') {
                generateRandomPath();
            } else {
                generatePath(level.mapType);
            }
            updateUI();
            
            // 播放关卡背景音乐
            const bgmLevel = levelNum === 'endless' ? 5 : levelNum;
            sound.playBgm(bgmLevel);
            
            // 如果是重试，跳过剧情和知识模态框
            if (skipStory) {
                return;
            }
            
            if (!level.isEndless) {
                // 先显示链灵对话，然后显示关卡剧情
                const dialogueKey = `level${levelNum}`;
                if (chainSpiritDialogues[dialogueKey]) {
                    showDialogue(dialogueKey, () => {
                        // 对话结束后显示关卡剧情
                        const levelStory = storyData.levels[levelNum];
                        if (levelStory && levelStory.opening) {
                            showStory(levelStory.opening, () => {
                                // 第一关只显示第一个塔的介绍
                                if (levelNum === 1) {
                                    showMultipleTowerKnowledge(['validator'], 0);
                                } else {
                                    showKnowledgeModal(level);
                                }
                            });
                        } else {
                            // 第一关只显示第一个塔的介绍
                            if (levelNum === 1) {
                                showMultipleTowerKnowledge(['validator'], 0);
                            } else {
                                showKnowledgeModal(level);
                            }
                        }
                    });
                } else {
                    // 没有对话时直接显示剧情
                    const levelStory = storyData.levels[levelNum];
                    if (levelStory && levelStory.opening) {
                        showStory(levelStory.opening, () => {
                            // 第一关只显示第一个塔的介绍
                            if (levelNum === 1) {
                                showMultipleTowerKnowledge(['validator'], 0);
                            } else {
                                showKnowledgeModal(level);
                            }
                        });
                    } else {
                        // 第一关只显示第一个塔的介绍
                        if (levelNum === 1) {
                            showMultipleTowerKnowledge(['validator'], 0);
                        } else {
                            showKnowledgeModal(level);
                        }
                    }
                }
            } else {
                // 无尽模式也需要玩家手动开始
                // 不自动调用startWave()，等待玩家点击spawn图标
            }
        }
        
        function startWave() {
            const level = gameState.level === 'endless' ? levels[levels.length - 1] : levels[gameState.level - 1];
            
            if (gameState.currentWave >= gameState.totalWaves) {
                return;
            }
            
            gameState.waveInProgress = true;
            gameState.wavePreparation = false;
            gameState.enemiesSpawned = 0;
            gameState.spawnTimer = 0;
            
            // 无尽模式动态生成波次
            const waveData = level.isEndless ? generateEndlessWave(gameState.currentWave + 1) : level.waves[gameState.currentWave];
            gameState.currentWaveEnemies = [];
            
            for (const group of waveData) {
                for (let i = 0; i < group.count; i++) {
                    gameState.currentWaveEnemies.push(group.type);
                }
            }
            gameState.currentWaveEnemies.sort(() => Math.random() - 0.5);
            
            sound.waveStart();
            
            showWaveAnnouncement();
            
            updateUI();
        }
        
        function showWaveAnnouncement() {
            const announcement = document.createElement('div');
            announcement.className = 'wave-announce';
            announcement.textContent = getText('ui_wave_announce', gameState.currentWave + 1, gameState.totalWaves);
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 2000);
        }
        
        function skipToNextWave() {
            if (gameState.wavePreparation) {
                gameState.currentWave++;
                startWave();
                sound.uiClick();
            }
        }
        
        function updateWave() {
            if (gameState.wavePreparation) {
                gameState.preparationTimer -= 16;
                if (gameState.preparationTimer <= 0) {
                    gameState.currentWave++;
                    startWave();
                }
                return;
            }
            
            if (!gameState.waveInProgress) return;
            
            gameState.spawnTimer -= 16;
            
            if (gameState.spawnTimer <= 0 && gameState.currentWaveEnemies.length > 0) {
                const type = gameState.currentWaveEnemies.shift();
                const useSecondPath = gameState.path2 && Math.random() > 0.5;
                spawnEnemy(type, useSecondPath);
                gameState.enemiesSpawned++;
                gameState.spawnTimer = type === 'boss' ? 3000 : 600;
            }
            
            // Check if all enemies for current wave have been spawned
            if (gameState.currentWaveEnemies.length === 0 && gameState.waveInProgress) {
                // All enemies spawned for this wave
                
                // Check if this is the last wave
                if (gameState.currentWave + 1 >= gameState.totalWaves) {
                    // Last wave - check if all evil enemies are cleared
                    const evilEnemiesLeft = gameState.enemies.filter(e => e.isEvil).length;
                    const goodEnemiesLeft = gameState.enemies.filter(e => !e.isEvil).length;
                    
                    // 只要所有恶意敌人被清除，就可以判定结果（不管还有多少合法交易在场上）
                    if (evilEnemiesLeft === 0) {
                        gameState.waveInProgress = false;
                        
                        // 胜利条件：所有恶意敌人被消灭且生命值大于0
                        if (gameState.lives > 0) {
                            completeLevel();
                        } else {
                            // 失败：生命值归零
                            console.log(`关卡失败: 生命值归零`);
                            gameState.gameOver = true;
                        }
                    }
                } else {
                    // Not last wave - show next wave button immediately after all spawned
                    gameState.waveInProgress = false;
                    gameState.wavePreparation = true;
                    
                    // 根据下一波的敌人数量动态调整准备时间
                    const level = gameState.level === 'endless' ? levels[levels.length - 1] : levels[gameState.level - 1];
                    const nextWaveData = level.isEndless ? generateEndlessWave(gameState.currentWave + 2) : level.waves[gameState.currentWave + 1];
                    
                    // 计算下一波的总敌人数量
                    let nextWaveEnemyCount = 0;
                    if (nextWaveData) {
                        for (const group of nextWaveData) {
                            nextWaveEnemyCount += group.count;
                        }
                    }
                    
                    // 准备时间 = 基础时间(3秒) + 敌人数量 * 每个敌人增加的时间(100ms)
                    // 最少3秒，最多10秒
                    const baseTime = 3000;
                    const timePerEnemy = 100;
                    gameState.preparationTimer = Math.min(10000, Math.max(baseTime, baseTime + nextWaveEnemyCount * timePerEnemy));
                    
                    // 无尽模式：每完成10波，生命值上限+1
                    if ((gameState.level === 'endless' || gameState.level === 6) && gameState.currentWave > 0 && gameState.currentWave % 10 === 0) {
                        gameState.maxLives += 1;
                        gameState.lives = Math.min(gameState.lives + 1, gameState.maxLives); // 同时恢复1点生命
                        addFloatingText(canvas.width / 2, 100, `🎉 ${getText('float_max_lives_up')} +1`, '#00ff88');
                    }
                    
                    sound.waveComplete();
                    updateUI(); // Update button display
                }
            }
        }
        
        function updateUI() {
            document.getElementById('balance').textContent = gameState.balance;
            document.getElementById('blockHeight').textContent = gameState.blockHeight;
            document.getElementById('levelNum').textContent = gameState.level;
            // 使用翻译键更新关卡名称（包含滚动检测）
            updateLevelNameScroll();
            
            document.getElementById('txCount').textContent = gameState.txCount;
            document.getElementById('txRequired').textContent = gameState.txRequired;
            document.getElementById('txProgress').style.width = (gameState.txCount / gameState.txRequired * 100) + '%';
            document.getElementById('enemiesLeft').textContent = gameState.enemies.filter(e => e.isEvil).length;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('maxLives').textContent = gameState.maxLives;
            
            document.getElementById('currentWaveNum').textContent = gameState.currentWave + 1;
            document.getElementById('totalWavesNum').textContent = gameState.totalWaves;
            
            const nextWaveBtn = document.getElementById('nextWaveBtn');
            if (gameState.wavePreparation && gameState.preparationTimer > 0) {
                nextWaveBtn.style.display = 'flex';
                const seconds = Math.ceil(gameState.preparationTimer / 1000);
                document.getElementById('nextWaveBtnText').textContent = `${getText('btn_next_wave')} (${seconds}s)`;
            } else {
                nextWaveBtn.style.display = 'none';
            }
            
            if (document.getElementById('pauseBalance')) {
                document.getElementById('pauseLevel').textContent = gameState.level;
                document.getElementById('pauseBalance').textContent = gameState.balance;
            }
            
            // 更新塔按钮的状态（高亮可购买的塔）
            updateTowerButtonStates();
        }
        
        function updateTowerButtonStates() {
            document.querySelectorAll('.tower-btn').forEach(btn => {
                const towerType = btn.dataset.tower;
                const def = towerDefs[towerType];
                
                // 如果塔未解锁，保持locked状态（已有锁图标）
                if (!gameState.unlockedTowers.includes(towerType)) {
                    btn.classList.add('locked');
                    btn.classList.remove('affordable', 'not-affordable');
                    return;
                }
                
                // 塔已解锁，移除locked状态
                btn.classList.remove('locked');
                
                // 根据金钱判断是否可购买
                if (gameState.balance >= def.cost) {
                    btn.classList.add('affordable');
                    btn.classList.remove('not-affordable');
                } else {
                    btn.classList.remove('affordable');
                    btn.classList.add('not-affordable');
                }
            });
        }
        
        function showTooltip(event, type) {
            const def = towerDefs[type];
            const locked = !gameState.unlockedTowers.includes(type);
            
            // 创建一个临时塔对象来获取Lv1属性
            const tempTower = { type: type, level: 1 };
            const stats = getTowerStats(tempTower);
            
            const tooltip = document.getElementById('tooltip');
            let statsHtml = '';
            
            if (type === 'miner') {
                statsHtml = `<div class="text-cyan-400">${getText('tooltip_income')}: ${stats.miningReward} GAS/3s (Lv1)</div>`;
            } else if (type === 'gasStation') {
                statsHtml = `
                    <div class="text-cyan-400">${getText('tooltip_range')}: ${stats.range}</div>
                `;
            } else if (type === 'contract') {
                statsHtml = `
                    <div class="text-purple-400">${getText('tooltip_slow_range')}: ${stats.range}</div>
                    <div class="text-purple-400">${getText('tooltip_slow_effect')}: ${Math.round((1 - stats.slowFactor) * 100)}%</div>
                    <div class="text-pink-400">${getText('tooltip_truesight_range')}: ${stats.truesightRange}</div>
                `;
            } else if (type !== 'mainnetCannon') {
                statsHtml = `
                    ${stats.range > 0 && stats.range < 9999 ? `<div class="text-cyan-400">${getText('tooltip_range')}: ${stats.range}</div>` : ''}
                    ${stats.range === 9999 ? `<div class="text-pink-400">${getText('tooltip_range')}: ${getText('tooltip_full_map')}</div>` : ''}
                    <div class="text-red-400">${getText('tooltip_damage')}: ${stats.damage || getText('tooltip_none')}</div>
                    <div class="text-orange-400">${getText('tooltip_attack_speed')}: ${stats.attackSpeed}s</div>
                `;
            }
            
            // 添加克制关系提示（动态倍率）
            let counterHtml = '';
            if (type === 'validator') {
                counterHtml = `<div class="text-green-400 text-xs mt-2">${getText('tooltip_counter_spam')}</div>`;
            } else if (type === 'zkSniper') {
                counterHtml = `<div class="text-green-400 text-xs mt-2">${getText('tooltip_counter_armored')}</div>`;
            } else if (type === 'sharding') {
                counterHtml = `<div class="text-green-400 text-xs mt-2">${getText('tooltip_counter_splitter')}</div>`;
            } else if (type === 'l2Channel') {
                counterHtml = `<div class="text-green-400 text-xs mt-2">${getText('tooltip_counter_healer')}</div>`;
            } else if (type === 'mainnetCannon') {
                counterHtml = `<div class="text-green-400 text-xs mt-2">${getText('tooltip_counter_boss')}</div>`;
            } else if (type === 'gasStation') {
                counterHtml = `<div class="text-purple-400 text-xs mt-2">${getText('tooltip_aura_gas')}</div>`;
            } else if (type === 'contract') {
                counterHtml = `<div class="text-pink-400 text-xs mt-2">${getText('tooltip_truesight')}</div>`;
            }
            
            tooltip.innerHTML = `
                <div class="font-bold text-lg mb-2">${getTowerName(type, 1)} ${locked ? '🔒' : ''}</div>
                ${locked ? `<div class="text-red-400 mb-2">${getText('tooltip_locked', def.unlockLevel)}</div>` : ''}
                <div class="text-gray-400 text-xs mb-2">${getText('tower_knowledge_' + type)}</div>
                <div class="mb-2">${getText('tower_desc_' + type)}</div>
                <div class="text-yellow-400">${getText('tooltip_build')}: ${def.cost} GAS</div>
                ${statsHtml}
                ${counterHtml}
                <div class="text-gray-400 text-xs mt-2">${type === 'mainnetCannon' ? getText('tooltip_cannot_upgrade') : getText('tooltip_can_upgrade')}</div>
                <div class="text-green-400">${getText('tooltip_sell')}: ${Math.floor(def.cost * (type === 'miner' ? 0.9 : 0.7))} GAS${type === 'miner' ? ` (90%${getText('tooltip_recycle')})` : ''}</div>
            `;
            tooltip.style.display = 'block';
            
            // 智能定位：确保tooltip不超出屏幕
            let left = event.pageX + 15;
            let top = event.pageY + 15;
            
            // 获取tooltip的实际尺寸
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // 检查右侧边界
            if (left + tooltipWidth > window.innerWidth) {
                left = event.pageX - tooltipWidth - 15; // 显示在鼠标左侧
            }
            
            // 检查底部边界
            if (top + tooltipHeight > window.innerHeight) {
                top = window.innerHeight - tooltipHeight - 10; // 贴近底部但留10px边距
            }
            
            // 确保不超出顶部
            if (top < 10) {
                top = 10;
            }
            
            // 确保不超出左侧
            if (left < 10) {
                left = 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        // 菜单按钮（右上角）- 打开暂停菜单
        function togglePause() {
            if (!gameState.running || gameState.gameOver || gameState.victory) return;
            gameState.paused = !gameState.paused;
            
            document.getElementById('pauseScreen').style.display = gameState.paused ? 'flex' : 'none';
            
            // 更新左下角暂停按钮状态和overlay
            if (gameState.paused) {
                document.getElementById('pauseBtnIcon').textContent = '▶';
                document.getElementById('pauseBtnText').textContent = getText('btn_continue');
                document.getElementById('spacePauseOverlay').style.display = 'none'; // 菜单打开时隐藏overlay
                // 暂停时显示语言选择器
                showLanguageSelector();
            } else {
                document.getElementById('pauseBtnIcon').textContent = '⏸';
                document.getElementById('pauseBtnText').textContent = getText('btn_pause');
                document.getElementById('spacePauseOverlay').style.display = 'none'; // 取消暂停时隐藏overlay
                // 恢复游戏时隐藏语言选择器
                hideLanguageSelector();
            }
            
            if (gameState.paused) updateUI();
            sound.uiClick();
        }
        
        // 暂停按钮（左下角）- 切换暂停状态
        function toggleGamePause() {
            if (!gameState.running || gameState.gameOver || gameState.victory) return;
            gameState.paused = !gameState.paused;
            
            // 更新按钮状态
            if (gameState.paused) {
                document.getElementById('pauseBtnIcon').textContent = '▶';
                document.getElementById('pauseBtnText').textContent = getText('btn_continue');
                document.getElementById('spacePauseOverlay').style.display = 'flex';
            } else {
                document.getElementById('pauseBtnIcon').textContent = '⏸';
                document.getElementById('pauseBtnText').textContent = getText('btn_pause');
                document.getElementById('spacePauseOverlay').style.display = 'none';
            }
            
            sound.uiClick();
        }
        
        function toggleSpeed() {
            if (!gameState.running || gameState.gameOver || gameState.victory) return;
            
            // 切换速度：1倍 <-> 2倍
            gameState.gameSpeed = gameState.gameSpeed === 1 ? 2 : 1;
            
            // 更新按钮显示
            const speedIcon = document.getElementById('speedIcon');
            const speedText = document.getElementById('speedText');
            const speedBtn = document.getElementById('speedBtn');
            
            if (gameState.gameSpeed === 2) {
                speedIcon.textContent = '⏩';
                speedText.textContent = getText('speed_normal');
                speedBtn.style.borderColor = '#ff6600';
                speedBtn.style.color = '#ff6600';
            } else {
                speedIcon.textContent = '▶';
                speedText.textContent = getText('speed_double');
                speedBtn.style.borderColor = '';
                speedBtn.style.color = '';
            }
            
            sound.uiClick();
        }
        
        function toggleVolumePanel() {
            const panel = document.getElementById('volumePanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            sound.uiClick();
        }
        
        function updateBGMVolume(value) {
            const volume = parseInt(value) / 100;
            sound.bgmVolume = volume;
            
            // 更新BGM音量
            if (sound.bgmGain) {
                sound.bgmGain.gain.value = volume;
            }
            
            // 更新显示
            document.getElementById('bgmVolumeText').textContent = value + '%';
            
            // 如果音量为0，禁用音乐
            if (volume === 0 && sound.bgmPlaying) {
                sound.stopBgm();
            }
        }
        
        function updateSFXVolume(value) {
            const volume = parseInt(value) / 100;
            sound.masterVolume = volume;
            
            // 更新显示
            document.getElementById('sfxVolumeText').textContent = value + '%';
            
            // 播放测试音效
            if (volume > 0) {
                sound.uiClick();
            }
        }
        
        let towerMenuVisible = true; // 初始状态为显示
        
        function toggleTowerMenu() {
            const content = document.getElementById('towerMenuContent');
            const icon = document.getElementById('towerMenuToggleIcon');
            
            towerMenuVisible = !towerMenuVisible;
            
            if (towerMenuVisible) {
                content.style.display = 'flex';
                icon.textContent = '▼';
            } else {
                content.style.display = 'none';
                icon.textContent = '▲';
            }
            
            sound.uiClick();
        }
        
        function selectTowerByKey(towerType) {
            // 检查塔是否解锁
            if (!gameState.unlockedTowers.includes(towerType)) {
                sound.towerError();
                return;
            }
            
            // 如果已经选中了这个塔，再按一次则取消选择
            if (gameState.selectedTower === towerType) {
                gameState.selectedTower = null;
                sound.uiClick();
                
                // 取消所有高亮
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.style.transform = '';
                    btn.style.boxShadow = '';
                });
                return;
            }
            
            // 选择塔（不检查钱是否足够）
            gameState.selectedTower = towerType;
            sound.uiClick();
            
            // 高亮对应的塔按钮
            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.style.transform = '';
                btn.style.boxShadow = '';
            });
            const towerBtn = document.querySelector(`[data-tower="${towerType}"]`);
            if (towerBtn) {
                towerBtn.style.transform = 'scale(1.1)';
                towerBtn.style.boxShadow = '0 0 20px currentColor';
            }
        }
        
        function toggleHelp() {
            const panel = document.getElementById('helpPanel');
            const toggle = document.getElementById('helpToggle');
            panel.classList.toggle('open');
            toggle.classList.toggle('panel-open');
            toggle.textContent = panel.classList.contains('open') ? getText('btn_close') : getText('btn_help');
            
            // 确保打开帮助面板时更新所有翻译
            if (panel.classList.contains('open')) {
                // 更新帮助面板内的所有翻译
                panel.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    const text = getText(key);
                    
                    // 如果文本包含HTML标签，使用innerHTML，否则使用textContent
                    if (text.includes('<br>') || text.includes('<')) {
                        element.innerHTML = text;
                    } else {
                        element.textContent = text;
                    }
                });
            }
        }
        
        // ==================== GAME LOOP ====================
        function gameLoop() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.running) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            drawGrid();
            drawPath();
            drawBlock();
            drawTowers();
            drawEnemies();
            drawProjectiles();
            drawParticles();
            drawFloatingTexts();
            drawPlacementPreview();
            
            if (gameState.paused || gameState.spacePaused || gameState.modalPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            if (gameState.gameOver) {
                if (!gameState.gameOverShown) {
                    console.log('触发游戏结束界面');
                    gameState.gameOverShown = true;
                    sound.gameOver();
                    document.getElementById('gameUI').style.display = 'none';
                    // 显示失败剧情
                    showStory(storyData.failure, () => {
                        document.getElementById('gameOverScreen').style.display = 'flex';
                        // 显示语言选择器（失败界面）
                        showLanguageSelector();
                    });
                }
                requestAnimationFrame(gameLoop);
                return;
            }
            
            if (gameState.victory) {
                showVictoryScreen();
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // 根据游戏速度倍率更新多次
            const updateCount = gameState.gameSpeed;
            for (let i = 0; i < updateCount; i++) {
                updateWave();
                updateEnemies();
                updateTowers();
                updateProjectiles();
                updateParticles();
                updateFloatingTexts();
            }
            updateEnemyInfoPanel();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ==================== EVENT LISTENERS ====================
        canvas.addEventListener('mousemove', (e) => {
            gameState.mouseX = e.clientX;
            gameState.mouseY = e.clientY;
            
            for (const tower of gameState.towers) {
                tower.showRange = Math.hypot(e.clientX - tower.x, e.clientY - tower.y) < 25;
            }
        });
        
        canvas.addEventListener('click', (e) => {
            // 检查是否点击了刷怪图标（第一波开始前）
            if (!gameState.waveInProgress && !gameState.wavePreparation && gameState.currentWave === 0 && gameState.enemies.length === 0) {
                const spawnX = 50;
                const spawnY = gameState.path[0].y;
                const dist = Math.hypot(e.clientX - spawnX, e.clientY - spawnY);
                if (dist < 35) {
                    startWave();
                    sound.uiClick();
                    return;
                }
            }
            
            // 检查是否点击了敌人
            for (const enemy of gameState.enemies) {
                const dist = Math.hypot(e.clientX - enemy.renderX, e.clientY - enemy.renderY);
                if (dist < enemy.size + 10) {
                    showEnemyInfo(enemy);
                    return;
                }
            }
            
            for (const tower of gameState.towers) {
                if (tower.type === 'mainnetCannon' && Math.hypot(e.clientX - tower.x, e.clientY - tower.y) < 25) {
                    if (gameState.balance >= 150) {
                        gameState.cannonTargetMode = true;
                        gameState.selectedCannon = tower;
                        document.getElementById('cannonTargetOverlay').style.display = 'block';
                    } else {
                        addFloatingText(tower.x, tower.y, 'NEED 150 GAS', '#ff0044');
                        sound.towerError();
                    }
                    return;
                }
            }
            
            for (const tower of gameState.towers) {
                if (Math.hypot(e.clientX - tower.x, e.clientY - tower.y) < 25) {
                    gameState.selectedTower = null;
                    showSellPanel(tower);
                    closeEnemyInfo(); // 关闭敌人信息
                    return;
                }
            }
            
            closeSellPanel();
            closeEnemyInfo(); // 关闭敌人信息
            
            if (!gameState.selectedTower) return;
            
            const x = Math.floor(e.clientX / gameState.gridSize) * gameState.gridSize + gameState.gridSize / 2;
            const y = Math.floor(e.clientY / gameState.gridSize) * gameState.gridSize + gameState.gridSize / 2;
            
            if (placeTower(gameState.selectedTower, x, y)) {
                sound.towerPlace();
            } else {
                sound.towerError();
            }
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            gameState.selectedTower = null;
            closeSellPanel();
            exitCannonMode();
        });
        
        document.getElementById('cannonTargetOverlay').addEventListener('contextmenu', (e) => {
            e.preventDefault();
            exitCannonMode();
        });
        
        document.querySelectorAll('[data-tower]').forEach(el => {
            el.addEventListener('click', (e) => {
                const type = e.currentTarget.dataset.tower;
                if (!gameState.unlockedTowers.includes(type)) {
                    sound.towerError();
                    return;
                }
                gameState.selectedTower = type;
                closeSellPanel();
                sound.uiClick();
            });
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Check if credits modal is open
                if (document.getElementById('creditsModal').style.display === 'flex') {
                    closeCredits();
                } else if (gameState.cannonTargetMode) {
                    exitCannonMode();
                } else {
                    togglePause();
                }
            }
            if (e.key === 'p' || e.key === 'P') togglePause();
            if (e.key === 'x' || e.key === 'X') toggleSpeed(); // X键切换二倍速
            if (e.key === 'n' || e.key === 'N') skipToNextWave(); // N键跳到下一波
            if (e.key === 'm' || e.key === 'M') toggleVolumePanel(); // M键切换音量面板
            
            // W键：快捷升级所选塔
            if ((e.key === 'w' || e.key === 'W') && gameState.running && !gameState.modalPaused) {
                if (gameState.selectedPlacedTower) {
                    upgradeSelectedTower();
                }
            }
            
            // Q键：快捷出售所选塔
            if ((e.key === 'q' || e.key === 'Q') && gameState.running && !gameState.modalPaused) {
                if (gameState.selectedPlacedTower) {
                    sellSelectedTower();
                }
            }
            
            // R键：主网大炮轰炸快捷键
            if ((e.key === 'r' || e.key === 'R') && gameState.running && !gameState.modalPaused) {
                // 检查是否有主网大炮
                const hasMainnetCannon = gameState.towers.some(t => t.type === 'mainnetCannon');
                if (hasMainnetCannon && !gameState.cannonTargetMode) {
                    // 进入瞄准模式
                    gameState.cannonTargetMode = true;
                    document.getElementById('cannonTargetOverlay').style.display = 'block';
                    sound.uiClick();
                }
            }
            
            // 数字键1-8选择防御塔
            const towerKeys = ['validator', 'miner', 'gasStation', 'contract', 'sharding', 'zkSniper', 'l2Channel', 'mainnetCannon'];
            const keyNum = parseInt(e.key);
            if (keyNum >= 1 && keyNum <= 8) {
                const towerType = towerKeys[keyNum - 1];
                if (gameState.running && !gameState.modalPaused) {
                    selectTowerByKey(towerType);
                }
            }
            
            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault();
                toggleGamePause(); // 改为单击切换暂停
            }
        });
        
        // ==================== LEVEL SELECTION ====================
        let unlockedLevels = [1];
        let completedLevels = [];
        
        // ========== 体验模式函数 ==========
        function unlockAllForTesting() {
            sound.uiClick();
            
            // 解锁所有关卡（包括无限模式）
            unlockedLevels = [1, 2, 3, 4, 5, 'endless'];
            completedLevels = [];
            
            // 解锁所有塔
            gameState.unlockedTowers = ['validator', 'miner', 'gasStation', 'contract', 'sharding', 'zkSniper', 'l2Channel', 'mainnetCannon'];
            
            alert('🎮 体验模式已开启！\n\n✓ 所有关卡已解锁\n✓ 无尽模式已解锁\n✓ 所有防御塔已解锁\n\n现在可以自由体验游戏的全部内容！');
            
            // 确保在alert关闭后再显示选关界面并更新卡片
            showLevelSelect();
        }
        // ========== 体验模式函数结束 ==========
        
        // ==================== STORY FUNCTIONS ====================
        let currentStoryCallback = null;
        
        function showStory(storyObj, callback) {
            document.getElementById('storyIcon').textContent = storyObj.icon;
            
            // 如果有翻译键，使用翻译；否则使用原文
            if (storyObj.titleKey) {
                document.getElementById('storyTitle').textContent = getText(storyObj.titleKey);
                document.getElementById('storySubtitle').textContent = getText(storyObj.subtitleKey);
                document.getElementById('storyContent').innerHTML = getText(storyObj.contentKey);
            } else {
                document.getElementById('storySubtitle').textContent = storyObj.subtitle;
                document.getElementById('storyTitle').textContent = storyObj.title;
                document.getElementById('storyContent').innerHTML = storyObj.content;
            }
            
            // 更新核心机制文本
            const mechanicsTitleEl = document.getElementById('mechanicsTitle');
            const mechanicsAllowEl = document.getElementById('mechanicsAllow');
            const mechanicsDestroyEl = document.getElementById('mechanicsDestroy');
            if (mechanicsTitleEl) mechanicsTitleEl.textContent = getText('opening_mechanics_title');
            if (mechanicsAllowEl) mechanicsAllowEl.textContent = getText('opening_mechanics_allow');
            if (mechanicsDestroyEl) mechanicsDestroyEl.textContent = getText('opening_mechanics_destroy');
            
            // 更新关卡选择界面的机制显示文本
            const mechanicsLegitimateDataEl = document.getElementById('mechanicsLegitimateData');
            const mechanicsMaliciousAttackEl = document.getElementById('mechanicsMaliciousAttack');
            const mechanicsPassEl = document.getElementById('mechanicsPass');
            const mechanicsKillEl = document.getElementById('mechanicsKill');
            if (mechanicsLegitimateDataEl) mechanicsLegitimateDataEl.textContent = getText('mechanics_legitimate_data');
            if (mechanicsMaliciousAttackEl) mechanicsMaliciousAttackEl.textContent = getText('mechanics_malicious_attack');
            if (mechanicsPassEl) mechanicsPassEl.textContent = getText('mechanics_pass');
            if (mechanicsKillEl) mechanicsKillEl.textContent = getText('mechanics_kill');
            
            // 翻译按钮文本
            const buttonTextMap = {
                '开始守护！': 'story_btn_start',
                '开始部署': 'story_btn_deploy',
                '继续前进': 'story_btn_continue',
                '最终决战': 'story_btn_final',
                '完成使命': 'story_btn_complete',
                '部署分片': 'story_btn_deploy',
                '部署ZK技术': 'story_btn_deploy',
                '部署L2': 'story_btn_deploy',
                '准备最终战': 'story_btn_final'
            };
            
            const buttonKey = buttonTextMap[storyObj.buttonText];
            document.getElementById('storyButton').textContent = buttonKey ? getText(buttonKey) : storyObj.buttonText;
            
            document.getElementById('storyModal').style.display = 'flex';
            currentStoryCallback = callback;
            sound.modalOpen();
            
            // 隐藏语言选择器（剧情界面）
            hideLanguageSelector();
        }
        
        function closeStoryModal() {
            document.getElementById('storyModal').style.display = 'none';
            sound.uiClick();
            if (currentStoryCallback) {
                currentStoryCallback();
                currentStoryCallback = null;
            }
            
            // 关闭剧情后，根据当前界面决定是否显示语言选择器
            // 如果是在游戏中，则不显示；如果是在菜单界面，则显示
            setTimeout(() => {
                const gameUI = document.getElementById('gameUI');
                const levelSelect = document.getElementById('levelSelectScreen');
                const startScreen = document.getElementById('startScreen');
                const knowledgeLibrary = document.getElementById('knowledgeLibraryScreen');
                
                // 只要不是在游戏中，就显示语言选择器
                if (gameUI.style.display !== 'block') {
                    showLanguageSelector();
                }
            }, 150);
        }
        
        function showOpeningStory() {
            showStory(storyData.opening, () => {
                showLevelSelect();
            });
        }
        
        function showStartScreenHelp() {
            sound.uiClick();
            const helpContent = `
                <div style="text-align: left; max-width: 600px; margin: 0 auto;">
                    <h3 style="color: #00ffff; margin-bottom: 20px; text-align: center;">${getText('help_title_quick')}</h3>
                    
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #00ff88;">${getText('traffic_tip_green')}</strong>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong style="color: #ff0044;">${getText('traffic_tip_red')}</strong>
                    </div>
                    
                    <div style="background: rgba(0, 100, 150, 0.2); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 255, 255, 0.3);">
                        <strong style="color: #00ffff;">${getText('help_title_hotkeys')}</strong><br><br>
                        <div style="line-height: 1.8;">
                            ${getText('hotkeys_tip')}
                        </div>
                    </div>
                </div>
            `;
            
            showFloatingMessage(helpContent, 8000);
        }
        
        function showLevelStory(levelNum, type) {
            const story = storyData.levels[levelNum];
            if (story && story[type]) {
                showStory(story[type], () => {
                    if (type === 'victory') {
                        // 通关剧情后返回关卡选择
                    }
                });
            }
        }
        
        function setDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            sound.uiClick();
            
            // 更新按钮样式 - 增强选中效果
            const easyBtn = document.getElementById('difficultyEasy');
            const normalBtn = document.getElementById('difficultyNormal');
            const hardBtn = document.getElementById('difficultyHard');
            
            // 重置所有按钮
            [easyBtn, normalBtn, hardBtn].forEach(btn => {
                btn.style.boxShadow = 'none';
                btn.style.transform = 'scale(1)';
                btn.style.background = 'transparent';
            });
            
            // 高亮选中的按钮
            if (difficulty === 'easy') {
                easyBtn.style.boxShadow = '0 0 30px #00ff88, inset 0 0 20px rgba(0, 255, 136, 0.2)';
                easyBtn.style.transform = 'scale(1.05)';
                easyBtn.style.background = 'rgba(0, 255, 136, 0.1)';
            } else if (difficulty === 'normal') {
                normalBtn.style.boxShadow = '0 0 30px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.2)';
                normalBtn.style.transform = 'scale(1.05)';
                normalBtn.style.background = 'rgba(0, 255, 255, 0.1)';
            } else if (difficulty === 'hard') {
                hardBtn.style.boxShadow = '0 0 30px #ff0044, inset 0 0 20px rgba(255, 0, 68, 0.2)';
                hardBtn.style.transform = 'scale(1.05)';
                hardBtn.style.background = 'rgba(255, 0, 68, 0.1)';
            }
            
            // 更新难度文字（使用多语言简短版本）
            const difficultyKey = 'difficulty_' + difficulty + '_short';
            document.getElementById('currentDifficultyText').textContent = getText(difficultyKey);
            document.getElementById('currentDifficultyText').style.color = 
                difficulty === 'easy' ? '#00ff88' : (difficulty === 'hard' ? '#ff0044' : '#00ffff');
        }
        
        function showLevelSelect() {
            sound.init();
            sound.uiClick();
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('levelSelectScreen').style.display = 'flex';
            updateLevelCards();
            // 初始化难度选择UI
            setDifficulty(gameState.difficulty);
            
            // 强制显示语言选择器（在关卡选择界面）
            const selector = document.getElementById('languageSelector');
            if (selector) {
                selector.style.display = 'block';
                selector.style.visibility = 'visible';
                selector.style.opacity = '1';
            }
        }
        
        function backToStart() {
            sound.uiClick();
            sound.stopBgm(); // 停止背景音乐
            document.getElementById('levelSelectScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            
            // 显示语言选择器（在主界面）
            showLanguageSelector();
        }
        
        // 记录从哪个界面进入知识库
        let knowledgeLibrarySource = 'levelSelect'; // 'levelSelect' 或 'start'
        
        function openKnowledgeLibrary() {
            sound.uiClick();
            knowledgeLibrarySource = 'levelSelect';
            document.getElementById('levelSelectScreen').style.display = 'none';
            document.getElementById('knowledgeLibraryScreen').style.display = 'flex';
            renderKnowledgeLibrary();
            
            // 显示语言选择器（在知识库界面）
            showLanguageSelector();
        }
        
        function openKnowledgeLibraryFromStart() {
            sound.uiClick();
            knowledgeLibrarySource = 'start';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('knowledgeLibraryScreen').style.display = 'flex';
            renderKnowledgeLibrary();
            
            // 显示语言选择器（在知识库界面）
            showLanguageSelector();
        }
        
        // Credits modal functions
        function openCredits() {
            sound.uiClick();
            document.getElementById('creditsModal').style.display = 'flex';
        }
        
        function closeCredits() {
            sound.uiClick();
            document.getElementById('creditsModal').style.display = 'none';
        }
        
        function switchKnowledgeTab(tabName) {
            sound.uiClick();
            
            // Update tab buttons
            const tabGuide = document.getElementById('tabGuide');
            const tabEncyclopedia = document.getElementById('tabEncyclopedia');
            const contentGuide = document.getElementById('tabContentGuide');
            const contentEncyclopedia = document.getElementById('tabContentEncyclopedia');
            
            if (tabName === 'guide') {
                // Activate guide tab
                tabGuide.classList.add('active');
                tabEncyclopedia.classList.remove('active');
                contentGuide.classList.add('active');
                contentEncyclopedia.classList.remove('active');
            } else {
                // Activate encyclopedia tab
                tabGuide.classList.remove('active');
                tabEncyclopedia.classList.add('active');
                contentGuide.classList.remove('active');
                contentEncyclopedia.classList.add('active');
            }
        }
        
        function backToLevelSelect() {
            sound.uiClick();
            document.getElementById('knowledgeLibraryScreen').style.display = 'none';
            
            // 根据来源返回到正确的界面
            if (knowledgeLibrarySource === 'start') {
                // 从主菜单进入的，返回主菜单
                document.getElementById('startScreen').style.display = 'flex';
                document.getElementById('levelSelectScreen').style.display = 'none';
            } else {
                // 从选关界面进入的，返回选关界面
                document.getElementById('levelSelectScreen').style.display = 'flex';
                document.getElementById('startScreen').style.display = 'none';
            }
            
            // 隐藏故事卡片
            document.getElementById('storyModal').style.display = 'none';
            
            // 移除链灵对话框
            const dialogueOverlay = document.getElementById('dialogueOverlay');
            if (dialogueOverlay) {
                dialogueOverlay.remove();
            }
            
            // 显示语言选择器
            showLanguageSelector();
        }
        
        function backToMainMenu() {
            sound.uiClick();
            document.getElementById('knowledgeLibraryScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('levelSelectScreen').style.display = 'none';
        }
        
        function closeKnowledgeLibrary() {
            sound.uiClick();
            document.getElementById('knowledgeLibraryScreen').style.display = 'none';
            
            // 检查是否应该返回主菜单还是关卡选择
            if (document.getElementById('startScreen').style.display === 'none' && 
                document.getElementById('levelSelectScreen').style.display === 'none') {
                // 从主菜单打开的，返回主菜单
                document.getElementById('startScreen').style.display = 'flex';
            } else {
                // 从关卡选择打开的，返回关卡选择
                document.getElementById('levelSelectScreen').style.display = 'flex';
            }
            
            // 显示语言选择器
            showLanguageSelector();
        }
        
        function renderKnowledgeLibrary() {
            // 动态渲染知识库内容以支持多语言
            const container = document.getElementById('knowledgeLibraryScreen');
            if (!container) return;
            
            // 更新所有带data-i18n属性的元素
            container.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                const text = getText(key);
                if (text.includes('<') || text.includes('<br>')) {
                    element.innerHTML = text;
                } else {
                    element.textContent = text;
                }
            });
            
            // 更新所有knowledge-box中的属性文本
            // 创建一个映射表，包含所有可能的翻译（中英日）
            const statTranslations = {
                // 中文
                '成本': 'panel_stat_cost',
                '射程': 'panel_stat_range',
                '伤害': 'panel_stat_damage',
                '攻速': 'panel_stat_speed',
                '收入': 'panel_stat_income',
                '出售回收': 'panel_stat_sell_refund',
                '使用': 'panel_stat_uses',
                'AOE伤害': 'panel_stat_aoe_damage',
                '范围': 'panel_stat_range',
                '加速': 'panel_stat_boost',
                '减速': 'panel_stat_slow',
                // 英文
                'Cost': 'panel_stat_cost',
                'Range': 'panel_stat_range',
                'Damage': 'panel_stat_damage',
                'Speed': 'panel_stat_speed',
                'Income': 'panel_stat_income',
                'Refund on sell': 'panel_stat_sell_refund',
                'Uses': 'panel_stat_uses',
                'AOE Damage': 'panel_stat_aoe_damage',
                'Boost': 'panel_stat_boost',
                'Slow': 'panel_stat_slow',
                // 日文
                'コスト': 'panel_stat_cost',
                'ダメージ': 'panel_stat_damage',
                '射程': 'panel_stat_range',
                '攻速': 'panel_stat_speed',
                '攻撃速度': 'panel_stat_speed',
                '収入': 'panel_stat_income',
                '売却回収': 'panel_stat_sell_refund',
                '使用': 'panel_stat_uses',
                'AOEダメージ': 'panel_stat_aoe_damage',
                '加速': 'panel_stat_boost',
                '減速': 'panel_stat_slow'
            };
            
            container.querySelectorAll('.knowledge-box').forEach(box => {
                let html = box.innerHTML;
                
                // 按照从长到短的顺序替换，避免部分匹配问题
                const sortedKeys = Object.keys(statTranslations).sort((a, b) => b.length - a.length);
                
                for (const oldText of sortedKeys) {
                    const key = statTranslations[oldText];
                    const newText = getText(key);
                    // 使用正则表达式进行全局替换
                    const regex = new RegExp(oldText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                    html = html.replace(regex, newText);
                }
                
                box.innerHTML = html;
            });
        }
        
        function showTowerKnowledge(towerType) {
            sound.uiClick();
            const towerDef = towerDefs[towerType];
            const knowledgeCard = knowledgeCards.towers[towerType];
            
            // 为不同的塔设置不同的图标大小，让所有图标看起来一样大
            const iconSizes = {
                validator: '160px',  // 验证节点作为基准
                miner: '160px',
                gasStation: '160px',
                contract: '160px',
                sharding: '200px',   // 分片炮需要更大
                zkSniper: '200px',   // ZK狙击需要更大
                l2Channel: '200px',  // L2通道需要更大
                mainnetCannon: '200px' // 主网大炮需要更大
            };
            const fontSize = iconSizes[towerType] || '160px';
            document.getElementById('knowledgeModalIcon').innerHTML = `<div style="font-size: ${fontSize}; line-height: 1; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">${towerDef.icon}</div>`;
            document.getElementById('knowledgeModalTitle').textContent = getText(`knowledge_${towerType}_title`) + ' - ' + getTowerName(towerType, 1);
            
            // 使用翻译系统构建完整的知识卡片内容
            document.getElementById('knowledgeModalDesc').innerHTML = `
                <div class="knowledge-section">
                    <div class="knowledge-content" style="font-size: 14px; line-height: 1.8; text-align: left;">
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_principle')}：</strong>${getText(`knowledge_${towerType}_principle`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_analogy')}：</strong>${getText(`knowledge_${towerType}_analogy`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_application')}：</strong>${getText(`knowledge_${towerType}_application`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_gameplay')}：</strong>${getText(`knowledge_${towerType}_gameplay`)}</div>
                    </div>
                </div>
            `;
            document.getElementById('knowledgeModalOverlay').style.display = 'flex';
        }
        
        function showEnemyKnowledge(enemyType) {
            sound.uiClick();
            const enemyDef = enemyDefs[enemyType];
            const knowledgeCard = knowledgeCards.enemies[enemyType];
            
            // 映射敌人类型到翻译键
            const enemyTypeMap = {
                'doubleSpend': 'doublespend',
                'shielded': 'armored',
                'healer': 'vampire'
            };
            const translationKey = enemyTypeMap[enemyType] || enemyType;
            
            document.getElementById('enemyModalIcon').textContent = enemyDef.icon;
            document.getElementById('enemyModalTitle').textContent = getText(`knowledge_${translationKey}_title`);
            
            // 使用翻译系统构建完整的敌人知识内容
            document.getElementById('enemyModalDesc').innerHTML = `
                <div class="knowledge-section">
                    <div class="knowledge-content" style="font-size: 14px; line-height: 1.8; text-align: left;">
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_principle')}：</strong>${getText(`knowledge_${translationKey}_principle`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_analogy')}：</strong>${getText(`knowledge_${translationKey}_analogy`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_application')}：</strong>${getText(`knowledge_${translationKey}_application`)}</div>
                        <div style="margin-bottom: 12px;"><strong>${getText('knowledge_label_gameplay')}：</strong>${getText(`knowledge_${translationKey}_gameplay`)}</div>
                    </div>
                </div>
            `;
            document.getElementById('enemyModalOverlay').style.display = 'flex';
        }
        
        // ==================== TUTORIAL SYSTEM ====================
        let tutorialState = {
            active: false,
            currentStep: 0,
            steps: [
                {
                    icon: '👋',
                    title: '欢迎来到 Block Rush！',
                    text: '这是一个教育性的塔防游戏。让我们快速学习如何游玩！',
                    highlight: null,
                    arrow: null,
                    action: null
                },
                {
                    icon: '🛡️',
                    title: '选择防御塔',
                    text: '点击左侧的"验证哨"按钮来选择你的第一个防御塔',
                    highlight: () => document.querySelector('[data-tower="validator"]'),
                    arrow: { x: -60, y: 0 },
                    action: 'selectTower'
                },
                {
                    icon: '📍',
                    title: '放置防御塔',
                    text: '在路径旁边的空地上点击来放置防御塔。防御塔会自动攻击范围内的敌人',
                    highlight: null,
                    arrow: null,
                    action: 'placeTower'
                },
                {
                    icon: '🚀',
                    title: '开始波次',
                    text: '点击路径入口的红色图标来开始第一波敌人',
                    highlight: () => document.getElementById('spawnIcon'),
                    arrow: { x: 0, y: -60 },
                    action: 'startWave'
                },
                {
                    icon: '⬆️',
                    title: '升级防御塔',
                    text: '点击已放置的防御塔可以查看信息和升级。升级会提升攻击力和射程',
                    highlight: null,
                    arrow: null,
                    action: null
                },
                {
                    icon: '✅',
                    title: '准备好了！',
                    text: '你已经掌握了基础操作！现在开始守护区块链的安全吧！',
                    highlight: null,
                    arrow: null,
                    action: null
                }
            ]
        };
        
        function startTutorial() {
            tutorialState.active = true;
            tutorialState.currentStep = 0;
            gameState.paused = true;
            showTutorialStep();
        }
        
        function showTutorialStep() {
            const step = tutorialState.steps[tutorialState.currentStep];
            const overlay = document.getElementById('tutorialOverlay');
            const highlight = document.getElementById('tutorialHighlight');
            const message = document.getElementById('tutorialMessage');
            const arrow = document.getElementById('tutorialArrow');
            
            // 显示覆盖层
            overlay.style.display = 'block';
            
            // 更新消息内容
            document.getElementById('tutorialIcon').textContent = step.icon;
            document.getElementById('tutorialTitle').textContent = step.title;
            document.getElementById('tutorialText').textContent = step.text;
            
            // 更新按钮文本
            const nextBtn = document.getElementById('tutorialNextBtn');
            if (tutorialState.currentStep === tutorialState.steps.length - 1) {
                nextBtn.textContent = '开始游戏';
            } else if (step.action) {
                nextBtn.style.display = 'none';
            } else {
                nextBtn.style.display = 'block';
                nextBtn.textContent = '下一步';
            }
            
            // 高亮元素
            if (step.highlight && typeof step.highlight === 'function') {
                const element = step.highlight();
                if (element) {
                    const rect = element.getBoundingClientRect();
                    highlight.style.display = 'block';
                    highlight.style.left = rect.left - 10 + 'px';
                    highlight.style.top = rect.top - 10 + 'px';
                    highlight.style.width = rect.width + 20 + 'px';
                    highlight.style.height = rect.height + 20 + 'px';
                    
                    // 定位消息框
                    message.style.left = rect.right + 30 + 'px';
                    message.style.top = rect.top + 'px';
                    
                    // 显示箭头
                    if (step.arrow) {
                        arrow.style.display = 'block';
                        arrow.style.left = rect.left + rect.width / 2 + step.arrow.x + 'px';
                        arrow.style.top = rect.top + rect.height / 2 + step.arrow.y + 'px';
                    } else {
                        arrow.style.display = 'none';
                    }
                } else {
                    highlight.style.display = 'none';
                    arrow.style.display = 'none';
                    message.style.left = '50%';
                    message.style.top = '50%';
                    message.style.transform = 'translate(-50%, -50%)';
                }
            } else {
                highlight.style.display = 'none';
                arrow.style.display = 'none';
                message.style.left = '50%';
                message.style.top = '50%';
                message.style.transform = 'translate(-50%, -50%)';
            }
        }
        
        function nextTutorialStep() {
            sound.uiClick();
            tutorialState.currentStep++;
            
            if (tutorialState.currentStep >= tutorialState.steps.length) {
                endTutorial();
            } else {
                showTutorialStep();
            }
        }
        
        function skipTutorial() {
            sound.uiClick();
            endTutorial();
        }
        
        function endTutorial() {
            tutorialState.active = false;
            document.getElementById('tutorialOverlay').style.display = 'none';
            gameState.paused = false;
            localStorage.setItem('tutorialCompleted', 'true');
        }
        
        // 监听游戏事件以推进教程
        const originalPlaceTower = placeTower;
        window.placeTower = function(...args) {
            const result = originalPlaceTower.apply(this, args);
            if (tutorialState.active && tutorialState.steps[tutorialState.currentStep].action === 'placeTower') {
                nextTutorialStep();
            }
            return result;
        };
        
        function updateLevelCards() {
            console.log('updateLevelCards called, unlockedLevels:', unlockedLevels);
            document.querySelectorAll('.level-card').forEach(card => {
                const levelId = card.dataset.level;
                const levelColor = card.dataset.color;
                
                // 确保CSS变量被设置
                if (levelColor) {
                    card.style.setProperty('--level-color', levelColor);
                }
                
                // 无尽模式特殊处理
                if (levelId === 'endless') {
                    const endlessUnlocked = unlockedLevels.includes('endless');
                    const statusElement = card.querySelector('.level-status');
                    card.classList.remove('locked', 'unlocked');
                    if (endlessUnlocked) {
                        card.classList.add('unlocked');
                        statusElement.textContent = getText('level_status_challenge');
                        // 无尽模式解锁后也使用实心填充样式
                        statusElement.classList.add('primary-action');
                        console.log('Endless mode unlocked');
                    } else {
                        card.classList.add('locked');
                        statusElement.classList.remove('primary-action');
                        console.log('Endless mode locked');
                    }
                    return;
                }
                
                const levelNum = parseInt(levelId);
                const isUnlocked = unlockedLevels.includes(levelNum);
                const isCompleted = completedLevels.includes(levelNum);
                
                console.log(`Level ${levelNum}: unlocked=${isUnlocked}, completed=${isCompleted}`);
                
                card.classList.remove('locked', 'unlocked', 'completed');
                
                const statusElement = card.querySelector('.level-status');
                
                if (isCompleted) {
                    card.classList.add('completed', 'unlocked');
                    statusElement.textContent = getText('level_status_replay');
                    statusElement.classList.remove('primary-action');
                } else if (isUnlocked) {
                    card.classList.add('unlocked');
                    statusElement.textContent = getText('level_status_start');
                    // 所有已解锁但未完成的关卡都使用实心填充样式
                    statusElement.classList.add('primary-action');
                } else {
                    card.classList.add('locked');
                    statusElement.textContent = getText('unlock_status_template', levelNum - 1);
                    statusElement.classList.remove('primary-action');
                }
            });
        }
        
        // 存储选中的关卡
        let selectedLevelNum = null;
        
        function selectLevel(levelNum) {
            if (!unlockedLevels.includes(levelNum)) {
                sound.towerError();
                return;
            }
            
            sound.uiClick();
            
            // 如果点击的是已选中的关卡，则取消选择
            if (selectedLevelNum === levelNum) {
                // 取消选择
                selectedLevelNum = null;
                
                // 移除所有选中状态
                document.querySelectorAll('.level-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                // 隐藏开始部署按钮
                document.getElementById('startDeployBtn').style.display = 'none';
                return;
            }
            
            // 选择新关卡
            selectedLevelNum = levelNum;
            
            // 更新卡片选中状态
            document.querySelectorAll('.level-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelector(`.level-card[data-level="${levelNum}"]`).classList.add('selected');
            
            // 显示开始部署按钮
            document.getElementById('startDeployBtn').style.display = 'inline-block';
        }
        
        function startSelectedLevel() {
            if (!selectedLevelNum) {
                sound.towerError();
                return;
            }
            
            const levelNum = selectedLevelNum;
            sound.uiClick();
            
            // 停止当前游戏循环
            gameState.running = false;
            
            // 确保UI状态正确
            document.getElementById('levelSelectScreen').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            
            // 隐藏语言选择器（游戏进行中）
            hideLanguageSelector();
            
            // 第一关触发序章对话和教程（只在非重试时）
            // 判断是否是重试：只有当游戏正在运行且关卡相同时才算重试
            const isRetry = gameState.running && gameState.level === levelNum;
            const shouldShowPrologue = levelNum === 1 && !localStorage.getItem('prologueShown') && !isRetry;
            
            if (levelNum === 1 && !localStorage.getItem('tutorialCompleted') && !isRetry) {
                setTimeout(() => startTutorial(), 500);
            }
            
            const level = levelNum === 'endless' ? levels[levels.length - 1] : levels[levelNum - 1];
            
            // 完全重置游戏状态
            gameState.balance = level.startBalance;
            // 无尽模式初始生命值为1，其他关卡保持原有逻辑
            if (levelNum === 'endless' || levelNum === 6) {
                gameState.lives = 1;
                gameState.maxLives = 1;
            } else {
                gameState.lives = 1;
                gameState.maxLives = 1;
            }
            gameState.towers = [];
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.particles = [];
            gameState.floatingTexts = [];
            gameState.laserBeams = [];
            gameState.gameOver = false;
            gameState.gameOverShown = false;
            gameState.victory = false;
            gameState.waveInProgress = false;
            gameState.wavePreparation = false;
            gameState.paused = false;
            gameState.spacePaused = false;
            gameState.modalPaused = false;
            gameState.preparationTimer = 0;
            gameState.selectedTower = null;
            gameState.selectedPlacedTower = null;
            gameState.selectedEnemy = null;
            gameState.cannonTargetMode = false;
            gameState.selectedCannon = null;
            
            // 确保所有模态框和覆盖层都被隐藏
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('spacePauseOverlay').style.display = 'none';
            document.getElementById('enemyModalOverlay').style.display = 'none';
            document.getElementById('knowledgeModalOverlay').style.display = 'none';
            
            gameState.unlockedTowers = ['validator', 'miner', 'gasStation', 'contract'];
            
            // 无限模式解锁所有炮台
            if (levelNum === 'endless') {
                gameState.unlockedTowers = ['validator', 'miner', 'gasStation', 'contract', 'sharding', 'zkSniper', 'l2Channel', 'mainnetCannon'];
            } else {
                // 普通关卡根据进度解锁
                for (let i = 1; i <= levelNum; i++) {
                    const lvl = levels[i - 1];
                    if (lvl.unlockTower && !gameState.unlockedTowers.includes(lvl.unlockTower)) {
                        gameState.unlockedTowers.push(lvl.unlockTower);
                    }
                }
            }
            
            document.querySelectorAll('[data-tower]').forEach(el => {
                const type = el.dataset.tower;
                if (gameState.unlockedTowers.includes(type)) {
                    el.classList.remove('locked');
                } else {
                    el.classList.add('locked');
                }
            });
            
            // 更新塔按钮状态（高亮可购买的塔）
            updateTowerButtonStates();
            
            gameState.running = true;
            
            // 处理序章对话
            if (shouldShowPrologue) {
                localStorage.setItem('prologueShown', 'true');
                showDialogue('prologue', () => {
                    // 序章对话结束后开始关卡
                    startLevel(levelNum, isRetry);
                });
            } else {
                startLevel(levelNum, isRetry);
            }
        }
        
        function completeLevel() {
            const currentLevel = gameState.level;
            
            if (!completedLevels.includes(currentLevel)) {
                completedLevels.push(currentLevel);
            }
            if (currentLevel < 5 && !unlockedLevels.includes(currentLevel + 1)) {
                unlockedLevels.push(currentLevel + 1);
            }
            
            sound.waveComplete();
            
            // 先显示链灵胜利对话
            const dialogueKey = `level${currentLevel}`;
            if (chainSpiritDialogues[dialogueKey] && chainSpiritDialogues[dialogueKey].victory) {
                // 先暂停游戏
                gameState.running = false;
                
                // 显示链灵胜利对话
                const victoryDialogue = {
                    character: '链灵',
                    icon: '✨',
                    intro: chainSpiritDialogues[dialogueKey].victory
                };
                dialogueState.currentDialogue = victoryDialogue;
                dialogueState.currentIndex = 0;
                dialogueState.active = true;
                dialogueState.callback = () => {
                    // 对话结束后显示通关剧情
                    const levelStory = storyData.levels[currentLevel];
                    if (levelStory && levelStory.victory) {
                        showStory(levelStory.victory, () => {
                            if (currentLevel >= 5) {
                                // 解锁无尽模式
                                if (!unlockedLevels.includes('endless')) {
                                    unlockedLevels.push('endless');
                                }
                                // 第五关完成后显示胜利界面
                                showVictoryScreen();
                            } else {
                                showLevelCompleteMessage(currentLevel);
                            }
                        });
                    } else {
                        if (currentLevel >= 5) {
                            // 解锁无尽模式
                            if (!unlockedLevels.includes('endless')) {
                                unlockedLevels.push('endless');
                            }
                            // 第五关完成后显示胜利界面
                            showVictoryScreen();
                        } else {
                            showLevelCompleteMessage(currentLevel);
                        }
                    }
                };
                displayCurrentDialogue();
            } else {
                // 没有链灵对话时直接显示通关剧情
                const levelStory = storyData.levels[currentLevel];
                if (levelStory && levelStory.victory) {
                    // 先暂停游戏
                    gameState.running = false;
                    showStory(levelStory.victory, () => {
                        if (currentLevel >= 5) {
                            // 解锁无尽模式
                            if (!unlockedLevels.includes('endless')) {
                                unlockedLevels.push('endless');
                            }
                            // 第五关完成后显示胜利界面
                            showVictoryScreen();
                        } else {
                            showLevelCompleteMessage(currentLevel);
                        }
                    });
                } else {
                    if (currentLevel >= 5) {
                        // 解锁无尽模式
                        if (!unlockedLevels.includes('endless')) {
                            unlockedLevels.push('endless');
                        }
                        // 第五关完成后显示胜利界面
                        showVictoryScreen();
                    } else {
                        showLevelCompleteMessage(currentLevel);
                    }
                }
            }
        }
        
        function showVictoryScreen() {
            sound.victory();
            document.getElementById('gameUI').style.display = 'none';
            const victoryScreen = document.getElementById('victoryScreen');
            victoryScreen.style.display = 'flex';
            // 移除之前的动画类（如果有）
            victoryScreen.classList.remove('slide-up');
            // 强制重排以重新触发动画
            void victoryScreen.offsetWidth;
            // 添加动画类
            victoryScreen.classList.add('slide-up');
            showLanguageSelector();
        }
        
        function showLevelCompleteMessage(levelNum) {
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height * 0.5;
                    gameState.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: Math.random() * -5,
                        life: 40,
                        color: ['#00ffff', '#00ff88', '#ffcc00', '#ff00aa'][Math.floor(Math.random() * 4)],
                        size: Math.random() * 10 + 5
                    });
                }, i * 50);
            }
            
            addFloatingText(canvas.width / 2, canvas.height / 2 - 50, `关卡 ${levelNum} 完成!`, '#00ff88');
            addFloatingText(canvas.width / 2, canvas.height / 2, `下一关已解锁！`, '#00ffff');
            
            // 立即跳转，不等待
            if (!gameState.gameOver && !gameState.victory) {
                returnToLevelSelect();
            }
        }
        
        function startEndlessMode() {
            // 从胜利界面直接进入无尽模式
            document.getElementById('victoryScreen').style.display = 'none';
            gameState.victory = false;
            
            // 设置选中的关卡为无尽模式
            selectedLevelNum = 'endless';
            
            // 直接启动无尽模式
            startSelectedLevel();
        }
        
        function returnToLevelSelect() {
            gameState.running = false;
            gameState.paused = false;
            gameState.spacePaused = false;
            gameState.modalPaused = false;
            gameState.wavePreparation = false;
            sound.stopBgm(); // 停止背景音乐
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('spacePauseOverlay').style.display = 'none';
            document.getElementById('enemyModalOverlay').style.display = 'none';
            document.getElementById('knowledgeModalOverlay').style.display = 'none';
            document.getElementById('storyModal').style.display = 'none';
            
            // 移除链灵对话框
            const dialogueOverlay = document.getElementById('dialogueOverlay');
            if (dialogueOverlay) {
                dialogueOverlay.remove();
            }
            
            document.getElementById('levelSelectScreen').style.display = 'flex';
            updateLevelCards();
            
            // 显示语言选择器（返回关卡选择界面）
            showLanguageSelector();
        }
        
        function restartCurrentLevel() {
            const currentLevelNum = gameState.level;
            
            // 重置所有状态
            gameState.paused = false;
            gameState.gameOver = false;
            gameState.gameOverShown = false;
            gameState.victory = false;
            gameState.running = false;
            
            // 隐藏所有界面
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('spacePauseOverlay').style.display = 'none';
            document.getElementById('enemyModalOverlay').style.display = 'none';
            document.getElementById('knowledgeModalOverlay').style.display = 'none';
            document.getElementById('storyModal').style.display = 'none';
            
            // 移除链灵对话框
            const dialogueOverlay = document.getElementById('dialogueOverlay');
            if (dialogueOverlay) {
                dialogueOverlay.remove();
            }
            
            // 设置选中的关卡并直接开始
            selectedLevelNum = currentLevelNum;
            startSelectedLevel();
        }
        
        // Start
        gameLoop();
    </script>
</body>
</html>